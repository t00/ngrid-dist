{"version":3,"file":"pebula-utils.js","sources":["ng://@pebula/utils/lib/unrx.ts","ng://@pebula/utils/lib/array.ts"],"sourcesContent":["import { Observable, Subject } from 'rxjs';\nimport { filter, takeUntil } from 'rxjs/operators';\n\n/**\n * Emits the values emitted by the source observable until a kill signal is sent to the group.\n * You can also specify a `subKillGroup` which can be used to kill specific subscriptions within a group.\n *\n * When a `killGroup` is \"killed\" all `subKillGroup` are killed as well. When a `subKillGroup` is \"killed\" the group remains\n * as well as other \"subKillGroup\" registered for that group.\n *\n * > WARNING: Do not apply operators that subscribe internally (e.g. combineLatest, switchMap) after the `killOnDestroy` operator.\n * Internal subscriptions will not unsubscribe automatically.\n * For more information see {@link https://blog.angularindepth.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef | this blog post}\n */\nexport function unrx<T>(killGroup: any, subKillGroup?: any): (source: Observable<T>) => Observable<T> {\n  return unrx.pipe<T>(killGroup, subKillGroup);\n}\n\nexport namespace unrx {\n  const ALL_HANDLERS_TOKEN = {};\n  const notifierStore = new WeakMap<any, Subject<any>>();\n\n  function getNotifier(component: any, create = false): Subject<any> | undefined {\n    let notifier = notifierStore.get(component);\n    if (!notifier && create === true) {\n      notifierStore.set(component, notifier = new Subject<any>());\n    }\n    return notifier;\n  }\n\n  /**\n   * Send a \"kill\" signal to the specified `killGroup`.\n   * This will immediately unsubscribe all subscriptions with the `unrx` pipe registered under the specified `killGroup`.\n   *\n   * Note that the entire `killGroup` is destroyed.\n   */\n  export function kill(killGroup: any): void;\n  /**\n   * Send a \"kill\" signal to a specific `subKillGroup` in the specified `killGroup`.\n   * This will immediately unsubscribe all subscriptions with the `unrx` pipe registered under the specified `killGroup` and `subKillGroup`.\n   *\n   */\n  export function kill(killGroup: any, ...subKillGroup: any[]): void;\n  export function kill(killGroup: any, ...subKillGroup: any[]): void {\n    if (subKillGroup.length === 0) {\n      killAll(killGroup);\n    } else {\n      const notifier = getNotifier(killGroup);\n      if (notifier) {\n        for (const h of subKillGroup) {\n          notifier.next(h);\n        }\n      }\n    }\n  }\n\n  /** {@inheritdoc unrx} */\n  export function pipe<T>(killGroup: any, subKillGroup?: any): (source: Observable<T>) => Observable<T> {\n    return (source: Observable<T>) => source.pipe(\n      takeUntil(getNotifier(killGroup, true).pipe(filter( h => h === ALL_HANDLERS_TOKEN || (subKillGroup && h === subKillGroup ) )))\n    );\n  }\n\n  function killAll(obj: any): void {\n    const notifier = getNotifier(obj);\n    if (notifier) {\n      notifier.next(ALL_HANDLERS_TOKEN);\n      notifier.complete();\n      notifierStore.delete(obj);\n    }\n  }\n}\n\n/**\n * Emits the values emitted by the source Observable until the angular component instance is destroyed. (`ngOnDestroy` is called).\n * If the component already implements `ngOnDestroy` it will wrap it.\n *\n * You can also destroy on-demand by providing a handler and use `UnRx.kill` to unsubscribe.\n * Note that using the same handler id for multiple subscriptions will kill all of them together, i.e. the handler is also a group.\n *\n * > WARNING: Do not apply operators that subscribe internally (e.g. combineLatest, switchMap) after the `killOnDestroy` operator.\n * Internal subscriptions will not unsubscribe automatically. For more information see https://blog.angularindepth.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef\n */\nexport function UnRx<T>(component: any, handler?: any): (source: Observable<T>) => Observable<T>;\n/**\n * A Decorator that add support for automatic unsubscription in angular components.\n *\n * When applied on a component, `UnRx` will wrap the `ngOnDestroy` life-cycle` hook (or create if doesn't exist) and automatically\n * destroy all open subscriptions that contain the `UnRx` pipe in their emission stream.\n *\n * @remarks\n *\n * The following example demonstrate a component using the HTTP client to call a server.\n * We add the `UnRx` pipe to the response observable (`pipe(UnRx(this))`) so when the component is destroyed the subscription is closed as well.\n *\n * This might seem redundant because the `HttpClient` will automatically close the subscription after the response but what happen when\n * the response arrived AFTER the component is destroyed (user left the page)?\n *\n * In this case the subscription will emit the response and the handler will run, we don't want that!\n *\n * By applying the pipe we ensure that nothing will run once the component is destroyed.\n *\n * The BIG BONUS here is http cancellation, once destroyed `UnRx` will close the subscription which will cancel the HTTP request!\n * ```ts\n * import { Component } from '@angular/core';\n * import { HttpClient } from '@angular/common/http';\n *\n * @Component({\n *  selector: 'my-cmp',\n *  template: ``\n * })\n * @UnRx() // Will un-subscribe all open subscriptions when component is destroyed\n * export class MyComponent {\n *   static URL = '/some-endpoint';\n *\n *   constructor(private http: HttpClient) { }\n *\n *   getData() {\n *     this.http.get(MyComponent.URL)\n *       .pipe(UnRx(this))             // Register the stream for auto-kill on destroy\n *       .subscribe( response => {\n *         console.log(response);\n *       });\n *   }\n * }\n * ```\n *\n * The following example is an improved version of the previous one.\n * All pending request will be cancelled when the component is destroyed but we will also cancel all pending requests\n * when a new request is fired.\n *\n * With this we ensure state and flow integrity (no race condition between 2 requests).\n * We also make sure that resources are not wasted (multiple redundant requests.)\n * ```ts\n * import { Component } from '@angular/core';\n * import { HttpClient } from '@angular/common/http';\n *\n * @Component({\n *  selector: 'my-cmp',\n *  template: ``\n * })\n * @UnRx() // Will un-subscribe all open subscriptions when component is destroyed\n * export class MyComponent {\n *   static URL = '/some-endpoint';\n *\n *   constructor(private http: HttpClient) { }\n *\n *   getData() {\n *     UnRx.kill(this, MyComponent.URL); // Kill (cancel) pending HTTP requests\n *     this.http.get(MyComponent.URL)\n *       .pipe(UnRx(this, MyComponent.URL)) // Register the stream for auto-kill on destroy and add a handler for ad-hoc unsubscribe\n *       .subscribe( response => {\n *         console.log(response);\n *       });\n *   }\n * }\n * ```\n *\n * @internalremarks\n * Based on work from:\n *   - https://github.com/w11k/ng2-rx-componentdestroyed/blob/master/src/index.ts\n *   - https://stackoverflow.com/questions/38008334/angular-rxjs-when-should-i-unsubscribe-from-subscription/41177163#41177163\n */\nexport function UnRx<T = any>(): ClassDecorator;\nexport function UnRx<T>(component?: any, handler?: any): ClassDecorator | ( (source: Observable<T>) => Observable<T> ) {\n  return component\n    ? unrx<T>(component, handler)\n    : UnRx.decorateComponent\n  ;\n}\n\nexport namespace UnRx {\n  const originalOnDestroyFunctionStore = new Map<any, () => void>();\n\n  function ngOnDestroy(): void {\n    const oldNgOnDestroy = originalOnDestroyFunctionStore.get(this.constructor);\n    if (oldNgOnDestroy) {\n      oldNgOnDestroy.apply(this);\n    }\n    unrx.kill(this);\n  }\n\n  export function decorateComponent(target: any): any {\n    const proto = target.prototype;\n    if (proto.ngOnDestroy) {\n      originalOnDestroyFunctionStore.set(target, proto.ngOnDestroy);\n    }\n    proto.ngOnDestroy = ngOnDestroy;\n    return target;\n  }\n\n  /**\n   * Send a \"kill\" signal to the specified `component` instance.\n   * This will immediately unsubscribe all subscriptions with the `UnRx` pipe registered under the specified component instance.\n   */\n  export function kill(killGroup: any): void;\n  /**\n   * Send a \"kill\" signal to a specific `token` in the specified `component` instance.\n   * This will immediately unsubscribe all subscriptions with the `UnRx` pipe registered under the specified `component` instance and `token`.\n   *\n   */\n  export function kill(component: any, ...tokens: any[]): void;\n  export function kill(component: any, ...tokens: any[]): void {\n    unrx.kill(component, ...tokens);\n  }\n\n}\n","export function removeFromArray<T = any>(arr: T[], predicate: (value: T, index?: number) => boolean): boolean;\nexport function removeFromArray<T = any>(arr: T[], value: T): boolean;\nexport function removeFromArray<T = any>(arr: T[], values: T[]): boolean[];\nexport function removeFromArray<T = any>(arr: T[], value: T | T[] | ((value: T, index?: number) => boolean)): boolean | boolean[] {\n  if (Array.isArray(value)) {\n    return value.map( v => _removeFromArray(arr, v) );\n  } else if (typeof value === 'function') {\n    const idx = arr.findIndex(value as any);\n    if (idx > -1) {\n      arr.splice(idx, 1);\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return _removeFromArray<T>(arr, value);\n  }\n}\n\nfunction _removeFromArray<T = any>(arr: T[], value: T): boolean {\n  const idx = arr.indexOf(value);\n  if (idx > -1) {\n    arr.splice(idx, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n"],"names":["tslib_1.__values"],"mappings":"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"}