{"version":3,"file":"pebula-ngrid-testing.js","sources":["../../../../libs/ngrid/testing/src/lib/utils/matching.ts","../../../../libs/ngrid/testing/src/lib/utils/mixin.ts","../../../../libs/ngrid/testing/src/lib/cell/ngrid-column-cell-harness.ts","../../../../libs/ngrid/testing/src/lib/row/ngrid-column-row-harness.ts","../../../../libs/ngrid/testing/src/lib/grid/ngrid-component-harness.ts","../../../../libs/ngrid/testing/src/lib/grid/actions.ts","../../../../libs/ngrid/testing/src/pebula-ngrid-testing.ts"],"sourcesContent":["import { TestElement } from '@angular/cdk/testing';\n\nexport async function findHostClassMatch(hostElement: TestElement, regExp: RegExp): Promise<RegExpMatchArray | undefined> {\n  const classAttribute = await hostElement.getAttribute('class');\n  return findClassMatch(classAttribute, regExp);\n}\n\nexport function findClassMatch(classAttributeValue: string, regExp: RegExp): RegExpMatchArray | undefined {\n  for (const c of classAttributeValue.split(' ')) {\n    const match = c.trim().match(regExp);\n    if (match) {\n      return match;\n    }\n  }\n}\n","/* tslint:disable:max-line-length */\nexport interface Constructor<T> extends Function {\n  // tslint:disable-next-line: callable-types\n  new (...args: any[]): T;\n}\n\nexport type Mixin<BASE, MIXIN> = BASE & MIXIN;\n\nfunction mixObjects(base: any, mixins: any[]): void {\n  mixins.forEach(mixin => {\n    Object.getOwnPropertyNames(mixin)\n      .concat(Object.getOwnPropertySymbols(mixin) as any)\n      .forEach(name => {\n        // mixin can't override base behavior, only add\n        if (!base.hasOwnProperty(name)) {\n          // if its a property descriptor we need to rewire the context\n          const propDesc = Object.getOwnPropertyDescriptor(mixin, name);\n          if (propDesc) {\n            Object.defineProperty(base, name, propDesc);\n          } else {\n            base[name] = mixin[name];\n          }\n        }\n      });\n  });\n}\n\n/**\n * Type-less mixin\n */\nexport function MixinFree(base: any, mixin: any, extend: 'class' | 'proto' | 'both' = 'both'): any {\n  if (extend === 'proto' || extend === 'both') {\n    mixObjects(base.prototype, [mixin.prototype]);\n  }\n  if (extend === 'class' || extend === 'both') {\n    mixObjects(base, [mixin]);\n  }\n  return base as any;\n}\n\nexport function Mixin<TBASE, CBASE, T1, C1>(base: CBASE & Constructor<TBASE>, m1: C1 & Constructor<T1>): Constructor<TBASE & T1> & CBASE & C1;\nexport function Mixin<TBASE, CBASE, T1, C1, T2, C2>(base: CBASE & Constructor<TBASE>, m1: C1 & Constructor<T1>, m2: C2 & Constructor<T2>): Constructor<TBASE & T1 & T2> & CBASE & C1 & C2;\nexport function Mixin<TBASE, CBASE, T1, C1, T2, C2, T3, C3>(base: CBASE & Constructor<TBASE>, m1: C1 & Constructor<T1>, m2: C2 & Constructor<T2>, m3: C3 & Constructor<T3>): Constructor<TBASE & T1 & T2 & T3> & CBASE & C1 & C2 & C3;\nexport function Mixin<TBASE, CBASE, T1, C1, T2, C2, T3, C3, T4, C4>(base: CBASE & Constructor<TBASE>, m1: C1 & Constructor<T1>, m2: C2 & Constructor<T2>, m3: C3 & Constructor<T3>, m4: C4 & Constructor<T4>): Constructor<TBASE & T1 & T2 & T3 & T4> & CBASE & C1 & C2 & C3 & C4;\nexport function Mixin<TBASE, CBASE, T1, C1, T2, C2, T3, C3, T4, C4, T5, C5>(base: CBASE & Constructor<TBASE>, m1: C1 & Constructor<T1>, m2: C2 & Constructor<T2>, m3: C3 & Constructor<T3>, m4: C4 & Constructor<T4>, m5: C5 & Constructor<T5>): Constructor<TBASE & T1 & T2 & T3 & T4 & T5> & CBASE & C1 & C2 & C3 & C4 & C5;\nexport function Mixin<TBASE, CBASE, T1, C1, T2, C2, T3, C3, T4, C4, T5, C5, T6, C6>(base: CBASE & Constructor<TBASE>, m1: C1 & Constructor<T1>, m2: C2 & Constructor<T2>, m3: C3 & Constructor<T3>, m4: C4 & Constructor<T4>, m5: C5 & Constructor<T5>, m6: C6 & Constructor<T6>): Constructor<TBASE & T1 & T2 & T3 & T4 & T5 & T6> & CBASE & C1 & C2 & C3 & C4 & C5 & C6;\nexport function Mixin<TBASE, CBASE, T1, C1, T2, C2, T3, C3, T4, C4, T5, C5, T6, C6, T7, C7>(base: CBASE & Constructor<TBASE>, m1: C1 & Constructor<T1>, m2: C2 & Constructor<T2>, m3: C3 & Constructor<T3>, m4: C4 & Constructor<T4>, m5: C5 & Constructor<T5>, m6: C6 & Constructor<T6>, m7: C7 & Constructor<T7>): Constructor<TBASE & T1 & T2 & T3 & T4 & T5 & T6 & T7> & CBASE & C1 & C2 & C3 & C4 & C5 & C6 & C7;\n/**\n * A type friendly, class based, mixin functions that mix in instance and static members.\n *\n * EXAMPLE:\n * ```ts\n * class User_ {\n *   id: number;\n *   firstName: string;\n *   lastName: string;\n * }\n *\n * class FullName {\n *   get fullName(): string {\n *     return `${this['firstName']} ${this['lastName']}`;\n *   }\n *\n *   static createId(): number {\n *     // a shady id generator.\n *     return Date.now();\n *   }\n * }\n *\n * export const User = Mixin(User_, FullName);\n * export type User = Mixin<User_, FullName>;\n *\n * // not using it:\n * const user = new User();\n * user.id = User.createId();\n * user.firstName = 'John';\n * user.lastName = 'Doe';\n * console.log(user.fullName); // John Doe\n * ```\n *\n * > To allow Generics in static members (e.g. static createUser(): T) see MixinExt\n *\n * ## Limitations:\n * From a type perspective this utility has limitations.\n *\n * #### You can't (currently) extend a mixed in type.\n *```ts\n *  export const User = Mixin(User_, FullName);\n *\n *  export class MyExtendedUser extends User { // <- Type Error\n *  }\n *```\n *\n * ```\n * Type 'Type<User_ & FullName> & typeof FullName & typeof User_' is not a constructor function type.\n * ```\n *\n * The error is misleading, this is a current known TS limitation (see [Github Issue](https://github.com/Microsoft/TypeScript/issues/4890))\n *\n * #### You can use generic inference once, from that point the generic param types for mixin have to be explicitly set:\n * ```ts\n *   export const User = Mixin(User_, FullName); // fine\n *\n *   export const UserNumber2 = Mixin(User, OtherMixin); // Error\n * ```\n *\n * ```\n * The type argument for type parameter 'TBASE' cannot be inferred from the usage.\n * Consider specifying the type arguments explicitly.\n * Type argument candidate 'FullName' is not a valid type argument because it is not a supertype of candidate 'User_'.\n * Property 'fullName' is missing in type 'User_'.\n * ```\n * This might be related to the previous limitation, or not...\n *\n *\n * There are 2 solution:\n *\n * 1) Using the built in interface that supports up to 6 mixins at once. (base + 6)\n * ```ts\n * export const User = Mixin(User_, FullName, OtherMixin); //  FullName, OtherMixin are 2, you can rest param your way for 5 more...\n * export type User = User_ & FullName & OtherMixin\n * ```\n * > This time we cant use `Mixin` to apply the User **type** so we just do it manually...\n *\n * 2) going the long way:\n * ```ts\n *   export const User = Mixin(User_, FullName); // fine\n *\n *   export const UserNumber2 = Mixin<User, typeof User, OtherMixin, typeof OtherMixin>(User, OtherMixin);\n * ```\n *\n *\n * @param base\n * @param mixin\n */\nexport function Mixin<TBASE, CBASE, TMIXIN, CMIXIN>(base: CBASE & Constructor<TBASE>, ...mixins: Array<CMIXIN & Constructor<TMIXIN>>): Constructor<TBASE & TMIXIN> & CMIXIN & CBASE {\n  mixObjects(base.prototype, mixins.map(m => m.prototype));\n  mixObjects(base, mixins);\n  return base as any;\n}\n\nexport function MixinExt<TBASE, CBASE, SMIXIN, T1, C1>(base: CBASE & Constructor<TBASE>, extraStatic: SMIXIN, m1: C1 & Constructor<T1>): Constructor<TBASE & T1> & SMIXIN & CBASE & C1;\nexport function MixinExt<TBASE, CBASE, SMIXIN, T1, C1, T2, C2>(base: CBASE & Constructor<TBASE>, extraStatic: SMIXIN, m1: C1 & Constructor<T1>, m2: C2 & Constructor<T2>): Constructor<TBASE & T1 & T2> & SMIXIN & CBASE & C1 & C2;\nexport function MixinExt<TBASE, CBASE, SMIXIN, T1, C1, T2, C2, T3, C3>(base: CBASE & Constructor<TBASE>, extraStatic: SMIXIN, m1: C1 & Constructor<T1>, m2: C2 & Constructor<T2>, m3: C3 & Constructor<T3>): Constructor<TBASE & T1 & T2 & T3> & SMIXIN & CBASE & C1 & C2 & C3;\nexport function MixinExt<TBASE, CBASE, SMIXIN, T1, C1, T2, C2, T3, C3, T4, C4>(base: CBASE & Constructor<TBASE>, extraStatic: SMIXIN, m1: C1 & Constructor<T1>, m2: C2 & Constructor<T2>, m3: C3 & Constructor<T3>, m4: C4 & Constructor<T4>): Constructor<TBASE & T1 & T2 & T3 & T4> & SMIXIN & CBASE & C1 & C2 & C3 & C4;\nexport function MixinExt<TBASE, CBASE, SMIXIN, T1, C1, T2, C2, T3, C3, T4, C4, T5, C5>(base: CBASE & Constructor<TBASE>, extraStatic: SMIXIN, m1: C1 & Constructor<T1>, m2: C2 & Constructor<T2>, m3: C3 & Constructor<T3>, m4: C4 & Constructor<T4>, m5: C5 & Constructor<T5>): Constructor<TBASE & T1 & T2 & T3 & T4 & T5> & SMIXIN & CBASE & C1 & C2 & C3 & C4 & C5;\nexport function MixinExt<TBASE, CBASE, SMIXIN, T1, C1, T2, C2, T3, C3, T4, C4, T5, C5, T6, C6>(base: CBASE & Constructor<TBASE>, extraStatic: SMIXIN, m1: C1 & Constructor<T1>, m2: C2 & Constructor<T2>, m3: C3 & Constructor<T3>, m4: C4 & Constructor<T4>, m5: C5 & Constructor<T5>, m6: C6 & Constructor<T6>): Constructor<TBASE & T1 & T2 & T3 & T4 & T5 & T6> & SMIXIN & CBASE & C1 & C2 & C3 & C4 & C5 & C6;\nexport function MixinExt<TBASE, CBASE, SMIXIN, T1, C1, T2, C2, T3, C3, T4, C4, T5, C5, T6, C6, T7, C7>(base: CBASE & Constructor<TBASE>, extraStatic: SMIXIN, m1: C1 & Constructor<T1>, m2: C2 & Constructor<T2>, m3: C3 & Constructor<T3>, m4: C4 & Constructor<T4>, m5: C5 & Constructor<T5>, m6: C6 & Constructor<T6>, m7: C7 & Constructor<T7>): Constructor<TBASE & T1 & T2 & T3 & T4 & T5 & T6 & T7> & SMIXIN & CBASE & C1 & C2 & C3 & C4 & C5 & C6 & C7;\n/**\n * For full description see Mixin function.\n *\n * The MixinExt utility does the same as Mixin but also allows adding an extra static type to the intersection.\n *\n * Although static members are mixed in there is a situation that requires an additional static mixin.\n * In a TypeScript class we can not apply generics on static members in the class level, only in a member based level.\n * If we want to return our final mixin type from a static member (e.g: factory) we need a different type.\n *\n * Example:\n * ```ts\n * class User_ {\n *   id: number;\n *   firstName: string;\n *   lastName: string;\n * }\n *\n * class FullName {\n *   get fullName(): string {\n *     return `${this['firstName']} ${this['lastName']}`;\n *   }\n * }\n *\n * const createNew = {\n *   create(): any {\n *     return new User_(); // at this point User_ is fully mixed in.\n *   }\n * }\n *\n * interface CreateStatic<T> {\n *   create(): Mixin<T, FullName>;\n * }\n *\n * export const User = MixinExt(User_, createNew as CreateStatic<User_>, FullName );\n * export type User = Mixin<User_, FullName>;\n * ```\n *\n * > Same as Mixin, MixinExt supports up to 6 mixins but only 1 extra static member.\n * If you need more then 1 just intersect all of your extera static interfaces to 1.\n * @param base\n * @param extraStatic Optional object for extra static member, use for static functions that require generics with Generics.\n * @param mixins\n */\nexport function MixinExt<TBASE, CBASE, SMIXIN, TMIXIN, CMIXIN>(base: CBASE & Constructor<TBASE>, extraStatic: SMIXIN, ...mixins: Array<CMIXIN & Constructor<TMIXIN>>): Constructor<TBASE & TMIXIN> & CBASE & SMIXIN & CMIXIN {\n  (Mixin as any)(base, ...mixins);\n  mixObjects(base, Array.of(extraStatic));\n  return base as any;\n}\n","import { ComponentHarness, ComponentHarnessConstructor, HarnessPredicate } from '@angular/cdk/testing';\nimport { ColumnCellHarnessFilters, ColumnHeaderCellHarnessFilters, DataCellHarnessFilters } from '../ngrid-harness-filters';\nimport { findHostClassMatch } from '../utils';\n\nconst CLASS_COLUMN_RE = /^cdk-column-(.+)$/;\n\n/**\n * Harness for interacting with cells that belong to a column.\n * This can be a column header cell, data cell or a column footer cell\n */\nexport class PblNgridColumnCellHarness extends ComponentHarness {\n  static hostSelector = `pbl-ngrid-header-cell, pbl-ngrid-cell`;\n\n  static with(options: ColumnCellHarnessFilters = {}): HarnessPredicate<PblNgridColumnCellHarness> {\n    return getColumnCellPredicate(PblNgridColumnCellHarness, options);\n  }\n\n  async getText(): Promise<string> {\n    return (await this.host()).text();\n  }\n\n  async getColumnId(): Promise<string> {\n    const match = await findHostClassMatch(await this.host(), CLASS_COLUMN_RE);\n    if (match) {\n      return match[1];\n    }\n\n    throw Error('Could not determine column name of cell.');\n  }\n}\n\n\nexport class PblNgridColumnHeaderCellHarness extends PblNgridColumnCellHarness {\n  // TODO: better detection here, not relay on class that might change.\n  static hostSelector = `pbl-ngrid-header-cell`;\n\n  static with(options: ColumnHeaderCellHarnessFilters = {}): HarnessPredicate<PblNgridColumnHeaderCellHarness> {\n    return getColumnCellPredicate(PblNgridColumnHeaderCellHarness, options);\n  }\n}\n\nexport class PblNgridDataCellHarness extends PblNgridColumnCellHarness {\n  // TODO: better detection here, not relay on class that might change.\n  static hostSelector = `pbl-ngrid-cell`;\n\n  static with(options: DataCellHarnessFilters = {}): HarnessPredicate<PblNgridDataCellHarness> {\n    return getColumnCellPredicate(PblNgridDataCellHarness, options);\n  }\n}\n\nexport function getColumnCellPredicate<T extends PblNgridColumnCellHarness>(type: ComponentHarnessConstructor<T>,\n                                                                            options: ColumnCellHarnessFilters): HarnessPredicate<T> {\n  // We can't use FluentApi here because ngc will cry\n  const predicate = new HarnessPredicate(type, options);\n  predicate.addOption('columnIds', options.columnIds, (harness, columnIds) => harness.getColumnId().then(columnId => columnIds.indexOf(columnId) !== -1));\n  return predicate;\n}\n","import { ComponentHarness, ComponentHarnessConstructor, HarnessPredicate } from '@angular/cdk/testing';\nimport { ColumnCellHarnessFilters, DataCellHarnessFilters, ColumnHeaderCellHarnessFilters, PblNgridDataRowHarnessFilters } from '../ngrid-harness-filters';\nimport { PblNgridColumnCellHarness, PblNgridDataCellHarness, PblNgridColumnHeaderCellHarness } from '../cell/ngrid-column-cell-harness';\n\n/**\n * Harness for interacting with rows that are structured based on a column\n */\nexport class PblNgridColumnRowHarness extends ComponentHarness {\n  async getCells(filter: ColumnHeaderCellHarnessFilters, type: typeof PblNgridColumnHeaderCellHarness): Promise<PblNgridColumnHeaderCellHarness[]>\n  async getCells(filter: DataCellHarnessFilters, type: typeof PblNgridDataCellHarness): Promise<PblNgridDataCellHarness[]>\n  async getCells(filter: ColumnCellHarnessFilters): Promise<PblNgridColumnCellHarness[]>;\n  async getCells(filter: ColumnCellHarnessFilters = {}, type?: typeof PblNgridColumnCellHarness): Promise<PblNgridColumnCellHarness[]> {\n    if (!type) {\n      type = PblNgridColumnCellHarness;\n    }\n    return this.locatorForAll( type.with(filter) )();\n  }\n}\n\nexport class PblNgridColumnHeaderRowHarness extends PblNgridColumnRowHarness {\n  // TODO: better detection here, not relay on class that might change.\n  static hostSelector = `div[pbl-ngrid-fixed-meta-row-container=\"header\"] pbl-ngrid-column-row.pbl-ngrid-header-row-main`;\n\n  async getCellByColumnId(columnId: string): Promise<PblNgridColumnCellHarness> {\n    const result = await this.getCells({ columnIds: [columnId] });\n    if (result) {\n      return result[0];\n    }\n  }\n\n  async getCells(filter: ColumnHeaderCellHarnessFilters = {}) {\n    return super.getCells(filter, PblNgridColumnCellHarness);\n  }\n}\n\nexport class PblNgridDataRowHarness extends PblNgridColumnRowHarness {\n  // TODO: better detection here, not relay on class that might change.\n  static hostSelector = `pbl-cdk-table pbl-ngrid-row`;\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a nGrid data row with specific attributes.\n   * @param options Options for narrowing the search\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(options: PblNgridDataRowHarnessFilters = {}): HarnessPredicate<PblNgridDataRowHarness> {\n    return getDataRowPredicate(PblNgridDataRowHarness, options);\n  }\n\n  async getRowIndex(): Promise<number | undefined> {\n    const attr = await this.host().then( host => host.getAttribute('row-id') );\n    return Number(attr);\n  }\n\n  async getRowIdentity(): Promise<string | undefined> {\n    return await this.host().then( host => host.getAttribute('row-key') );\n  }\n\n  async getCells(filter: DataCellHarnessFilters = {}) {\n    return super.getCells(filter, PblNgridDataCellHarness);\n  }\n}\n\nexport function getDataRowPredicate<T extends PblNgridDataRowHarness>(type: ComponentHarnessConstructor<T>,\n                                                               options: PblNgridDataRowHarnessFilters): HarnessPredicate<T> {\n  // We can't use FluentApi here because ngc will cry\n  const predicate = new HarnessPredicate(type, options);\n\n  predicate\n    .addOption('rowIndex', options.rowIndex,\n        (harness, rowIndex) => harness.getRowIndex().then( result => result === rowIndex))\n    .addOption('rowIdentity', options.rowIdentity,\n        (harness, rowIdentity) => HarnessPredicate.stringMatches(harness.getRowIdentity(), rowIdentity));\n\n  return predicate;\n}\n","import { ContentContainerComponentHarness, HarnessPredicate } from '@angular/cdk/testing';\nimport { PblNgridColumnHeaderRowHarness, PblNgridDataRowHarness } from '../row/ngrid-column-row-harness';\nimport { PblNgridHarnessFilters } from '../ngrid-harness-filters';\n\nexport class PblNgridHarness extends ContentContainerComponentHarness {\n  static hostSelector = 'pbl-ngrid';\n\n  static register<P extends keyof PblNgridHarness>(key: P, method: PblNgridHarness[P]) {\n    PblNgridHarness.prototype[key] = method;\n  }\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a nGrid with specific attributes.\n   * @param options Options for narrowing the search\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(options: PblNgridHarnessFilters = {}): HarnessPredicate<PblNgridHarness> {\n    return new HarnessPredicate(PblNgridHarness, options);\n  }\n\n  async getColumnHeaderRow(): Promise<PblNgridColumnHeaderRowHarness> {\n    return this.locatorFor(PblNgridColumnHeaderRowHarness)();\n  }\n\n  async getDataRow(rowIdentity: string): Promise<PblNgridDataRowHarness | undefined>\n  async getDataRow(rowIndex: number): Promise<PblNgridDataRowHarness | undefined>; // tslint:disable-line: unified-signatures\n  async getDataRow(rowIdentOrIndex: string | number): Promise<PblNgridDataRowHarness | undefined> {\n    if (typeof rowIdentOrIndex === 'number') {\n      return this.locatorFor(PblNgridDataRowHarness.with({ rowIndex: rowIdentOrIndex }))();\n    } else {\n      return this.locatorFor(PblNgridDataRowHarness.with({ rowIdentity: rowIdentOrIndex } ))();\n    }\n  }\n\n  async getDataRows(): Promise<PblNgridDataRowHarness[]> {\n    await this.forceStabilize();\n    return this.locatorForAll(PblNgridDataRowHarness)();\n  }\n}\n\n","import { TestElement } from '@angular/cdk/testing';\nimport { UnitTestElement } from '@angular/cdk/testing/testbed';\nimport { PblNgridHarness } from './ngrid-component-harness';\n\ndeclare module './ngrid-component-harness' {\n  interface PblNgridHarness {\n    /**\n     * Takes an immediate snapshot of the current rows rendered in the view and their order. (only stores the row identity, no cell data)\n     * and then poll the view to detect when the row have been re-rendered.\n     *\n     * You can provide a function that will run right after the snapshot, allowing changes to be executed right after the snapshot.\n     * The function must return a promise and the promise value will be returned by this method.\n     *\n     * Optimizing render change detection:\n     * Detecting a change in the row rendering state is simple, first a snapshot of current row identities is saves (A collection of strings)\n     * and then, for a predefined period of time (timeout) it is sampled against the view at predefined intervals (frequency)\n     * You can optimize the process by changing the frequency and/or timeout.\n     * A longer timeout means more time to test but allowing more time for render heavy operations\n     * A bigger frequency means sampling more often, allowing change to pop faster\n     *\n     * For example, a timeout of 500 (half second) and frequency of 10 means the view is samples every 50ms, 10 times.\n     *\n     * > This mimics the `onRenderChanged` event of the `DataSource`.\n     *\n     * @param fn A function that will return a promise for an operation that might cause a render change\n     * @param timeoutMs The total time (in ms) to wait before giving up (default: 500)\n     * @param frequency The total number of iterations to sample within the timeout (default: 10)\n     */\n    waitForRenderChanged<T = undefined>(fn?: () => Promise<T>, timeoutMs?: number, frequency?: number): Promise<T>;\n\n    scrollToLocation(location: ScrollToLocation): Promise<void>;\n    scrollTo(x: number, y: number): Promise<void>;\n\n    getColumnIds(): Promise<string[]>;\n    getViewPortData(): Promise<string[][]>;\n  }\n}\n\nexport enum ScrollToLocation {\n  VerticalStart,\n  VerticalEnd,\n  HorizontalStart,\n  HorizontalEnd,\n}\n\nclass PblNgridHarnessActions extends PblNgridHarness {\n\n  async waitForRenderChanged<T = undefined>(fn?: () => Promise<T>, timeoutMs = 500, frequency = 10): Promise<T> {\n    const rowIdentities = await this.getDataRows().then(rows => rows.map(r => r.getRowIdentity())).then( rows => Promise.all(rows) );\n\n    const result: T = typeof fn === 'function' ? await fn() : undefined;\n\n    frequency = Math.max(frequency, 1);\n    timeoutMs = Math.max(timeoutMs, 0);\n    const interval = Math.floor(timeoutMs / frequency);\n\n    const wait = () => new Promise( res => { setTimeout(res, interval)});\n\n    while (frequency > 0) {\n      await wait();\n\n      const newRows = await this.getDataRows();\n      if (rowIdentities.length !== newRows.length) {\n        return;\n      }\n\n      for (let i = 0; i < rowIdentities.length; i++) {\n        const newIdentity = newRows[i] ? (await newRows[i].getRowIdentity()) : null;\n        if (newIdentity !== rowIdentities[i]) {\n          return;\n        }\n      }\n\n      frequency -= 1;\n    }\n\n    return result;\n  }\n\n  async getColumnIds() {\n    return this.getColumnHeaderRow()\n      .then( header => header.getCells() )\n      .then( columns => Promise.all(columns.map( c => c.getColumnId() )) );\n  }\n\n  async getViewPortData() {\n    await this.forceStabilize();\n    return this.getDataRows()\n      .then( rows => rows.map( r => r.getCells().then( cells => cells.map(c => c.getText() )) ) )\n      .then( rows => Promise.all(rows.map( pRow => pRow.then( row => Promise.all(row) ))));\n  }\n\n  async scrollTo(x: number, y: number) {\n    // TODO: support protractor env\n    scrollDom(await this.locatorFor('pbl-cdk-virtual-scroll-viewport')(), x, y)\n  }\n\n  async scrollToLocation(location: ScrollToLocation) {\n    // TODO: support protractor env\n    const viewPort = await this.locatorFor('pbl-cdk-virtual-scroll-viewport')();\n    const element = (viewPort as UnitTestElement).element;\n    let x = element.scrollLeft;\n    let y = element.scrollTop;\n\n    switch (location) {\n      case ScrollToLocation.HorizontalStart:\n        x = 0;\n        break;\n      case ScrollToLocation.HorizontalEnd:\n        x = element.scrollWidth;\n        break;\n      case ScrollToLocation.VerticalStart:\n        y = 0;\n        break;\n      case ScrollToLocation.VerticalEnd:\n        y = element.scrollHeight;\n        break;\n    }\n    scrollDom(viewPort, x, y);\n  }\n}\n\nasync function scrollDom(viewPort: TestElement, x: number, y: number) {\n  const element = (viewPort as UnitTestElement).element;\n  element.scroll(x, y);\n}\n\nconst keys = Object.getOwnPropertyNames(PblNgridHarnessActions.prototype) as Array<keyof PblNgridHarnessActions>;\nfor (const key of keys) {\n  PblNgridHarness.register(key, PblNgridHarnessActions.prototype[key])\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}