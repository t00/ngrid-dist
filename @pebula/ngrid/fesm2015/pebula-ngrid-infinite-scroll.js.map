{"version":3,"file":"pebula-ngrid-infinite-scroll.js","sources":["../../../../libs/ngrid/infinite-scroll/src/lib/infinite-scroll-data-source/infinite-scroll-deffered-row.ts","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-scroll-data-source/caching/sequenced-block-cache.ts","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-scroll-data-source/caching/fragmented-block-cache/fragment.ts","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-scroll-data-source/caching/fragmented-block-cache/fragments.ts","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-scroll-data-source/caching/fragmented-block-cache/utils.ts","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-scroll-data-source/caching/fragmented-block-cache/fragmented-block-cache.ts","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-scroll-data-source/caching/noop-cache.ts","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-scroll-data-source/caching/create-cache-adapter.ts","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-scroll-data-source/infinite-scroll-datasource.cache.ts","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-scroll-data-source/utils.ts","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-scroll-data-source/infinite-scroll-datasource.ts","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-scroll-data-source/infinite-scroll-datasource-adapter.ts","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-scroll-data-source/trigger-execution-queue/execution-proxy-observer.ts","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-scroll-data-source/trigger-execution-queue/execution-queue.ts","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-scroll-data-source/event-state.ts","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-scroll-data-source/infinite-scroll-datasource.context.ts","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-scroll-data-source/infinite-scroll-datasource.factory.ts","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-virtual-row/directives.ts","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-virtual-row/row.ts","../../../../libs/ngrid/infinite-scroll/src/lib/default-infinite-virtual-row/default-infinite-virtual-row.component.ts","../../../../libs/ngrid/infinite-scroll/src/lib/default-infinite-virtual-row/default-infinite-virtual-row.component.html","../../../../libs/ngrid/infinite-scroll/src/lib/infinite-scroll-plugin.ts","../../../../libs/ngrid/infinite-scroll/src/lib/grid-infinite-scroll.module.ts","../../../../libs/ngrid/infinite-scroll/src/pebula-ngrid-infinite-scroll.ts"],"sourcesContent":["export const INFINITE_SCROLL_DEFFERED_ROW = {} as any;\n","import { PblInfiniteScrollDSContext } from '../infinite-scroll-datasource.context';\nimport { CacheAdapterOptions, CacheBlock, PblNgridCacheAdapter, RowSequence, StartOrEnd } from './cache-adapter';\n\n/*\nThis cache will force the blocks to align perfectly, where no event can be fired with rows\nthat overlap any other pervious or future event unless they overlap fully.\nFor example, if the block size is 50 and strictBlocks is true the events will include fromRow, toRows: [0, 49] [50, 99] .... [300, 349]\nIf strictBlocks is false you might get the above but might also get [73, 122] etc...\n\nWhile the user scrolls slowly the datasource will output strict blocks natively, the anomalies happen when\nthe user scrolls fast, into a scroll area with no rows.\n\nUsing strictBlocks fits to scenarios where the server returns page based pagination with no option to get items between pages. (i.e. fixed page size)\nIf your server returns pagination based on \"skip\" and \"limit\" then using strictBlocks does not add any value.\n\nWhen using strictBlocks cache performance might improve but the tradeoff is a little bit more API calls.\n*/\n\n/**\n * A Caching strategy that enforces storing cache rows in blocks where\n *\n *  - All blocks have the same predefined size (configurable)\n *  - A block contains items in a sequence (I.E A block is a page)\n *  - Each block must continue a sequence from the last block.\n *\n * In Addition, the cache is limited by size (configurable).\n * When items are added or when maximum size is updated the cache will auto-purge items\n * that cause overflow.\n *\n * If items are added which breaks the current sequence the entire cache is purged automatically.\n *\n * This is best for grid's that use a datasource with page based pagination.\n * While the user scrolls, each next item is most often the next block in sequence.\n *\n * Note that when pre-defining the virtual size to the total amount of rows will allow the user\n * to fast scroll which might break the sequence, skipping a block or more, thus purging the entire cache.\n */\nexport class SequencedBlockCache implements PblNgridCacheAdapter<CacheAdapterOptions> {\n\n  public end: number = -1;\n  public start: number = 0;\n\n  get maxSize(): number { return this._maxSize; }\n  get size(): number { return this.end - this.start + 1; }\n  get empty() { return this.size === 0; }\n\n  readonly options: CacheAdapterOptions;\n\n  private _maxSize = 0;\n  private lastAdd: StartOrEnd | undefined;\n\n  constructor(private readonly context: PblInfiniteScrollDSContext<any>, options?: CacheAdapterOptions) {\n    this.options = { ...(options || {}) };\n  }\n\n  remove(startRow: number, count: number): RowSequence[] {\n    const start = Math.max(startRow, this.start);\n    const end = Math.min(startRow + count - 1, this.end);\n    return [ [start, end] ];\n  }\n\n  /**\n   * Set the new max size for this cache.\n   * @returns When new max size is bigger the old & current size violates the new max size, return the number of items trimmed from the cache\n   * with positive value if trimmed from end, negative value if trimmed from start. Otherwise returns 0.\n   */\n  setCacheSize(maxSize: number): RowSequence[] {\n    this._maxSize = Math.max(0, maxSize);\n    const oversize = this.alignBoundary(this.lastAdd || 1);\n    if (oversize < 0) {\n      return [\n        [this.start + oversize, this.start - 1],\n      ];\n    } else if (oversize > 0) {\n      return [\n        [this.end + 1, this.end + oversize],\n      ];\n    } else {\n      return [];\n    }\n  }\n\n  update(startRow: number, endRow: number, direction: StartOrEnd): RowSequence[] {\n    if (this.empty) {\n      return this.add(startRow, endRow - startRow + 1);\n    } else if (this.isSibling(startRow, endRow, direction)) {\n      if (direction === -1) {\n        const offset = this.start - startRow;\n        return this.add(startRow, offset);\n      } else if (direction === 1) {\n        const offset = endRow - this.end;\n        return this.add(this.end + 1, offset);\n      } else {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          throw new Error('Infinite scroll - Sequenced block cache Error');\n        }\n        return;\n      }\n    } else {\n      const result = this.clear();\n      this.add(startRow, endRow - startRow + 1);\n      return result;\n    }\n  }\n\n  clear(): RowSequence[] {\n    this.lastAdd = undefined;\n    if (this.empty) {\n      return [ [0, 0] ];\n    }\n\n    const { start, end } = this;\n    this.start = 0;\n    this.end = -1;\n    return [ [start, end] ];\n  }\n\n  createBlock(startIndex: number, endIndex: number, totalLength = 0): CacheBlock | undefined {\n    const [ direction, start, end ] = this.matchBlock(startIndex, endIndex) || [];\n\n    if (!direction) {\n      return undefined;\n    }\n\n    const { blockSize } = this.context.options;\n\n    let fromRow: number;\n    let toRow: number;\n    switch (direction) {\n      case -1:\n        fromRow = Math.max(0, end - (blockSize - 1));\n        toRow = end;\n        break;\n      case 1:\n        fromRow = start;\n        toRow = start + blockSize - 1;\n        break;\n    }\n\n    if (totalLength && fromRow >= totalLength) {\n      return undefined;\n    }\n\n    // Strict Block logic:\n    // Now, we align the block to match a sequential world of blocks based on the block size.\n    // If we have a gap we want to divert to the nearest block start/end, based on the direction.\n    // If we go down (direction is 1) we want the nearest block start BELOW us, getting duplicates in the call but ensuring no gaps ahead\n    // If we go up (direction is -1) we want to nearest block start ABOVE us, getting duplicates in the call but ensuring no gaps ahead.\n    const main = direction === 1 ? fromRow : toRow;\n    let rem = main % blockSize;\n    if (rem !== 0) {\n      fromRow = main - rem;\n      toRow = fromRow + blockSize - 1;\n    }\n\n    if (totalLength) {\n      if (toRow >= totalLength) {\n        toRow = totalLength - 1;\n        fromRow = toRow - (toRow % blockSize)\n      }\n    }\n\n    return [direction, fromRow, toRow];\n  }\n\n  private matchBlock(start: number, end: number): [-1 | 1, number, number] | undefined {\n    if (this.empty) {\n      return [1, start, end];\n    }\n\n    if (start >= this.start && end <= this.end) {\n      return undefined;\n    }\n\n    if (start < this.start && end >= this.start - 1) {\n      return [-1, start, this.start -1];\n    }\n    if (end > this.end && start <= this.end + 1) {\n      return [1, this.end + 1, end];\n    }\n\n    return [end > this.end ? 1 : -1, start, end];\n  }\n\n  private oversize() {\n    return this._maxSize ? Math.max(this.size - this._maxSize, 0) : 0;\n  }\n\n  private isSibling(startRow: number, endRow: number, direction: StartOrEnd) {\n    if (direction === 1) {\n      return this.end + 1 === startRow;\n    }\n    if (direction === -1) {\n      return this.start - 1 === endRow;\n    }\n    return false;\n  }\n\n  private add(startRow: number, count: number): RowSequence[] {\n    if (startRow < 0 || count <= 0) {\n      return [];\n    }\n\n    let oversize: number;\n    let end = startRow + count - 1;\n    if (this.empty) {\n      this.start = startRow;\n      this.end = end;\n      oversize = this.alignBoundary(1);\n    } else if (startRow < this.start) {\n      this.start = startRow;\n      oversize = this.alignBoundary(-(this.lastAdd = -1) as any);\n    } else if (end > this.end) {\n      this.end = end;\n      oversize = this.alignBoundary(-(this.lastAdd = 1) as any);\n    }\n    if (oversize < 0) {\n      return [\n        [this.start + oversize, this.start - 1],\n      ];\n    } else if (oversize > 0) {\n      return [\n        [this.end + 1, this.end + oversize],\n      ];\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * Align the cache to fix max size.\n   * @returns the number of items trimmed from the cache with positive value if trimmed from end, negative value if trimmed from start.\n  */\n  private alignBoundary(trimFrom: StartOrEnd): number {\n    const oversize = this.oversize();\n    if (oversize) {\n      if (trimFrom === 1) {\n        this.end -= oversize;\n      } else {\n        this.start += oversize;\n        return -oversize;\n      }\n    }\n    return oversize;\n  }\n}\n","export class Fragment {\n\n  static calcEnd(startRow: number, count: number) {\n    return startRow + count - 1;\n  }\n\n  get size(): number { return this.end - this.start + 1; }\n  get empty() { return this.size === 0; }\n\n  constructor(public start: number, public end: number) { }\n\n  containsRow(rowIndex: number) {\n    return rowIndex >= this.start && rowIndex <= this.end;\n  }\n\n  equals(f: Fragment) {\n    return this.start === f.start && this.end === f.end;\n  }\n}\n","import { RowSequence, StartOrEnd } from '../cache-adapter';\nimport { Fragment } from './fragment';\n\nexport class Fragments extends Array<Fragment> {\n\n  private dirty = false;\n  private _size: number = 0;\n\n  get size(): number {\n    if (this.dirty) {\n      this.onDirty();\n    }\n    return this._size;\n  }\n\n  remove(startRow: number, count: number, startFrom = 0): RowSequence[] {\n    const result: RowSequence[] = [];\n    const endRow = Fragment.calcEnd(startRow, count);\n    const index = this.searchByRow(startRow, startFrom);\n\n    if (index !== -1) {\n      const item = this[index];\n      const originalEnd = item.end;\n\n      const gap = originalEnd - endRow;\n\n      item.end = startRow - 1;\n\n      if (gap === 0) {\n        result.push([startRow, endRow]);\n      } else if (gap < 0) {\n        result.push([startRow, originalEnd], ...this.remove(originalEnd + 1, gap, index + 1));\n      } else {\n        const f = new Fragment(endRow + 1, originalEnd);\n        this.splice(index, 0, f);\n        result.push([startRow, endRow]);\n      }\n\n      if (result.length > 0) {\n        this.markDirty();\n      }\n    }\n\n    return result;\n  }\n\n  removeItems(count: number, location: StartOrEnd): RowSequence[] {\n    const result: RowSequence[] = [];\n    let f: Fragment;\n    while (count > 0) {\n      f = location === -1 ? this.shift() : this.pop();\n      if (!f) {\n        break;\n      }\n\n      if (f.size > count) {\n        if (location === -1) {\n          f.start += count;\n          result.push([f.start - count, f.start - 1]);\n        } else {\n          f.end -= count;\n          result.push([f.end + 1, f.end + count]);\n        }\n        count = 0;\n      } else {\n        count = count - f.size;\n        result.push([f.start, f.end]);\n        f = undefined;\n      }\n    }\n    if (f) {\n      if (location === -1) {\n        this.unshift(f);\n      } else {\n        this.push(f);\n      }\n    }\n    if (result.length > 0) {\n      this.markDirty();\n    }\n    return result;\n  }\n\n  clear(): RowSequence[] {\n    const result: RowSequence[] = [];\n    while (this.length > 0) {\n      const f = this.shift();\n      result.push([f.start, f.end]);\n    }\n    if (result.length > 0) {\n      this.markDirty();\n    }\n    return result;\n  }\n\n  /**\n   * Returns the first row index of a missing row that is the most close (based on the direction) to the provided rowIndex.\n   * If the provided rowIndex is missing, returns the provided rowIndex.\n   * Note that when the direction is -1 the closest missing row might be -1, i.e. all rows are in-place and nothing is missing\n   */\n  findClosestMissing(rowIndex: number, direction: StartOrEnd) {\n    const fragment = this[this.searchByRow(rowIndex)];\n    if (fragment) { // we assume fragments must have gaps or else they are merged\n      return direction === 1 ? fragment.end + 1 : fragment.start - 1;\n    }\n    return rowIndex;\n  }\n\n  containsRange(startRow: number, endRow: number) {\n    const first = this[this.searchByRow(startRow)];\n    return first && endRow <= first.end; // we assume fragments must have gaps or else they are merged\n  }\n\n  /**\n   * Search all fragments and find the index of the fragments that contains a specific row index\n   */\n  searchByRow(rowIndex: number, startFrom = 0) {\n    let end = this.length - 1;\n\n    while (startFrom <= end){\n      let mid = Math.floor((startFrom + end) / 2);\n      const item = this[mid];\n      if (item.containsRow(rowIndex)) {\n        return mid;\n      }\n      else if (item.end < rowIndex) {\n        startFrom = mid + 1;\n      } else {\n        end = mid - 1;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Search for the row that either contain the rowIndex or is the closest to it (from the start)\n   * I.e, if no fragment contains the rowIndex, the closest fragment to it will return it's index\n   * If The row index is greater then the end of the hightest fragment -1 is returned\n   * */\n  searchRowProximity(rowIndex: number, startFrom = 0) {\n    let end = this.length - 1;\n\n    let mostProximate = -1;\n    while (startFrom <= end){\n      let mid = Math.floor((startFrom + end) / 2);\n      const item = this[mid];\n      if (item.containsRow(rowIndex)) {\n        return mid;\n      } else if (item.end < rowIndex) {\n        startFrom = mid + 1;\n      } else {\n        mostProximate = mid;\n        end = mid - 1;\n      }\n    }\n    return mostProximate;\n  }\n\n  markDirty() {\n    this.dirty = true;\n  }\n\n  /**\n   * Check and verify that there are no sequential blocks (e.g. block 1 [0, 99], block 2 [100, 199])\n   * If there are, merge them into a single block\n   */\n  checkAndMerge() {\n    for (let i = 1; i < this.length; i++) {\n      if (this[i - 1].end + 1 === this[i].start) {\n        this[i - 1].end = this[i].end;\n        this.splice(i, 1);\n        i -= 1;\n      }\n    }\n  }\n\n  private onDirty() {\n    this.dirty = false;\n    this._size = this.reduce( (s, f) => s + f.size, 0);\n  }\n}\n","import { Fragment } from './fragment';\n\nexport enum IntersectionType {\n  /** No intersection between \"source\" and \"target\" */\n  none,\n  /** \"source\" and \"target\" are equal */\n  full,\n  /** \"target\" contains the entire \"source\" */\n  contained,\n  /** \"source\" contains the entire \"target\" */\n  contains,\n  /** A portion from the \"source\" is not intersected with the \"target\" */\n  partial,\n}\n\nexport function intersect(f1: Fragment, f2: Fragment): Fragment | null {\n  const min = f1.start < f2.start ? f1 : f2;\n  const max = min === f1 ? f2 : f1;\n  return min.end < max.start\n    ? null\n    : new Fragment(max.start, min.end < max.end ? min.end : max.end);\n}\n\nexport function findIntersectionType(source: Fragment, target: Fragment, intersection?: ReturnType<typeof intersect>): IntersectionType {\n  if (source.equals(target)) {\n    return IntersectionType.full;\n  }\n\n  if (intersection === undefined) {\n    intersection = intersect(source, target);\n  }\n\n  if (!intersection) {\n    return IntersectionType.none;\n  }\n\n  if (source.equals(intersection)) {\n    return IntersectionType.contained;\n  }\n\n  if (target.equals(intersection)) {\n    return IntersectionType.contains;\n  }\n\n  return IntersectionType.partial;\n}\n","import { PblInfiniteScrollDSContext } from '../../infinite-scroll-datasource.context';\nimport { CacheAdapterOptions, CacheBlock, PblNgridCacheAdapter, RowSequence, StartOrEnd } from '../cache-adapter';\nimport { Fragment } from './fragment';\nimport { Fragments } from './fragments';\nimport { findIntersectionType, IntersectionType } from './utils';\n\n// const LOG = msg => { console.log(msg); }\n\nexport interface FragmentedBlockCacheOptions extends CacheAdapterOptions {\n  /**\n   * When set to true the cache will force the blocks to align perfectly, where no event can be fired with rows\n   * that overlap any other pervious or future event unless they overlap fully.\n   * For example, if the block size is 50 and \"strictPaging\" is true the events will include fromRow, toRows: [0, 49] [50, 99] .... [300, 349]\n   * If 'strictPaging is false you might get the above but might also get [73, 122] etc...\n   * @default false\n   */\n  strictPaging?: boolean\n}\n\n/**\n * A Caching strategy that enforces storing cache rows in blocks where\n *\n *  - All blocks have the same predefined size (configurable)\n *  - A block contains items in a sequence (I.E A block is a page)\n *\n * In Addition, the cache is limited by size (configurable).\n * When items are added or when maximum size is updated the cache will auto-purge items\n * that cause overflow.\n *\n * Beside overflow, not other logic can perform automatic purging.\n *\n * This is best for grid's that use a datasource with an index based pagination (skip/limit) and\n */\nexport class FragmentedBlockCache implements PblNgridCacheAdapter<FragmentedBlockCacheOptions> {\n\n  get maxSize(): number { return this._maxSize; }\n  get size(): number { return this.fragments.size; }\n  get empty() { return this.size === 0; }\n\n  readonly options: FragmentedBlockCacheOptions;\n\n  private _maxSize = 0;\n  private coldLocation: StartOrEnd | undefined;\n  // DO NOT MODIFY FRAGMENT ITEMS IN THE COLLECTION WITHOUT CALLING \"markDirty()\" afterwards\n  private fragments = new Fragments();\n  private lastStartRow = 0;\n  private lastDir: StartOrEnd = 1;\n\n  constructor(private readonly context: PblInfiniteScrollDSContext<any>, options?: FragmentedBlockCacheOptions) {\n    this.options = { ...(options || {}) };\n  }\n\n  remove(startRow: number, count: number): RowSequence[] {\n    return this.fragments.remove(startRow, count);\n  }\n\n  /**\n   * Set the new max size for this cache.\n   * @returns When new max size is bigger the old & current size violates the new max size, return the number of items trimmed from the cache\n   * with positive value if trimmed from end, negative value if trimmed from start. Otherwise returns 0.\n   */\n  setCacheSize(maxSize: number): RowSequence[] {\n    this._maxSize = Math.max(0, maxSize);\n    return this.alignBoundary();\n  }\n\n  update(startRow: number, endRow: number, direction: StartOrEnd): RowSequence[] {\n    this.coldLocation = direction === 1 ? -1 : 1;\n    return this.add(startRow, endRow);\n  }\n\n  clear(): RowSequence[] {\n    this.coldLocation = undefined;\n    if (this.empty) {\n      return [ [0, 0] ];\n    }\n    return this.fragments.clear();\n  }\n\n  createBlock(startIndex: number, endIndex: number, totalLength = 0): CacheBlock | undefined {\n    const [ direction, start, end ] = this.matchBlock(startIndex, endIndex) || [];\n\n    // LOG(`CREATE BLOCK: [${startIndex}, ${endIndex}] => [${direction}, ${start}, ${end}]`)\n    if (!direction) {\n      return undefined;\n    }\n\n    const { blockSize } = this.context.options;\n    const { strictPaging } = this.options;\n\n    let fromRow: number;\n    let toRow: number;\n    switch (direction) {\n      case -1:\n        fromRow = Math.max(0, end - (blockSize - 1));\n        toRow = end;\n        if (!strictPaging && fromRow < start) {\n          fromRow = Math.min(this.fragments.findClosestMissing(fromRow, 1), start);\n        }\n        break;\n      case 1:\n        fromRow = start;\n        toRow = start + blockSize - 1;\n        if (!strictPaging && toRow > end) {\n          toRow = Math.max(this.fragments.findClosestMissing(toRow, -1), end);\n        }\n        break;\n    }\n\n    if (totalLength && fromRow >= totalLength) {\n      return undefined;\n    }\n\n    // Strict Block logic:\n    // Now, we align the block to match a sequential world of blocks based on the block size.\n    // If we have a gap we want to divert to the nearest block start/end, based on the direction.\n    // If we go down (direction is 1) we want the nearest block start BELOW us, getting duplicates in the call but ensuring no gaps ahead\n    // If we go up (direction is -1) we want to nearest block start ABOVE us, getting duplicates in the call but ensuring no gaps ahead.\n    if (strictPaging) {\n      const main = direction === 1 ? fromRow : toRow;\n      let rem = main % blockSize;\n      if (rem !== 0) {\n        fromRow = main - rem;\n        toRow = fromRow + blockSize - 1;\n      }\n    }\n\n    if (totalLength && toRow >= totalLength) {\n      toRow = totalLength - 1;\n      if (strictPaging) {\n        fromRow = toRow - (toRow % blockSize)\n      }\n    }\n\n    return [direction, fromRow, toRow];\n  }\n\n  private matchBlock(start: number, end: number): CacheBlock | undefined {\n    if (this.empty) {\n      return [1, start, end];\n    }\n\n    const iFirst = this.fragments.searchRowProximity(start);\n    const iLast = this.fragments.searchRowProximity(end);\n    if (iFirst === -1) {\n      return [1, start, end];\n    }\n\n    const first = this.fragments[iFirst];\n    if (iLast === -1) {\n      return [1, first.containsRow(start) ? first.end + 1 : start, end];\n    }\n\n    const intersectionType = findIntersectionType(first, new Fragment(start,end));\n    const dir = this.lastStartRow > start ? -1 : this.lastStartRow === start ? this.lastDir : 1;\n    this.lastStartRow = start;\n    this.lastDir = dir;\n\n    // The logic here assumes that there are not sequential blocks, (e.g. block 1 [0, 99], block 2 [100, 199])\n    // All sequential blocks are to be merged via checkAndMerge on the fragments collection\n    switch (intersectionType) {\n      case IntersectionType.none:\n        return [dir, start, end];\n      case IntersectionType.partial:\n        if (iFirst === iLast) {\n          if (start < first.start) {\n            return [dir, start, first.start - 1];\n          } else {\n            return [dir, first.end + 1, end];\n          }\n        } else {\n          const last = this.fragments[iLast];\n          return [dir, start < first.start ? start : first.end + 1, end >= last.start ? last.start - 1 : end];\n        }\n      case IntersectionType.contained:\n        const last = this.fragments[iLast];\n        return [dir, start, end >= last.start ? last.start - 1 : end];\n      case IntersectionType.contains:\n      case IntersectionType.full:\n        return undefined;\n    }\n  }\n\n  private add(startRow: number, endRow: number): RowSequence[] {\n    if (startRow < 0 || endRow <= 0) {\n      return [];\n    }\n\n    const newFragment = new Fragment(startRow, endRow);\n    const iFirst = this.fragments.searchRowProximity(startRow);\n    const first = this.fragments[iFirst];\n    const intersectionType = !first ? null : findIntersectionType(first, newFragment);\n\n    switch (intersectionType) {\n      case null:\n        // EDGE CASE: when  \"first\" is undefined, i.e. \"iFirst\" is -1\n        // This edge case means no proximity, i,e. the new fragment is AFTER the last fragment we currently have (or we have no fragments)\n        this.fragments.push(newFragment);\n        break;\n      case IntersectionType.none: // it means first === last\n        this.fragments.splice(iFirst, 0, newFragment);\n        break;\n      case IntersectionType.partial:\n      case IntersectionType.contained:\n        let iLast = this.fragments.searchRowProximity(endRow);\n        if (iLast === -1) {\n          iLast = this.fragments.length - 1;\n        }\n        const last = this.fragments[iLast];\n        first.start = Math.min(newFragment.start, first.start);\n        if (newFragment.end >= last.start) {\n          first.end = newFragment.end;\n          this.fragments.splice(iFirst + 1, iLast - iFirst);\n        } else {\n          first.end = Math.max(newFragment.end, first.end);\n          this.fragments.splice(iFirst + 1, (iLast - 1) - iFirst);\n        }\n        break;\n      case IntersectionType.contains:\n      case IntersectionType.full:\n        return [];\n    }\n\n    this.fragments.markDirty();\n    this.fragments.checkAndMerge();\n    return this.alignBoundary();\n  }\n\n  private oversize() {\n    return this._maxSize ? Math.max(this.size - this._maxSize, 0) : 0;\n  }\n\n  private alignBoundary(): RowSequence[] {\n    const oversize = this.oversize();\n    return oversize > 0 ? this.fragments.removeItems(oversize, this.coldLocation || 1) : [];\n  }\n}\n","import { PblInfiniteScrollDataSource } from '../infinite-scroll-datasource';\nimport { PblInfiniteScrollDSContext } from '../infinite-scroll-datasource.context';\nimport { CacheAdapterOptions, CacheBlock, PblNgridCacheAdapter, RowSequence, StartOrEnd } from './cache-adapter';\n\n/**\n * A Caching strategy that enforces storing cache rows in blocks where\n *\n *  - All blocks have the same predefined size (configurable)\n *  - A block contains items in a sequence (I.E A block is a page)\n *  - Each block must continue a sequence from the last block.\n *\n * In Addition, the cache is limited by size (configurable).\n * When items are added or when maximum size is updated the cache will auto-purge items\n * that cause overflow.\n *\n * If items are added which breaks the current sequence the entire cache is purged automatically.\n *\n * This is best for grid's that use a datasource with page based pagination.\n * While the user scrolls, each next item is most often the next block in sequence.\n *\n * Note that when pre-defining the virtual size to the total amount of rows will allow the user\n * to fast scroll which might break the sequence, skipping a block or more, thus purging the entire cache.\n */\nexport class NoOpBlockCache implements PblNgridCacheAdapter<CacheAdapterOptions> {\n  get maxSize(): number { return this.ds.length; }\n  get size(): number { return this.ds.length; }\n  get empty() { return this.size === 0; }\n\n  readonly options: CacheAdapterOptions;\n\n  private readonly ds: PblInfiniteScrollDataSource<any>;\n\n  constructor(private readonly context: PblInfiniteScrollDSContext<any>, private readonly virtualRow: any) {\n    this.ds = context.getDataSource();\n  }\n\n  remove(startRow: number, count: number): RowSequence[] {\n    const start = 0;\n    const end = Math.min(startRow + count - 1, this.ds.length);\n    return [ [start, end ] ];\n  }\n\n  /**\n   * Set the new max size for this cache.\n   * @returns When new max size is bigger the old & current size violates the new max size, return the number of items trimmed from the cache\n   * with positive value if trimmed from end, negative value if trimmed from start. Otherwise returns 0.\n   */\n  setCacheSize(maxSize: number): RowSequence[] {\n    return [];\n  }\n\n  update(startRow: number, endRow: number, direction: StartOrEnd): RowSequence[] {\n    return [];\n  }\n\n  clear(): RowSequence[] {\n    return [ [0, this.ds.length - 1] ];\n  }\n\n  createBlock(startIndex: number, endIndex: number, totalLength = 0): CacheBlock | undefined {\n    const [ direction, start, end ] = this.matchBlock(startIndex, endIndex) || [];\n\n    if (!direction) {\n      return undefined;\n    }\n\n    const { blockSize } = this.context.options;\n\n    let fromRow: number;\n    let toRow: number;\n    switch (direction) {\n      case -1:\n        fromRow = Math.max(0, end - (blockSize - 1));\n        toRow = end;\n        break;\n      case 1:\n        fromRow = start;\n        toRow = start + blockSize - 1;\n        break;\n    }\n\n    if (totalLength && fromRow >= totalLength) {\n      return undefined;\n    }\n\n    if (totalLength) {\n      if (toRow >= totalLength) {\n        toRow = totalLength - 1;\n      }\n    }\n\n    return [direction, fromRow, toRow];\n  }\n\n  private matchBlock(start: number, end: number): CacheBlock | undefined { // TODO: refactor to labeled tuple types in TS 4.0\n    if (start === end) {\n      return [1, start, end];\n    }\n\n    const source = this.ds.source;\n\n    for (let i = start; i <= end; i++) {\n      if (source[i] !== this.virtualRow) {\n        start = i;\n      } else {\n        break;\n      }\n    }\n\n    if (start === end) {\n      return undefined;\n    } else {\n      return [1, start, end];\n    }\n  }\n}\n","import { PblInfiniteScrollDSContext } from '../infinite-scroll-datasource.context';\nimport { INFINITE_SCROLL_DEFFERED_ROW } from '../infinite-scroll-deffered-row';\nimport { SequencedBlockCache } from './sequenced-block-cache';\nimport { FragmentedBlockCache } from './fragmented-block-cache';\nimport { PblInfiniteScrollCacheOptions } from '../infinite-scroll-datasource.types';\nimport { NoOpBlockCache } from './noop-cache';\n\nexport interface PblNgridCacheAdaptersMap {\n  noOpCache: NoOpBlockCache ;\n  sequenceBlocks: SequencedBlockCache ;\n  fragmentedBlocks: FragmentedBlockCache;\n}\n\nexport function createCacheAdapter(context: PblInfiniteScrollDSContext<any>, options: PblInfiniteScrollCacheOptions) {\n  switch (options.type) {\n    case 'noOpCache':\n      return new NoOpBlockCache(context, INFINITE_SCROLL_DEFFERED_ROW);\n    case 'sequenceBlocks':\n      return new SequencedBlockCache(context, options.options);\n    case 'fragmentedBlocks':\n      return new FragmentedBlockCache(context, options.options);\n  }\n}\n","import { PblInfiniteScrollCacheOptions } from './infinite-scroll-datasource.types';\nimport { createCacheAdapter, PblNgridCacheAdapter, StartOrEnd } from './caching';\nimport { PblInfiniteScrollDSContext } from './infinite-scroll-datasource.context';\n\nfunction normalizeCacheOptions(options?: PblInfiniteScrollCacheOptions): PblInfiniteScrollCacheOptions {\n  if (!options) {\n    options = { type: 'noOpCache' };\n  }\n  return options;\n}\n\nexport class PblInfiniteScrollDataSourceCache<T, TData = any> {\n  get maxSize(): number { return this.cacheAdapter.maxSize; }\n  get size(): number { return this.cacheAdapter.size; }\n  get empty() { return this.cacheAdapter.empty; }\n\n  private cacheAdapter: PblNgridCacheAdapter<any>;\n\n  constructor(private readonly context: PblInfiniteScrollDSContext<T, TData>, options?: PblInfiniteScrollCacheOptions) {\n    this.cacheAdapter = createCacheAdapter(context, normalizeCacheOptions(options));\n    this.setCacheSize(300);\n  }\n\n  setCacheSize(maxSize: number) {\n    this.cacheAdapter.setCacheSize(maxSize);\n  }\n\n  matchNewBlock() {\n    const ds = this.context.getDataSource();\n    const totalLength = this.context.totalLength;\n\n    const renderEnd = ds.renderStart + ds.renderLength;\n    const start = ds.renderStart;\n    const end = totalLength ? Math.min(renderEnd, totalLength) : renderEnd;\n    return this.cacheAdapter.createBlock(start, end, totalLength);\n  }\n\n  createInitialBlock() {\n    const ds = this.context.getDataSource();\n    const totalLength = this.context.totalLength;\n    const renderEnd = ds.renderLength;\n    const start =0;\n    const end = totalLength ? Math.min(renderEnd, totalLength) : renderEnd;\n    return this.cacheAdapter.createBlock(start, end, totalLength);\n  }\n\n  update(startRow: number, endRow: number, direction: StartOrEnd) {\n    return this.cacheAdapter.update(startRow, endRow, direction);\n  }\n\n  clear() {\n    return this.cacheAdapter.clear();\n  }\n}\n","import { PblDataSourceTriggerChangedEvent } from '@pebula/ngrid';\nimport { CacheBlock } from './caching';\nimport { PblInfiniteScrollDSContext } from './infinite-scroll-datasource.context';\nimport { PblInfiniteScrollDsOptions, PblInfiniteScrollTriggerChangedEvent } from './infinite-scroll-datasource.types';\nimport { INFINITE_SCROLL_DEFFERED_ROW } from './infinite-scroll-deffered-row';\n\nexport function normalizeOptions(rawOptions: PblInfiniteScrollDsOptions) {\n  const options: PblInfiniteScrollDsOptions = rawOptions || {};\n\n  options.blockSize = Number(options.blockSize);\n  if (Number.isNaN(options.blockSize)) {\n    options.blockSize = 50;\n  } else if (options.blockSize <= 0) {\n    options.blockSize = 50;\n  }\n\n  options.initialVirtualSize = Number(options.initialVirtualSize);\n  if (Number.isNaN(options.initialVirtualSize)) {\n    options.initialVirtualSize = 0;\n  }\n\n  return options;\n}\n\nexport function shouldTriggerInvisibleScroll<T, TData = any>(context: PblInfiniteScrollDSContext<T, TData>) {\n  const ds = context.getDataSource();\n  if (context.totalLength && ds.renderStart > context.totalLength) {\n    return false;\n  }\n\n  return !!(context.cache.matchNewBlock());\n}\n\nexport function tryAddVirtualRowsBlock<T>(source: T[], event: PblInfiniteScrollTriggerChangedEvent<any>, blockSize: number) {\n  const currLen = source.length;\n  if (currLen < event.totalLength && event.totalLength > event.toRow && source[currLen - 1] !== INFINITE_SCROLL_DEFFERED_ROW) {\n    const len = Math.min(currLen + blockSize - 1, event.totalLength);\n    for (let i = currLen; i < len; i++) {\n      source[i] = INFINITE_SCROLL_DEFFERED_ROW;\n    }\n    return true;\n  }\n  return false;\n}\n\nexport function upgradeChangeEventToInfinite<T, TData = any>(totalLength: number, event: PblDataSourceTriggerChangedEvent<TData>, blockMatch: CacheBlock) {\n  const [ direction, start, end ] = blockMatch;\n\n  if (!event.isInitial) {\n    if (direction === 1 && end === totalLength - 1) {\n      (event as PblInfiniteScrollTriggerChangedEvent).isLastBlock = true;\n    }\n  }\n\n  (event as PblInfiniteScrollTriggerChangedEvent).direction = direction;\n  (event as PblInfiniteScrollTriggerChangedEvent).fromRow = start;\n  (event as PblInfiniteScrollTriggerChangedEvent).offset = (end - start) + 1;\n  (event as PblInfiniteScrollTriggerChangedEvent).toRow = end;\n\n  return event as PblInfiniteScrollTriggerChangedEvent<TData> | undefined;\n}\n\n/**\n * Update the cache with new block information to reflect the last triggered event and\n * also update the datasource with the new values, removing values that are purged due to cache logic.\n * Returns the new datasource, or the original datasource editing in-place.\n *\n * For example, if the cache was empty the values provided are returned\n * Otherwise, the original datasource is edited and returned.\n */\nexport function updateCacheAndDataSource<T, TData = any>(context: PblInfiniteScrollDSContext<T, TData>,\n                                                         event: PblInfiniteScrollTriggerChangedEvent<TData>,\n                                                         values: T[]) {\n\n  if (context.cache.empty) {\n    return values;\n  }\n\n  const source = context.getDataSource().source;\n  const toRemove = context.cache.update(event.fromRow, event.toRow, event.direction);\n  for(const [start, end] of toRemove) {\n    for (let i = start; i <= end; i++) {\n      source[i] = INFINITE_SCROLL_DEFFERED_ROW;\n    }\n  }\n\n  const { fromRow } = event;\n  for (let i = 0, len = values.length; i < len; i++) {\n    source[i + fromRow] = values[i];\n  }\n\n  return source;\n}\n","import { take } from 'rxjs/operators';\nimport { PblDataSource, PblDataSourceOptions, PblNgridRowContext } from '@pebula/ngrid';\nimport { PblInfiniteScrollDSContext } from './infinite-scroll-datasource.context';\nimport { INFINITE_SCROLL_DEFFERED_ROW } from './infinite-scroll-deffered-row';\nimport { PblInfiniteScrollDataSourceAdapter } from './infinite-scroll-datasource-adapter';\nimport { PblInfiniteScrollTriggerChangedEvent } from './infinite-scroll-datasource.types';\n\nexport class PblInfiniteScrollDataSource<T = any, TData = any> extends PblDataSource<T,\n                                                                                     TData,\n                                                                                     PblInfiniteScrollTriggerChangedEvent<TData>,\n                                                                                     PblInfiniteScrollDataSourceAdapter<T, TData>> {\n\n  get maxCacheSize() { return this.context.cache.maxSize; }\n  get cacheSize() { return this.context.cache.size; }\n\n  constructor(private readonly context: PblInfiniteScrollDSContext<T, TData>, options?: PblDataSourceOptions) {\n    super(context.getAdapter(), options);\n  }\n\n  setCacheSize(maxSize: number) {\n    this.context.cache.setCacheSize(maxSize);\n  }\n\n  purgeCache() {\n    const source = this.source;\n    for (const [start, end] of this.context.cache.clear()) {\n      for (let i = start; i <= end; i++) {\n        source[i] = INFINITE_SCROLL_DEFFERED_ROW;\n      }\n    }\n    this.refresh();\n  }\n\n  isVirtualRow(row: any) {\n    return row === INFINITE_SCROLL_DEFFERED_ROW;\n  }\n\n  isVirtualContext(context: PblNgridRowContext<any>) {\n    return context.$implicit === INFINITE_SCROLL_DEFFERED_ROW;\n  }\n\n  /**\n   * Update the size of the datasource to reflect a virtual size.\n   * This will extend the scrollable size of the grid.\n   *\n   * > Note that you can only add to the size, if the current size is larger than the new size nothing will happen.\n   */\n  updateVirtualSize(newSize: number) {\n    if (this.adapter.inFlight) {\n      this.onRenderDataChanging\n        .pipe(take(1))\n        .subscribe(r => {\n          PblInfiniteScrollDataSource.updateVirtualSize(newSize, r.data);\n          // we must refire so virtual scroll viewport can catch it\n          // because it also listen's to this stream but it is registered before us.\n          // See virtual-scroll/virtual-scroll-for-of.ts where \"dataStream\" is assigned\n          this._onRenderDataChanging.next(r);\n        });\n    } else {\n      PblInfiniteScrollDataSource.updateVirtualSize(newSize, this.source);\n    }\n  }\n\n  static updateVirtualSize(newSize: number, values: any[]) {\n    if (values && values.length < newSize) {\n      for (let i = values.length; i < newSize; i++) {\n        values[i] = INFINITE_SCROLL_DEFFERED_ROW;\n      }\n    }\n  }\n}\n","import { Observable } from 'rxjs';\nimport { PblDataSourceAdapter, PblDataSourceConfigurableTriggers } from '@pebula/ngrid';\nimport { PblInfiniteScrollTriggerChangedEvent } from './infinite-scroll-datasource.types';\nimport { PblInfiniteScrollDSContext } from './infinite-scroll-datasource.context';\nimport { debounceTime } from 'rxjs/operators';\n\nexport class PblInfiniteScrollDataSourceAdapter<T = any, TData = any> extends PblDataSourceAdapter<T, TData, PblInfiniteScrollTriggerChangedEvent<TData>> {\n\n  readonly virtualRowsLoading: Observable<boolean>;\n\n  constructor(private context: PblInfiniteScrollDSContext<T, TData>,\n              config: false | Partial<Record<keyof PblDataSourceConfigurableTriggers, boolean>>,\n              onVirtualLoading: Observable<boolean>) {\n    super(e => context.onTrigger(e), config);\n    this.virtualRowsLoading = onVirtualLoading.pipe(debounceTime(24));\n  }\n\n  dispose() {\n    this.context.dispose();\n    super.dispose();\n  }\n\n  protected emitOnSourceChanging(event: PblInfiniteScrollTriggerChangedEvent<TData>) {\n    if (event.isInitial) {\n      super.emitOnSourceChanging(event);\n    }\n  }\n}\n","import { Observable, Subscriber, Subscription, Subject } from 'rxjs';\nimport { PblInfiniteScrollTriggerChangedEvent } from '../infinite-scroll-datasource.types';\n\n// const LOG = msg => console.log(msg);\n\n/**\n * A wrapper around an on trigger observable call that will prevent it from\n * closing if marked to do so (calling `keepAlive()`).\n * If `keepAlive()` was called and the observable has been unsubscribed the teardown logic\n * will not unsubscribe from the underlying on-trigger observable, it will let it roll until\n * finished or being killed again.\n * Keep alive is a toggle, if \"used\" it can not be used again unless `keepAlive()` is called again.\n *\n * This observable is used internally by the execution queue to prevent on-trigger calls from being invoked and\n * cancelled multiple times.\n * This usually happen when scrolling, since the scroll might not break the current page block fetched, until fetched\n * it will keep asking for it, hence the need to keep it alive.\n * Each execution must return an observable or it will get canceled, so we return the currently executed trigger\n * instead of running it again...\n * @internal\n */\nexport class TriggerExecutionProxyObservable<T> extends Observable<T> {\n  readonly onKilled = new Subject<void>();\n\n  private canLive: boolean = false;\n  private baseSubscription: Subscription;\n  private subscriber: Subscriber<T>;\n  private error?: any;\n  private completed?: boolean;\n\n  constructor(private readonly event: PblInfiniteScrollTriggerChangedEvent,\n              private readonly target: Observable<T>) {\n    super(subscriber => this.onSubscribe(subscriber));\n    // LOG(`NEW[${event.id}]: ${event.fromRow} - ${event.toRow}`);\n  }\n\n  keepAlive() {\n    this.canLive = true;\n  }\n\n  private onSubscribe(subscriber: Subscriber<T>) {\n    this.subscriber = subscriber;\n\n    if (!this.baseSubscription) {\n      this.baseSubscription = this.target.subscribe({\n        next: v => this.subscriber.next(v),\n        error: e => {\n          this.error = e;\n          this.subscriber.error(e);\n        },\n        complete: () => {\n          this.completed = true;\n          this.subscriber.complete();\n        },\n      });\n    }\n\n    return () => this.tearDown();\n  }\n\n  private tearDown() {\n    if (!this.canLive || this.completed || this.error) {\n      // LOG(`UNSUBSCRIBE${this.event.id}: ${this.event.fromRow} - ${this.event.toRow}`);\n      this.baseSubscription.unsubscribe();\n      this.onKilled.next();\n      this.onKilled.complete();\n    } else {\n      // LOG(`REMOVE CREDIT${this.event.id}: ${this.event.fromRow} - ${this.event.toRow}`);\n      this.canLive = false;\n    }\n  }\n}\n","import { from, isObservable, Observable, of } from 'rxjs';\nimport { PblDataSourceTriggerChangeHandler } from '@pebula/ngrid';\nimport { PblInfiniteScrollTriggerChangedEvent } from '../infinite-scroll-datasource.types';\nimport { TriggerExecutionProxyObservable } from './execution-proxy-observer';\n\n// const LOG = msg => console.log(msg);\n\n/**\n * Execute a data source trigger based on infinite trigger change events provided.\n * Each time an execution starts the event is compared to already in-process event that were executed and did not yet finish.\n * If the event overlaps with an existing event, it will not execute.\n * Events overlap when the event to be executed has a range that is contained with any other in-flight event.\n */\nexport class TriggerExecutionQueue<T, TData = any> {\n\n  public slots = 2;\n\n  private runningEvents = new Map<PblInfiniteScrollTriggerChangedEvent<TData>, TriggerExecutionProxyObservable<T[]>>();\n\n  constructor(private readonly handler: PblDataSourceTriggerChangeHandler<T, PblInfiniteScrollTriggerChangedEvent<TData>>) { }\n\n  /**\n   * Execute an event and keep track of it until execution is done.\n   * Before execution, check if one of the events currently in execution, contains the provided event.\n   * If so, the execution is will not go through.\n   * Event contains another event only if the range (from/to) of the other event is within the boundaries of it's own range.\n   * For example, the event from row 50 to row 100 contains the event from row 70 to row 100 but it does not contain\n   * the event from row 49 to row 50.\n   * @param event\n   * @param fallbackToOverlap When true (and then a containing event is found), will signal the containing event to\n   * that an event with a set or all items it is fetching trying to execute again but was denied and it will also\n   * return it's currently running observable.\n   * Due to how the datasource works, it will try to unsubscribe/cancel the currently running observable and subscribe\n   * to the returned observable (which is the same), by signaling we allow the running observable to prevent closing the\n   * running call and remain in fact we're making it \"hot\" for period of time so it will not cancel any running call.\n   */\n  execute(event: PblInfiniteScrollTriggerChangedEvent<TData>, fallbackToOverlap = false): false | Observable<T[]> {\n    const overlap = this.checkOverlap(event);\n    if (!!overlap) {\n      if (fallbackToOverlap) {\n        overlap.keepAlive();\n        return overlap;\n      }\n      return false;\n    }\n\n    // LOG(`EXECUTING HANDLER: ${event.fromRow} - ${event.toRow}`);\n    const result = this.handler(event);\n    if (result === false) {\n      return false;\n    }\n\n\n    const triggerResult = Array.isArray(result)\n      ? of(result)\n      : isObservable(result)\n        ? result\n        : from(result)\n    ;\n\n    // LOG(`CREATE[${event.id}]: ${event.fromRow} - ${event.toRow}`);\n    const obs = new TriggerExecutionProxyObservable<T[]>(event, triggerResult);\n    obs.onKilled.subscribe(() => this.runningEvents.delete(event));\n\n    this.runningEvents.set(event, obs);\n\n    return obs;\n  }\n\n  private checkOverlap(event: PblInfiniteScrollTriggerChangedEvent<TData>) {\n    for (const [e, v] of this.runningEvents.entries()) {\n      if (event.fromRow >= e.fromRow && event.toRow <= e.toRow) {\n        // LOG(`OVERLAPPED: ${event.fromRow} - ${event.toRow}`);\n        return v;\n      }\n    }\n  }\n}\n","import { Observable } from 'rxjs';\nimport { tap } from 'rxjs/operators';\nimport { PblInfiniteScrollTriggerChangedEvent } from './infinite-scroll-datasource.types';\n\n/**\n * @internal\n */\nexport class EventState<T> {\n  private done: boolean;\n  private notFull: boolean;\n\n  constructor(public readonly event: PblInfiniteScrollTriggerChangedEvent = null) { }\n\n\n  isDone() {\n    return this.done;\n  }\n\n  rangeEquals(event: PblInfiniteScrollTriggerChangedEvent) {\n    return event.fromRow === this.event.fromRow && event.toRow === this.event.toRow;\n  }\n\n  /**\n   * When true is returned, the handling of `PblDataSource.onRenderedDataChanged` should be skipped.\n   * Usually, the event state will keep track of the returned value and check if the length of items returned covers\n   * the total length required by the event. Only when not enough items have been returned, the returned value will be true.\n   * Once true is returned, it will toggle back to false, i.e. it will tell you to skip once only.\n   */\n  skipNextRender() {\n    if (this.notFull) {\n      this.notFull = false;\n      return true;\n    }\n    return false;\n  }\n\n  pipe() {\n    return (o: Observable<T[]>) => {\n      return o.pipe(\n        tap( values => {\n          this.done = true;\n          this.notFull = values.length < this.event.offset;\n        }),\n      );\n    }\n  }\n}\n","import { Observable, of, BehaviorSubject } from 'rxjs';\nimport { tap, finalize, take, filter, map } from 'rxjs/operators';\nimport { PblDataSourceTriggerChangedEvent, DataSourceOf, PblDataSourceConfigurableTriggers } from '@pebula/ngrid/core';\nimport { PblInfiniteScrollFactoryOptions, PblInfiniteScrollDsOptions, PblInfiniteScrollTriggerChangedEvent } from './infinite-scroll-datasource.types';\nimport { PblInfiniteScrollDataSourceCache } from './infinite-scroll-datasource.cache';\nimport { normalizeOptions, shouldTriggerInvisibleScroll, tryAddVirtualRowsBlock, updateCacheAndDataSource, upgradeChangeEventToInfinite } from './utils';\nimport { PblInfiniteScrollDataSource } from './infinite-scroll-datasource';\nimport { PblInfiniteScrollDataSourceAdapter } from './infinite-scroll-datasource-adapter';\nimport { TriggerExecutionQueue } from './trigger-execution-queue';\nimport { CacheBlock } from './caching';\nimport { EventState } from './event-state';\n\n// const LOG = msg => console.log(msg) ;\n\ndeclare module '@pebula/ngrid/core/lib/data-source/adapter/types' {\n  interface PblDataSourceTriggerChangedEventSource {\n   /**\n    * The source of the event was from a scroll that reached into a group of rows that the grid needs to fetch.\n    */\n    infiniteScroll: true;\n  }\n}\n\nexport class PblInfiniteScrollDSContext<T, TData = any> {\n\n  options: PblInfiniteScrollDsOptions;\n  totalLength: number;\n  cache: PblInfiniteScrollDataSourceCache<T, TData>;\n\n  private ds: PblInfiniteScrollDataSource<T, TData>;\n  private adapter: PblInfiniteScrollDataSourceAdapter<T, TData>;\n  private currentSessionToken: any;\n  private queue: TriggerExecutionQueue<T, TData>;\n  private onVirtualLoading = new BehaviorSubject<boolean>(false);\n  private virtualLoadingSessions = 0;\n  private pendingTrigger$: Observable<T[]>;\n  private customTriggers: false | Partial<Record<keyof PblDataSourceConfigurableTriggers, boolean>>;\n  private timeoutCancelTokens = new Set<number>();\n  private ignoreScrolling: boolean = false;\n  private lastEventState = new EventState<T>();\n\n  constructor(private factoryOptions: PblInfiniteScrollFactoryOptions<T, TData>) {\n    this.options = normalizeOptions(factoryOptions.infiniteOptions);\n    if (this.options.initialVirtualSize > 0) {\n      this.totalLength = this.options.initialVirtualSize;\n    }\n    this.queue = new TriggerExecutionQueue<T, TData>(this.factoryOptions.onTrigger);\n  }\n\n  onTrigger(rawEvent: PblDataSourceTriggerChangedEvent<TData>): false | DataSourceOf<T> {\n    if (rawEvent.isInitial) {\n      return this.invokeInitialOnTrigger(rawEvent);\n    }\n\n    if (this.pendingTrigger$) {\n      // LOG(`HAS pendingTrigger$`);\n      const pendingTrigger$ = this.pendingTrigger$;\n      this.pendingTrigger$ = undefined;\n      if (rawEvent.data.changed && (rawEvent.data.curr as any) === pendingTrigger$) {\n        // LOG(`PENDING - MATCHED!`);\n        this.currentSessionToken = undefined;\n        return pendingTrigger$\n          .pipe(\n            finalize(() => {\n              // LOG(`PENDING - RESULT DONE`);\n              this.deferSyncRows(16, () => this.tickVirtualLoading(-1));\n\n            }));\n      }\n    }\n\n    if (this.currentSessionToken && rawEvent.data.changed && rawEvent.data.curr === this.currentSessionToken) {\n      if (this.ds.hostGrid.viewport.isScrolling) {\n        this.handleScrolling(rawEvent);\n        return of(this.ds.source);\n      }\n\n      const { result, event } = this.invokeRuntimeOnTrigger(rawEvent);\n      if (!result || !event) { // !event for type gate, because if we have \"result: then \"event\" is always set\n        // LOG('NO SCROLL - FALSE TRIGGER!');\n        this.currentSessionToken = undefined;\n        return false;\n      } else {\n        const { source } = this.ds;\n        if (tryAddVirtualRowsBlock(source, event, this.options.blockSize)) {\n          this.pendingTrigger$ = result;\n          this.tickVirtualLoading(1);\n          // LOG('NO SCROLL - VIRTUAL ROWS ADDED');\n          return of(source)\n            .pipe(\n              finalize(() => {\n                this.deferSyncRows();\n                // LOG('NO SCROLL - VIRTUAL ROWS RENDERED');\n                this.currentSessionToken = undefined;\n                this.ds.refresh(result as any);\n              }));\n        } else {\n          // LOG('NO SCROLL - NO VIRTUAL ROWS ADDED');\n          return result\n            .pipe(\n              finalize(() => {\n                // LOG(`NO SCROLL - RESULT DONE`);\n                this.deferSyncRows(16);\n                this.currentSessionToken = undefined;\n              }));\n        }\n      }\n    }\n\n    if (rawEvent.data.changed || (this.customTriggers && PblInfiniteScrollDataSourceAdapter.isCustomBehaviorEvent(rawEvent, this.customTriggers))) {\n      this.cache.clear();\n      rawEvent.isInitial = true;\n      return this.invokeInitialOnTrigger(rawEvent);\n    }\n\n    return false;\n    // throw new Error('Invalid');\n  }\n\n  getAdapter(): PblInfiniteScrollDataSourceAdapter<T, TData> {\n    if (!this.adapter) {\n      this.customTriggers = this.factoryOptions.customTriggers || false;\n      // we can't allow any internal trigger handlers to run\n      // It will throw the entire datasource out of sync, infinite ds can't do that\n      this.adapter = new PblInfiniteScrollDataSourceAdapter<T, TData>(this, { filter: true, sort: true, pagination: true }, this.onVirtualLoading);\n    }\n    return this.adapter;\n  }\n\n  getDataSource(): PblInfiniteScrollDataSource<T, TData> {\n    if (!this.ds) {\n      this.ds = new PblInfiniteScrollDataSource<T, TData>(this, this.factoryOptions.dsOptions)\n      this.cache = new PblInfiniteScrollDataSourceCache<T, TData>(this, this.factoryOptions.cacheOptions);\n      this.ds.onRenderedDataChanged.subscribe(() => this.onRenderedDataChanged() );\n      if (this.factoryOptions.onCreated) {\n        this.factoryOptions.onCreated(this.ds);\n      }\n    }\n    return this.ds;\n  }\n\n  dispose() {\n    this.onVirtualLoading.complete();\n    for (const t of this.timeoutCancelTokens.values()) {\n      clearTimeout(t);\n    }\n  }\n\n  /**\n   * This is where we detect if we need to internally invoke a trigger because we've reached an area\n   * in the grid where row's does not exists but we show the dummy row, hence we need to fetch them.\n   * The grid will never trigger an event here since from the grid's perspective a row is showing...\n   * This detection also handle's scrolling and session so we don't invoke the trigger to much.\n   */\n  private onRenderedDataChanged() {\n    if (this.lastEventState.skipNextRender()) {\n      // if the current event returned items that did not occupy the whole range of the event\n      // stop, we don't want to check anything cause we already know we are missing items.\n      // since we know we're missing items, we also know we're going to call the same range again which\n      // did not return anyway, so it is useless and in the worst case might cause infinite loop\n      // LOG(`RENDER DATA SKIPPING DUE TO SKIP NEXT RENDER!`);\n      return;\n    }\n    if (!this.currentSessionToken) {\n      if (shouldTriggerInvisibleScroll(this)) {\n        // LOG(`RENDER DATA CHANGED FROM ROW ${this.ds.renderStart}`);\n        const t = this.currentSessionToken = {};\n        this.safeAsyncOp(() => {\n          if (this.currentSessionToken === t) {\n            this.ds.refresh(t as any);\n          }\n        }, 0);\n      }\n    } else {\n      // LOG(`RENDER DATA WITH SESSION FROM ROW ${this.ds.renderStart}`);\n      if (!this.ds.hostGrid.viewport.isScrolling) {\n        // LOG(`SESSION OVERRIDE`);\n        this.ds.refresh(this.currentSessionToken = {} as any);\n      } else {\n        if (!this.ignoreScrolling) {\n          this.ignoreScrolling = true;\n          this.ds.hostGrid.viewport.scrolling\n            .pipe(\n              filter( d => d === 0),\n              take(1),\n            )\n            .subscribe(d => {\n              this.ignoreScrolling = false;\n              if (shouldTriggerInvisibleScroll(this)) {\n                // LOG(`OVERRIDING AFTER SCROLL SESSION`);\n                this.currentSessionToken = undefined;\n                this.onRenderedDataChanged();\n              }\n            });\n        }\n      }\n    }\n  }\n\n  /**\n   * Create a new event state for the given event, store it in the lastEventState property\n   * and returns a pipe that will sync the state of the event as the call progress.\n   * @param event\n   */\n  private wrapEventState(event: PblInfiniteScrollTriggerChangedEvent<TData>) {\n    return (this.lastEventState = new EventState<T>(event)).pipe();\n  }\n\n  private deferSyncRows(ms = 0, runBefore?: () => void, runAfter?: () => void) {\n    this.safeAsyncOp(() => {\n      runBefore && runBefore();\n      this.ds.hostGrid.rowsApi.syncRows('data', true);\n      runAfter && runAfter();\n    }, ms);\n  }\n\n  private safeAsyncOp(fn: () => void, delay: number) {\n    const cancelToken = setTimeout(() => {\n      this.timeoutCancelTokens.delete(cancelToken);\n      fn();\n    }, delay) as unknown as number;\n    this.timeoutCancelTokens.add(cancelToken);\n  }\n\n  private tickVirtualLoading(value: -1 | 1) {\n    this.virtualLoadingSessions = this.virtualLoadingSessions + value;\n    const inVirtualLoad = this.onVirtualLoading.value;\n    switch (this.virtualLoadingSessions) {\n      case 0:\n        inVirtualLoad && this.onVirtualLoading.next(false);\n        break;\n      case 1:\n        !inVirtualLoad && this.onVirtualLoading.next(true);\n        break;\n      default:\n        if (this.virtualLoadingSessions < 0) {\n          this.virtualLoadingSessions = 0;\n        }\n        break;\n    }\n  }\n\n  private handleScrolling(rawEvent: PblDataSourceTriggerChangedEvent<TData>) {\n    this.tickVirtualLoading(1);\n    const newBlock = this.cache.matchNewBlock();\n    const event = newBlock ? this.tryGetInfiniteEvent(rawEvent, newBlock) : false as const;\n    if (event !== false) {\n      if (tryAddVirtualRowsBlock(this.ds.source, event, this.options.blockSize)) {\n        // LOG('SCROLL - VIRTUAL ROWS ADDED');\n      }\n    }\n\n    this.ds.hostGrid.viewport.scrolling\n      .pipe(\n        filter( d => d === 0),\n        take(1),\n      )\n      .subscribe(d => {\n        const { result } = this.invokeRuntimeOnTrigger(rawEvent);\n        if (!!result) {\n          if (this.pendingTrigger$) {\n            this.tickVirtualLoading(-1);\n          }\n          // LOG('SCROLL DONE - HAS RESULT - HAS PENDING');\n          this.ds.refresh(this.pendingTrigger$ = result as any);\n        } else if (!this.pendingTrigger$) {\n          // LOG('SCROLL DONE = NO RESULT - NOT HAS PENDING');\n          this.ds.refresh(this.pendingTrigger$ = of(this.ds.source) as any);\n        } else {\n          // LOG('SCROLL DONE = NO RESULT - HAS PENDING');\n          this.tickVirtualLoading(-1);\n        }\n      });\n  }\n\n  private invokeInitialOnTrigger(rawEvent: PblDataSourceTriggerChangedEvent<TData>): false | DataSourceOf<T> {\n    const event = this.tryGetInfiniteEvent(rawEvent, rawEvent.isInitial ? this.cache.createInitialBlock() : this.cache.createInitialBlock());\n    const result = this.queue.execute(event);\n    return result && result.pipe(\n      this.wrapEventState(event),\n      tap( values => {\n        this.cache.clear();\n        if(values.length > 1) {\n          this.cache.update(0, values.length - 1, 1);\n        }\n\n        PblInfiniteScrollDataSource.updateVirtualSize(this.options.initialVirtualSize, values);\n        if (!rawEvent.isInitial) {\n          this.ds.hostGrid.viewport.scrollToOffset(0);\n        }\n      }),\n    );\n  }\n\n  private invokeRuntimeOnTrigger(rawEvent: PblDataSourceTriggerChangedEvent<TData>): { result?: Observable<T[]>; event: false | PblInfiniteScrollTriggerChangedEvent<TData> } {\n    const newBlock = this.cache.matchNewBlock();\n    const event = newBlock ? this.tryGetInfiniteEvent(rawEvent, newBlock) : false as const;\n\n    if(event !== false) {\n      if (this.lastEventState.isDone() && this.lastEventState.rangeEquals(event)) {\n        return { event: false };\n      }\n      event.eventSource = 'infiniteScroll';\n      const triggerResult = this.queue.execute(event, true);\n      if (triggerResult !== false) {\n        return {\n          event,\n          result: triggerResult\n            .pipe(\n              // tap( () => LOG(`TRIGGER[${event.id}]: ${event.fromRow} - ${event.toRow}`)),\n              this.wrapEventState(event),\n              map( values => updateCacheAndDataSource(this, event, values) ),\n            ),\n        };\n      }\n    }\n\n    return { event };\n  }\n\n  private tryGetInfiniteEvent(rawEvent: PblDataSourceTriggerChangedEvent<TData>, block: CacheBlock) {\n    const totalLength = this.totalLength || 0;\n    rawEvent.updateTotalLength = (totalLength: number) => { this.totalLength = totalLength; };\n    (rawEvent as PblInfiniteScrollTriggerChangedEvent).totalLength = totalLength;\n    return upgradeChangeEventToInfinite<T, TData>(totalLength, rawEvent, block);\n  }\n\n}\n","import { PblDataSourceBaseFactory, PblDataSourceAdapter } from '@pebula/ngrid/core';\nimport { PblInfiniteScrollFactoryOptions, PblInfiniteScrollDsOptions, PblInfiniteScrollTriggerChangedEvent, PblInfiniteScrollCacheOptions } from './infinite-scroll-datasource.types';\nimport { PblInfiniteScrollDSContext } from './infinite-scroll-datasource.context';\nimport { PblInfiniteScrollDataSource } from './infinite-scroll-datasource';\nimport { PblInfiniteScrollDataSourceAdapter } from './infinite-scroll-datasource-adapter';\nimport { PblNgridCacheAdapter, PblNgridCacheAdaptersMap } from './caching';\n\nexport class PblInfiniteScrollDSFactory<T, TData = any> extends PblDataSourceBaseFactory<T,\n                                                                                         TData,\n                                                                                         PblInfiniteScrollTriggerChangedEvent<TData>,\n                                                                                         PblInfiniteScrollDataSourceAdapter<T, TData>,\n                                                                                         PblInfiniteScrollDataSource<T, TData>> {\n  private infiniteScrollOptions: PblInfiniteScrollDsOptions;\n  private cacheOptions: PblInfiniteScrollCacheOptions;\n\n  private context: PblInfiniteScrollDSContext<T, TData>;\n\n  withInfiniteScrollOptions(options: PblInfiniteScrollDsOptions): this {\n    this.infiniteScrollOptions = options;\n    return this;\n  }\n\n  withCacheOptions<P extends keyof PblNgridCacheAdaptersMap>(type: P, options?: PblNgridCacheAdaptersMap[P] extends PblNgridCacheAdapter<infer U> ? U : never): this {\n    this.cacheOptions = { type, options: options as any };\n    return this;\n  }\n\n  create(): PblInfiniteScrollDataSource<T, TData> {\n    const factoryOptions: PblInfiniteScrollFactoryOptions<T, TData> = {\n      onTrigger: this._adapter.onTrigger,\n      customTriggers: this._adapter.customTriggers,\n      onCreated: this._onCreated,\n      dsOptions: this._dsOptions,\n      infiniteOptions: this.infiniteScrollOptions,\n      cacheOptions: this.cacheOptions,\n    };\n\n    this.context = new PblInfiniteScrollDSContext(factoryOptions);\n    super.onCreated(null);\n\n    return super.create();\n  }\n\n  protected createAdapter(): PblInfiniteScrollDataSourceAdapter<T, TData> {\n    return this.context.getAdapter();\n  }\n\n  protected createDataSource(adapter: PblDataSourceAdapter<T, TData, PblInfiniteScrollTriggerChangedEvent<TData>>): PblInfiniteScrollDataSource<T, TData> {\n    return this.context.getDataSource();\n  }\n}\n\nexport function createInfiniteScrollDS<T, TData = T[]>(): PblInfiniteScrollDSFactory<T, TData> {\n  return new PblInfiniteScrollDSFactory<T, TData>();\n}\n","// tslint:disable:use-host-property-decorator\nimport {\n  Directive,\n  OnInit,\n  OnDestroy,\n} from '@angular/core';\n\nimport { PblNgridRowDef } from '@pebula/ngrid';\n\ndeclare module '@pebula/ngrid/core/lib/registry/types' {\n  interface PblNgridSingleRegistryMap {\n    infiniteVirtualRow?: PblNgridInfiniteVirtualRowRefDirective;\n  }\n}\n\n@Directive({\n  selector: '[pblNgridInfiniteVirtualRowDef]',\n  inputs: ['columns: pblNgridInfiniteVirtualRowDefColumns', 'when: pblNgridInfiniteVirtualRowDefWhen'],\n})\nexport class PblNgridInfiniteVirtualRowRefDirective<T = any> extends PblNgridRowDef<T> implements OnInit, OnDestroy {\n\n  ngOnInit(): void {\n    this.registry.setSingle('infiniteVirtualRow', this as any);\n  }\n\n  ngOnDestroy(): void {\n    this.registry.setSingle('infiniteVirtualRow',  undefined);\n  }\n}\n","import { ChangeDetectionStrategy, Component, ViewEncapsulation } from '@angular/core';\nimport { CdkRow } from '@angular/cdk/table';\nimport { PblNgridRowComponent } from '@pebula/ngrid';\n\nexport const PBL_NGRID_ROW_TEMPLATE  = `<ng-content select=\".pbl-ngrid-row-prefix\"></ng-content><ng-content></ng-content><ng-content select=\".pbl-ngrid-row-suffix\"></ng-content>`;\n\n@Component({\n  selector: 'pbl-ngrid-row[infiniteRow]',\n  template: PBL_NGRID_ROW_TEMPLATE,\n  host: { // tslint:disable-line:no-host-metadata-property\n    'class': 'pbl-ngrid-row',\n    'role': 'row',\n  },\n  providers: [\n    { provide: CdkRow, useExisting: PblNgridRowComponent }\n  ],\n  exportAs: 'pblNgridInfiniteRow',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n})\nexport class PblNgridInfiniteRowComponent<T = any> extends PblNgridRowComponent<T> {\n\n  canCreateCell() {\n    return false;\n  }\n}\n","import { Component, ViewEncapsulation } from '@angular/core';\nimport { PblColumn } from '@pebula/ngrid';\n\n/**\n * Use to set the a default `pblNgridInfiniteVirtualRowDef` if the user did not set one.\n */\n@Component({\n  selector: 'pbl-ngrid-default-infinite-virtual-row',\n  templateUrl: './default-infinite-virtual-row.component.html',\n  styleUrls: ['./default-infinite-virtual-row.component.scss'],\n  encapsulation: ViewEncapsulation.None,\n})\nexport class PblNgridDefaultInfiniteVirtualRowComponent {\n  protected createCell(column: PblColumn) {\n  }\n\n  protected destroyCell(column: PblColumn) {\n  }\n}\n","<pbl-ngrid-row in *pblNgridInfiniteVirtualRowDef=\"let row;\" class=\"pbl-ngrid-infinite-virtual-row\" infiniteRow>\n  ...Loading\n</pbl-ngrid-row>\n","import { Injector, ComponentFactoryResolver, ComponentRef } from '@angular/core';\n\nimport { ON_DESTROY } from '@pebula/ngrid/core';\nimport { PblNgridComponent, PblNgridPluginController } from '@pebula/ngrid';\n\nimport { PblNgridInfiniteVirtualRowRefDirective } from './infinite-virtual-row/directives';\nimport { PblInfiniteScrollDataSource } from './infinite-scroll-data-source/infinite-scroll-datasource';\nimport { INFINITE_SCROLL_DEFFERED_ROW } from './infinite-scroll-data-source/infinite-scroll-deffered-row';\nimport { PblNgridDefaultInfiniteVirtualRowComponent } from './default-infinite-virtual-row/default-infinite-virtual-row.component';\n\ndeclare module '@pebula/ngrid/lib/ext/types' {\n  interface PblNgridPluginExtension {\n    infiniteScroll?: PblNgridInfiniteScrollPlugin;\n  }\n  interface PblNgridPluginExtensionFactories {\n    infiniteScroll: keyof typeof PblNgridInfiniteScrollPlugin;\n  }\n}\n\nexport const PLUGIN_KEY = 'infiniteScroll' as const;\n\nconst IS_INFINITE_VIRTUAL_ROW = (index: number, rowData: any) => {\n  return rowData === INFINITE_SCROLL_DEFFERED_ROW;\n};\nconst IS_NOT_INFINITE_VIRTUAL_ROW = (index: number, rowData: any) => {\n  return !IS_INFINITE_VIRTUAL_ROW(index, rowData);\n};\n\nexport class PblNgridInfiniteScrollPlugin<T = any> {\n\n  static create(grid: PblNgridComponent, injector: Injector): PblNgridInfiniteScrollPlugin {\n    const pluginCtrl = PblNgridPluginController.find(grid);\n    return new PblNgridInfiniteScrollPlugin(grid, pluginCtrl, injector);\n  }\n\n  private _enabled: boolean = false;\n  private _infiniteVirtualRowDef: PblNgridInfiniteVirtualRowRefDirective<T>;\n  private _infiniteVirtualRowRef: ComponentRef<PblNgridDefaultInfiniteVirtualRowComponent>;\n  private _removePlugin: (grid: PblNgridComponent<any>) => void;\n\n  constructor(private grid: PblNgridComponent<any>, private pluginCtrl: PblNgridPluginController<T>, private injector: Injector) {\n    this._removePlugin = pluginCtrl.setPlugin(PLUGIN_KEY, this);\n\n    grid.registry.changes\n      .subscribe( changes => {\n        for (const c of changes) {\n          switch (c.type) {\n            case 'infiniteVirtualRow':\n              if (c.op === 'remove') {\n                this.pluginCtrl.extApi.cdkTable.removeRowDef(c.value);\n                this._infiniteVirtualRowDef = undefined;\n              }\n              this.setupInfiniteVirtualRow();\n              break;\n          }\n        }\n      });\n\n    pluginCtrl.events\n      .pipe(ON_DESTROY)\n      .subscribe(() => {\n        if (this._infiniteVirtualRowRef) {\n          this._infiniteVirtualRowRef.destroy();\n        }\n        this._removePlugin(this.grid);\n      });\n\n    pluginCtrl.events.subscribe( event => {\n      if (event.kind === 'onDataSource') {\n        const prevState = this._enabled;\n        this._enabled = event.curr instanceof PblInfiniteScrollDataSource;\n\n        if (this._enabled !== prevState) {\n          pluginCtrl.onInit().subscribe( () => this.updateTable() );\n        }\n      }\n    });\n  }\n\n  private setupInfiniteVirtualRow(): void {\n    const grid = this.grid;\n    const cdkTable = this.pluginCtrl.extApi.cdkTable;\n    if (this._infiniteVirtualRowDef) {\n      cdkTable.removeRowDef(this._infiniteVirtualRowDef);\n      this._infiniteVirtualRowDef = undefined;\n    }\n    if (this._enabled) {\n      let infiniteVirtualRow = grid.registry.getSingle('infiniteVirtualRow');\n      if (infiniteVirtualRow) {\n        this._infiniteVirtualRowDef = infiniteVirtualRow = infiniteVirtualRow.clone();\n        Object.defineProperty(infiniteVirtualRow, 'when', { enumerable: true,  get: () => IS_INFINITE_VIRTUAL_ROW });\n      } else if (!this._infiniteVirtualRowRef) {\n        // TODO: move to module? set in root registry? put elsewhere to avoid grid sync (see event of registry change)...\n        this._infiniteVirtualRowRef = this.injector.get(ComponentFactoryResolver)\n          .resolveComponentFactory(PblNgridDefaultInfiniteVirtualRowComponent)\n          .create(this.injector);\n        this._infiniteVirtualRowRef.changeDetectorRef.detectChanges();\n        return;\n      }\n    }\n    this.resetTableRowDefs();\n  }\n\n  private resetTableRowDefs(): void {\n    if (this._infiniteVirtualRowDef) {\n      this._enabled === false\n        ? this.pluginCtrl.extApi.cdkTable.removeRowDef(this._infiniteVirtualRowDef)\n        : this.pluginCtrl.extApi.cdkTable.addRowDef(this._infiniteVirtualRowDef)\n      ;\n    }\n  }\n\n  /**\n   * Update the grid with detail row infor.\n   * Instead of calling for a change detection cycle we can assign the new predicates directly to the pblNgridRowDef instances.\n   */\n  private updateTable(): void {\n    this.grid._tableRowDef.when = !!this._enabled ? IS_NOT_INFINITE_VIRTUAL_ROW : undefined;\n    this.setupInfiniteVirtualRow();\n    // Once we changed the `when` predicate on the `CdkRowDef` we must:\n    //   1. Update the row cache (property `rowDefs`) to reflect the new change\n    this.pluginCtrl.extApi.cdkTable.updateRowDefCache();\n\n    //   2. re-render all rows.\n    // The logic for re-rendering all rows is handled in `CdkTable._forceRenderDataRows()` which is a private method.\n    // This is a workaround, assigning to `multiTemplateDataRows` will invoke the setter which\n    // also calls `CdkTable._forceRenderDataRows()`\n    // TODO: This is risky, the setter logic might change.\n    // for example, if material will check for change in `multiTemplateDataRows` setter from previous value...\n    this.pluginCtrl.extApi.cdkTable.multiTemplateDataRows = !!this._enabled;\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { CdkTableModule } from '@angular/cdk/table';\nimport { PblNgridModule, ngridPlugin, PblNgridPluginController } from '@pebula/ngrid';\nimport { PblNgridTargetEventsModule } from '@pebula/ngrid/target-events';\n\nimport './infinite-scroll-plugin'; // to make sure d.ts stay in published lib and so agumentation kicks in\nimport { PblNgridInfiniteScrollPlugin, PLUGIN_KEY } from './infinite-scroll-plugin';\nimport { PblNgridInfiniteVirtualRowRefDirective } from './infinite-virtual-row/directives';\nimport { PblNgridDefaultInfiniteVirtualRowComponent } from './default-infinite-virtual-row/default-infinite-virtual-row.component';\nimport { PblNgridInfiniteRowComponent } from './infinite-virtual-row/row';\n\n@NgModule({\n  imports: [ CommonModule, CdkTableModule, PblNgridModule, PblNgridTargetEventsModule ],\n  declarations: [ PblNgridInfiniteVirtualRowRefDirective, PblNgridInfiniteRowComponent, PblNgridDefaultInfiniteVirtualRowComponent ],\n  exports: [ PblNgridInfiniteVirtualRowRefDirective, PblNgridInfiniteRowComponent],\n  // TODO(REFACTOR_REF 2): remove when ViewEngine is no longer supported by angular (V12 ???)\n  entryComponents: [ PblNgridDefaultInfiniteVirtualRowComponent ],\n})\nexport class PblNgridInfiniteScrollModule {\n  static readonly NGRID_PLUGIN = ngridPlugin({ id: PLUGIN_KEY, factory: 'create' }, PblNgridInfiniteScrollPlugin);\n\n  constructor() {\n    PblNgridPluginController.onCreatedSafe(\n      PblNgridInfiniteScrollModule,\n      (grid, controller) => {\n        if (controller && controller.hasAncestor(PblNgridInfiniteScrollModule)) {\n          controller.createPlugin(PLUGIN_KEY);\n        }\n      },\n    );\n  }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}