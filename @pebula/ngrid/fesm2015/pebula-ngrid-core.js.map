{"version":3,"file":"pebula-ngrid-core.js","sources":["../../../../libs/ngrid/core/src/lib/events/event-pipes.ts","../../../../libs/ngrid/core/src/lib/utils/unrx.ts","../../../../libs/ngrid/core/src/lib/utils/array.ts","../../../../libs/ngrid/core/src/lib/utils/styling.differ.ts","../../../../libs/ngrid/core/src/lib/utils/column.ts","../../../../libs/ngrid/core/src/lib/data-source/triggers/pagination/token-paginator.ts","../../../../libs/ngrid/core/src/lib/data-source/triggers/pagination/paging-paginator.ts","../../../../libs/ngrid/core/src/lib/data-source/triggers/sort/sort.ts","../../../../libs/ngrid/core/src/lib/data-source/triggers/filter/filter.ts","../../../../libs/ngrid/core/src/lib/data-source/adapter/utils.ts","../../../../libs/ngrid/core/src/lib/data-source/adapter/adapter.ts","../../../../libs/ngrid/core/src/lib/data-source/data-source.ts","../../../../libs/ngrid/core/src/lib/data-source/base/factory.ts","../../../../libs/ngrid/core/src/lib/data-source/factory.ts","../../../../libs/ngrid/core/src/lib/configuration/config.ts","../../../../libs/ngrid/core/src/lib/errors/deprecated.ts","../../../../libs/ngrid/core/src/pebula-ngrid-core.ts"],"sourcesContent":["import { Observable, of, Subject } from 'rxjs';\nimport { filter, take, mapTo } from 'rxjs/operators';\n\nimport { PblNgridEventsMap, PblNgridEvents } from './ngrid-events';\n\nconst eventFilterFactory = <T extends keyof PblNgridEventsMap>(kind: T) => (o: Observable<PblNgridEvents>) => o.pipe(filter( e => e.kind === kind )) as Observable<PblNgridEventsMap[T]>;\nconst once = <T>(pipe: (o: Observable<PblNgridEvents>) => Observable<T>) => (o: Observable<PblNgridEvents>) => pipe(o).pipe(take(1));\n\nexport const ON_CONSTRUCTED = once(eventFilterFactory('onConstructed'));\nexport const ON_INIT = once(eventFilterFactory('onInit'));\nexport const ON_DESTROY = once(eventFilterFactory('onDestroy'));\nexport const ON_BEFORE_INVALIDATE_HEADERS = eventFilterFactory('beforeInvalidateHeaders');\nexport const ON_INVALIDATE_HEADERS = eventFilterFactory('onInvalidateHeaders');\nexport const ON_RESIZE_ROW = eventFilterFactory('onResizeRow');\n","import { Observable, Subject } from 'rxjs';\nimport { filter, takeUntil } from 'rxjs/operators';\n\n/**\n * Emits the values emitted by the source observable until a kill signal is sent to the group.\n * You can also specify a `subKillGroup` which can be used to kill specific subscriptions within a group.\n *\n * When a `killGroup` is \"killed\" all `subKillGroup` are killed as well. When a `subKillGroup` is \"killed\" the group remains\n * as well as other \"subKillGroup\" registered for that group.\n *\n * > WARNING: Do not apply operators that subscribe internally (e.g. combineLatest, switchMap) after the `killOnDestroy` operator.\n * Internal subscriptions will not unsubscribe automatically.\n * For more information see {@link https://blog.angularindepth.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef | this blog post}\n */\nexport function unrx<T>(killGroup: any, subKillGroup?: any): (source: Observable<T>) => Observable<T> {\n  return unrx.pipe<T>(killGroup, subKillGroup);\n}\n\nexport namespace unrx {\n  const ALL_HANDLERS_TOKEN = {};\n  const notifierStore = new WeakMap<any, Subject<any>>();\n\n  function getNotifier(component: any, create = false): Subject<any> | undefined {\n    let notifier = notifierStore.get(component);\n    if (!notifier && create === true) {\n      notifierStore.set(component, notifier = new Subject<any>());\n    }\n    return notifier;\n  }\n\n  /**\n   * Send a \"kill\" signal to the specified `killGroup`.\n   * This will immediately unsubscribe all subscriptions with the `unrx` pipe registered under the specified `killGroup`.\n   *\n   * Note that the entire `killGroup` is destroyed.\n   */\n  export function kill(killGroup: any): void;\n  /**\n   * Send a \"kill\" signal to a specific `subKillGroup` in the specified `killGroup`.\n   * This will immediately unsubscribe all subscriptions with the `unrx` pipe registered under the specified `killGroup` and `subKillGroup`.\n   *\n   */\n  export function kill(killGroup: any, ...subKillGroup: any[]): void;\n  export function kill(killGroup: any, ...subKillGroup: any[]): void {\n    if (subKillGroup.length === 0) {\n      killAll(killGroup);\n    } else {\n      const notifier = getNotifier(killGroup);\n      if (notifier) {\n        for (const h of subKillGroup) {\n          notifier.next(h);\n        }\n      }\n    }\n  }\n\n  /** {@inheritdoc unrx} */\n  export function pipe<T>(killGroup: any, subKillGroup?: any): (source: Observable<T>) => Observable<T> {\n    return (source: Observable<T>) => source.pipe(\n      takeUntil(getNotifier(killGroup, true).pipe(filter( h => h === ALL_HANDLERS_TOKEN || (subKillGroup && h === subKillGroup ) )))\n    );\n  }\n\n  function killAll(obj: any): void {\n    const notifier = getNotifier(obj);\n    if (notifier) {\n      notifier.next(ALL_HANDLERS_TOKEN);\n      notifier.complete();\n      notifierStore.delete(obj);\n    }\n  }\n}\n","export function removeFromArray<T = any>(arr: T[], predicate: (value: T, index?: number) => boolean): boolean;\nexport function removeFromArray<T = any>(arr: T[], value: T): boolean;\nexport function removeFromArray<T = any>(arr: T[], values: T[]): boolean[];\nexport function removeFromArray<T = any>(arr: T[], value: T | T[] | ((value: T, index?: number) => boolean)): boolean | boolean[] {\n  if (Array.isArray(value)) {\n    return value.map( v => _removeFromArray(arr, v) );\n  } else if (typeof value === 'function') {\n    const idx = arr.findIndex(value as any);\n    if (idx > -1) {\n      arr.splice(idx, 1);\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return _removeFromArray<T>(arr, value);\n  }\n}\n\nfunction _removeFromArray<T = any>(arr: T[], value: T): boolean {\n  const idx = arr.indexOf(value);\n  if (idx > -1) {\n    arr.splice(idx, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n","// This code is taken from an historical point in the angular repo\n// It no longer exists and class/style diffing is done internally in the core package embedded into the renderer.\n//\n// The code was taken from https://github.com/angular/angular/blob/2961bf06c61c78695d453b05fe6d5dd8a4f91da8/packages/common/src/directives/styling_differ.ts\n// And was removed in https://github.com/angular/angular/tree/69de7680f5e08165800d4db399949ea6bdff48d9\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Used to diff and convert ngStyle/ngClass instructions into [style] and [class] bindings.\n *\n * ngStyle and ngClass both accept various forms of input and behave differently than that\n * of how [style] and [class] behave in Angular.\n *\n * The differences are:\n *  - ngStyle and ngClass both **deep-watch** their binding values for changes each time CD runs\n *    while [style] and [class] bindings do not (they check for identity changes)\n *  - ngStyle allows for unit-based keys (e.g. `{'max-width.px':value}`) and [style] does not\n *  - ngClass supports arrays of class values and [class] only accepts map and string values\n *  - ngClass allows for multiple className keys (space-separated) within an array or map\n *     (as the * key) while [class] only accepts a simple key/value map object\n *\n * Having Angular understand and adapt to all the different forms of behavior is complicated\n * and unnecessary. Instead, ngClass and ngStyle should have their input values be converted\n * into something that the core-level [style] and [class] bindings understand.\n *\n * This [StylingDiffer] class handles this conversion by creating a new output value each time\n * the input value of the binding value has changed (either via identity change or deep collection\n * content change).\n *\n * ## Why do we care about ngStyle/ngClass?\n * The styling algorithm code (documented inside of `render3/interfaces/styling.ts`) needs to\n * respect and understand the styling values emitted through ngStyle and ngClass (when they\n * are present and used in a template).\n *\n * Instead of having these directives manage styling on their own, they should be included\n * into the Angular styling algorithm that exists for [style] and [class] bindings.\n *\n * Here's why:\n *\n * - If ngStyle/ngClass is used in combination with [style]/[class] bindings then the\n *   styles and classes would fall out of sync and be applied and updated at\n *   inconsistent times\n * - Both ngClass/ngStyle should respect [class.name] and [style.prop] bindings (and not arbitrarily\n *   overwrite their changes)\n *\n *   ```\n *   <!-- if `w1` is updated then it will always override `w2`\n *        if `w2` is updated then it will always override `w1`\n *        if both are updated at the same time then `w1` wins -->\n *   <div [ngStyle]=\"{width:w1}\" [style.width]=\"w2\">...</div>\n *\n *   <!-- if `w1` is updated then it will always lose to `w2`\n *        if `w2` is updated then it will always override `w1`\n *        if both are updated at the same time then `w2` wins -->\n *   <div [style]=\"{width:w1}\" [style.width]=\"w2\">...</div>\n *   ```\n * - ngClass/ngStyle were written as a directives and made use of maps, closures and other\n *   expensive data structures which were evaluated each time CD runs\n */\nexport class StylingDiffer<T extends({[key: string]: string | null} | {[key: string]: true})> {\n  /**\n   * Normalized string map representing the last value set via `setValue()` or null if no value has\n   * been set or the last set value was null\n   */\n  public readonly value: T|null = null;\n\n  /**\n   * The last set value that was applied via `setValue()`\n   */\n  private _inputValue: T|string|string[]|Set<string>|null = null;\n\n  /**\n   * The type of value that the `_lastSetValue` variable is\n   */\n  private _inputValueType: StylingDifferValueTypes = StylingDifferValueTypes.Null;\n\n  /**\n   * Whether or not the last value change occurred because the variable itself changed reference\n   * (identity)\n   */\n  private _inputValueIdentityChangeSinceLastCheck = false;\n\n  constructor(private _name: string, private _options: StylingDifferOptions) {}\n\n  /**\n   * Sets the input value for the differ and updates the output value if necessary.\n   *\n   * @param value the new styling input value provided from the ngClass/ngStyle binding\n   */\n  setInput(value: T|string[]|string|Set<string>|null): void {\n    if (value !== this._inputValue) {\n      let type: StylingDifferValueTypes;\n      if (!value) {  // matches empty strings, null, false and undefined\n        type = StylingDifferValueTypes.Null;\n        value = null;\n      } else if (Array.isArray(value)) {\n        type = StylingDifferValueTypes.Array;\n      } else if (value instanceof Set) {\n        type = StylingDifferValueTypes.Set;\n      } else if (typeof value === 'string') {\n        if (!(this._options & StylingDifferOptions.AllowStringValue)) {\n          throw new Error(this._name + ' string values are not allowed');\n        }\n        type = StylingDifferValueTypes.String;\n      } else {\n        type = StylingDifferValueTypes.StringMap;\n      }\n\n      this._inputValue = value;\n      this._inputValueType = type;\n      this._inputValueIdentityChangeSinceLastCheck = true;\n      this._processValueChange(true);\n    }\n  }\n\n  /**\n   * Checks the input value for identity or deep changes and updates output value if necessary.\n   *\n   * This function can be called right after `setValue()` is called, but it can also be\n   * called incase the existing value (if it's a collection) changes internally. If the\n   * value is indeed a collection it will do the necessary diffing work and produce a\n   * new object value as assign that to `value`.\n   *\n   * @returns whether or not the value has changed in some way.\n   */\n  updateValue(): boolean {\n    let valueHasChanged = this._inputValueIdentityChangeSinceLastCheck;\n    if (!this._inputValueIdentityChangeSinceLastCheck &&\n        (this._inputValueType & StylingDifferValueTypes.Collection)) {\n      valueHasChanged = this._processValueChange(false);\n    } else {\n      // this is set to false in the event that the value is a collection.\n      // This way (if the identity hasn't changed), then the algorithm can\n      // diff the collection value to see if the contents have mutated\n      // (otherwise the value change was processed during the time when\n      // the variable changed).\n      this._inputValueIdentityChangeSinceLastCheck = false;\n    }\n    return valueHasChanged;\n  }\n\n  /**\n   * Examines the last set value to see if there was a change in content.\n   *\n   * @param inputValueIdentityChanged whether or not the last set value changed in identity or not\n   * @returns `true` when the value has changed (either by identity or by shape if its a\n   * collection)\n   */\n  private _processValueChange(inputValueIdentityChanged: boolean): boolean {\n    // if the inputValueIdentityChanged then we know that input has changed\n    let inputChanged = inputValueIdentityChanged;\n\n    let newOutputValue: T|string|null = null;\n    const trimValues = (this._options & StylingDifferOptions.TrimProperties) ? true : false;\n    const parseOutUnits = (this._options & StylingDifferOptions.AllowUnits) ? true : false;\n    const allowSubKeys = (this._options & StylingDifferOptions.AllowSubKeys) ? true : false;\n\n    switch (this._inputValueType) {\n      // case 1: [input]=\"string\"\n      case StylingDifferValueTypes.String: {\n        if (inputValueIdentityChanged) {\n          // process string input only if the identity has changed since the strings are immutable\n          const keys = (this._inputValue as string).split(/\\s+/g);\n          if (this._options & StylingDifferOptions.ForceAsMap) {\n            newOutputValue = {} as T;\n            for (let i = 0; i < keys.length; i++) {\n              (newOutputValue as any)[keys[i]] = true;\n            }\n          } else {\n            newOutputValue = keys.join(' ');\n          }\n        }\n        break;\n      }\n      // case 2: [input]=\"{key:value}\"\n      case StylingDifferValueTypes.StringMap: {\n        const inputMap = this._inputValue as T;\n        const inputKeys = Object.keys(inputMap);\n\n        if (!inputValueIdentityChanged) {\n          // if StringMap and the identity has not changed then output value must have already been\n          // initialized to a StringMap, so we can safely compare the input and output maps\n          inputChanged = mapsAreEqual(inputKeys, inputMap, this.value as T);\n        }\n\n        if (inputChanged) {\n          newOutputValue = bulidMapFromStringMap(\n              trimValues, parseOutUnits, allowSubKeys, inputMap, inputKeys) as T;\n        }\n        break;\n      }\n      // case 3a: [input]=\"[str1, str2, ...]\"\n      // case 3b: [input]=\"Set\"\n      case StylingDifferValueTypes.Array:\n      case StylingDifferValueTypes.Set: {\n        const inputKeys = Array.from(this._inputValue as string[] | Set<string>);\n        if (!inputValueIdentityChanged) {\n          const outputKeys = Object.keys(this.value !);\n          inputChanged = !keyArraysAreEqual(outputKeys, inputKeys);\n        }\n        if (inputChanged) {\n          newOutputValue =\n              bulidMapFromStringArray(this._name, trimValues, allowSubKeys, inputKeys) as T;\n        }\n        break;\n      }\n      // case 4: [input]=\"null|undefined\"\n      default:\n        inputChanged = inputValueIdentityChanged;\n        newOutputValue = null;\n        break;\n    }\n\n    if (inputChanged) {\n      // update the readonly `value` property by casting it to `any` first\n      (this as any).value = newOutputValue;\n    }\n\n    return inputChanged;\n  }\n}\n\n/**\n * Various options that are consumed by the [StylingDiffer] class\n */\nexport const enum StylingDifferOptions {\n  None = 0b00000,              //\n  TrimProperties = 0b00001,    //\n  AllowSubKeys = 0b00010,      //\n  AllowStringValue = 0b00100,  //\n  AllowUnits = 0b01000,        //\n  ForceAsMap = 0b10000,        //\n}\n\n/**\n * The different types of inputs that the [StylingDiffer] can deal with\n */\nconst enum StylingDifferValueTypes {\n  Null = 0b0000,        //\n  String = 0b0001,      //\n  StringMap = 0b0010,   //\n  Array = 0b0100,       //\n  Set = 0b1000,         //\n  Collection = 0b1110,  //\n}\n\n\n/**\n * @param trim whether the keys should be trimmed of leading or trailing whitespace\n * @param parseOutUnits whether units like \"px\" should be parsed out of the key name and appended to\n *   the value\n * @param allowSubKeys whether key needs to be subsplit by whitespace into multiple keys\n * @param values values of the map\n * @param keys keys of the map\n * @return a normalized string map based on the input string map\n */\nfunction bulidMapFromStringMap(\n    trim: boolean, parseOutUnits: boolean, allowSubKeys: boolean,\n    values: {[key: string]: string | null | true},\n    keys: string[]): {[key: string]: string | null | true} {\n  const map: {[key: string]: string | null | true} = {};\n\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    let value = values[key];\n\n    if (value !== undefined) {\n      if (typeof value !== 'boolean') {\n        value = '' + value;\n      }\n      // Map uses untrimmed keys, so don't trim until passing to `setMapValues`\n      setMapValues(map, trim ? key.trim() : key, value, parseOutUnits, allowSubKeys);\n    }\n  }\n\n  return map;\n}\n\n/**\n * @param trim whether the keys should be trimmed of leading or trailing whitespace\n * @param parseOutUnits whether units like \"px\" should be parsed out of the key name and appended to\n *   the value\n * @param allowSubKeys whether key needs to be subsplit by whitespace into multiple keys\n * @param values values of the map\n * @param keys keys of the map\n * @return a normalized string map based on the input string array\n */\nfunction bulidMapFromStringArray(\n    errorPrefix: string, trim: boolean, allowSubKeys: boolean,\n    keys: string[]): {[key: string]: true} {\n  const map: {[key: string]: true} = {};\n\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    // ngDevMode && assertValidValue(errorPrefix, key);\n    key = trim ? key.trim() : key;\n    setMapValues(map, key, true, false, allowSubKeys);\n  }\n\n  return map;\n}\n\nfunction assertValidValue(errorPrefix: string, value: any) {\n  if (typeof value !== 'string') {\n    throw new Error(\n        `${errorPrefix} can only toggle CSS classes expressed as strings, got: ${value}`);\n  }\n}\n\nfunction setMapValues(\n    map: {[key: string]: unknown}, key: string, value: string | null | true, parseOutUnits: boolean,\n    allowSubKeys: boolean) {\n  if (allowSubKeys && key.indexOf(' ') > 0) {\n    const innerKeys = key.split(/\\s+/g);\n    for (let j = 0; j < innerKeys.length; j++) {\n      setIndividualMapValue(map, innerKeys[j], value, parseOutUnits);\n    }\n  } else {\n    setIndividualMapValue(map, key, value, parseOutUnits);\n  }\n}\n\nfunction setIndividualMapValue(\n    map: {[key: string]: unknown}, key: string, value: string | true | null,\n    parseOutUnits: boolean) {\n  if (parseOutUnits && typeof value === 'string') {\n    // parse out the unit (e.g. \".px\") from the key and append it to the value\n    // e.g. for [width.px]=\"40\" => [\"width\",\"40px\"]\n    const unitIndex = key.indexOf('.');\n    if (unitIndex > 0) {\n      const unit = key.substr(unitIndex + 1);  // skip over the \".\" in \"width.px\"\n      key = key.substring(0, unitIndex);\n      value += unit;\n    }\n  }\n  map[key] = value;\n}\n\n\n/**\n * Compares two maps and returns true if they are equal\n *\n * @param inputKeys value of `Object.keys(inputMap)` it's unclear if this actually performs better\n * @param inputMap map to compare\n * @param outputMap map to compare\n */\nfunction mapsAreEqual(\n    inputKeys: string[], inputMap: {[key: string]: unknown},\n    outputMap: {[key: string]: unknown}, ): boolean {\n  const outputKeys = Object.keys(outputMap);\n\n  if (inputKeys.length !== outputKeys.length) {\n    return true;\n  }\n\n  for (let i = 0, n = inputKeys.length; i <= n; i++) {\n    let key = inputKeys[i];\n    if (key !== outputKeys[i] || inputMap[key] !== outputMap[key]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n\n/**\n * Compares two Object.keys() arrays and returns true if they are equal.\n *\n * @param keyArray1 Object.keys() array to compare\n * @param keyArray1 Object.keys() array to compare\n */\nfunction keyArraysAreEqual(keyArray1: string[] | null, keyArray2: string[] | null): boolean {\n  if (!Array.isArray(keyArray1) || !Array.isArray(keyArray2)) {\n    return false;\n  }\n\n  if (keyArray1.length !== keyArray2.length) {\n    return false;\n  }\n\n  for (let i = 0; i < keyArray1.length; i++) {\n    if (keyArray1[i] !== keyArray2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import { PblColumnDefinition } from '../models/column';\n\n/**\n * Given an object (item) and a path, returns the value at the path\n */\nexport function deepPathGet(item: any, col: PblColumnDefinition): any {\n  if ( col.path ) {\n    for ( const p of col.path ) {\n      item = item[ p ];\n      if ( !item ) return;\n    }\n  }\n  return item[ col.prop ];\n}\n\n/**\n * Given an object (item) and a path, returns the value at the path\n */\nexport function deepPathSet(item: any, col: PblColumnDefinition, value: any): void {\n  if ( col.path ) {\n    for ( const p of col.path ) {\n      item = item[ p ];\n      if ( !item ) return;\n    }\n  }\n  item[ col.prop ] = value;\n}\n\n\nexport function getValue<T = any>(col: PblColumnDefinition, row: any): T {\n  if (col.transform) {\n    return col.transform(deepPathGet(row, col), row, col);\n  }\n  return deepPathGet(row, col);\n}\n","import { Observable, BehaviorSubject } from 'rxjs';\nimport { PblPaginator, PblPaginatorChangeEvent } from './types';\n\nexport class PblTokenPaginator implements PblPaginator<string> {\n  readonly kind: 'token' = 'token';\n  noCacheMode: boolean;\n\n  get perPage(): number { return this._perPage; }\n  set perPage(value: number) {\n    if (value < 1) {\n      throw new Error(`Invalid total size value ${value}`);\n    }\n\n    if (this._perPage !== value) {\n      const changes: PblPaginatorChangeEvent<string> = { perPage: [this._perPage, this._perPage = value] };\n      this.emit(changes);\n    }\n  }\n\n  get page(): string { return this._page; }\n  set page(value: string) {\n    if (this._page !== value) {\n      const idx = this._tokens.indexOf(value);\n      if (idx === -1) {\n        throw new Error(`Invalid page token ${value}`);\n      }\n      this._cursor = idx;\n      const prev = this._page;\n      this._page = value;\n      this.emit({ page: [prev, value] });\n    }\n  }\n\n  get total(): number { return this._total; }\n  set total(value: number) {\n    const changes: PblPaginatorChangeEvent<string> = { total: [this._total, this._total = value] };\n    this.emit(changes);\n  }\n\n  get totalPages(): number {\n    return this._tokens.length;\n  }\n\n  get range(): [number, number] {\n    if (!this._range) {\n      const start = (this._cursor) * this.perPage;\n      const end = Math.min(this._total, start + this.perPage);\n      this._range = this.noCacheMode\n        ? [ 0, end - start ]\n        : [ start, end ]\n      ;\n    }\n    return this._range;\n  }\n\n  readonly onChange: Observable<PblPaginatorChangeEvent<string>>;\n  protected onChange$: BehaviorSubject<PblPaginatorChangeEvent<string>>;\n  protected queuedChanges: PblPaginatorChangeEvent<string> | undefined;\n  protected _range: [number, number];\n  protected _perPage: number = 10;\n  protected _page: any;\n  protected _total: number = 0;\n  protected _tokens: any[];\n  protected _cursor: number;\n\n  constructor() {\n    this.onChange$ = new BehaviorSubject<PblPaginatorChangeEvent<string>>({page: [null, null]});\n    this.onChange = this.onChange$.asObservable();\n    this.reset();\n  }\n\n  reset(): void {\n    this._tokens = [null];\n    this._cursor = 0;\n    this._total = 0;\n    this.page = null;\n  }\n\n  canMove(value: string): boolean {\n    return this._tokens.indexOf(value) > -1;\n  }\n\n  hasNext(): boolean { return this._cursor < this._tokens.length - 1; }\n  hasPrev(): boolean { return this._cursor > 0; }\n\n  move(value: string): void { this.page = value; }\n  nextPage(): void { this.page = this._tokens[++this._cursor]; }\n  prevPage(): void { this.page = this._tokens[--this._cursor]; }\n\n  addNext(value: any): void {\n    const nextPointer = this._cursor + 1;\n    // if next pointer is not like what we got, set it and delete all after (invalidate them)\n    if (this._tokens[nextPointer] !== value) {\n      this._tokens[nextPointer] = value;\n      this._tokens.splice(nextPointer + 1);\n    }\n  }\n\n  private emit(changes: PblPaginatorChangeEvent<string>): void {\n    this._range = undefined;\n    if (this.queuedChanges) {\n      Object.assign(this.queuedChanges, changes);\n    } else {\n      this.queuedChanges = changes;\n      setTimeout(() => {\n        this.queuedChanges = undefined;\n        this.onChange$.next(changes);\n      });\n    }\n  }\n}\n","import { Observable, BehaviorSubject } from 'rxjs';\nimport { PblPaginator, PblPaginatorChangeEvent } from './types';\n\nexport class PblPagingPaginator implements PblPaginator<number> {\n  readonly kind: 'pageNumber' = 'pageNumber';\n  noCacheMode: boolean;\n\n  get perPage(): number { return this._perPage; }\n  set perPage(value: number) {\n    if (value < 1) {\n      throw new Error(`Invalid total size value ${value}`);\n    }\n\n    if (this._perPage !== value) {\n      const changes: PblPaginatorChangeEvent<number> = { perPage: [this._perPage, this._perPage = value] };\n\n      const prev = this._page;\n      this.calcPages();\n      if (prev !== this._page) {\n        changes.page = [prev, this._page];\n      }\n      this.emit(changes);\n    }\n\n  }\n\n  /**\n   * Get / Set the current page\n   */\n  get page(): number { return this._page; }\n  set page(value: number) {\n    if (value < 0 || value > this._totalPages) {\n      throw new Error(`Invalid page index ${value}`);\n    }\n\n    if (this._page !== value) {\n      const prev = this._page;\n      this._page = value;\n      this.emit({ page: [prev, value] });\n    }\n  }\n\n  get total(): number { return this._total; }\n  set total(value: number) {\n    if (value < 0) {\n      throw new Error(`Invalid total size value ${value}`);\n    }\n\n    if (this._total !== value) {\n      const changes: PblPaginatorChangeEvent<number> = { total: [this._total, this._total = value] };\n\n      const prev = this._page;\n      this.calcPages();\n      if (prev !== this._page) {\n        changes.page = [prev, this._page];\n      }\n\n      this.emit(changes);\n    }\n  }\n\n  /**\n   * The amount of pages in this paginator\n   */\n  get totalPages(): number {\n    return this._totalPages;\n  }\n\n  get range(): [number, number] {\n    if (!this._range) {\n      const start = (this.page - 1) * this.perPage;\n      const end = Math.min(this._total, start + this.perPage);\n      this._range = this.noCacheMode\n        ? [ 0, end - start ]\n        : [ start, end ]\n      ;\n    }\n    return this._range;\n  }\n\n  readonly onChange: Observable<PblPaginatorChangeEvent<number>>;\n  protected onChange$: BehaviorSubject<PblPaginatorChangeEvent<number>>;\n\n  private _total = 0;\n  private _perPage = 10;\n  private _page = 1;\n  private _totalPages = 0;\n  private _range: [number, number];\n\n  private queuedChanges: PblPaginatorChangeEvent<number> | undefined;\n\n  constructor() {\n    this.onChange$ = new BehaviorSubject<PblPaginatorChangeEvent<number>>({page: [null, 1]});\n    this.onChange = this.onChange$.asObservable();\n  }\n\n  canMove(value: number): boolean {\n    const p = this._page + value;\n    return p >= 1 && p <= this.totalPages;\n  }\n  hasNext(): boolean { return this.canMove(1); }\n  hasPrev(): boolean { return this.canMove(-1); }\n\n  move(value: number): void { this.page = this._page + value; }\n  nextPage(): void { this.move(1); }\n  prevPage(): void { this.move(-1); }\n\n\n  reset(): void {\n    this.page = 1;\n  }\n\n  /**\n   * Calculate the number of pages.\n   * returns true if the current page has changed due to calculation. (current page \\> new pages value)\n   */\n  protected calcPages(): void {\n    this._totalPages = Math.ceil(this._total / this.perPage);\n    if (this._totalPages > 0 && this._page > this._totalPages) {\n      this.page = this._totalPages;\n    }\n  }\n\n  private emit(changes: PblPaginatorChangeEvent<number>): void {\n    this._range = undefined;\n    if (this.queuedChanges) {\n      Object.assign(this.queuedChanges, changes);\n    } else {\n      this.queuedChanges = changes;\n      setTimeout(() => {\n        this.queuedChanges = undefined;\n        this.onChange$.next(changes);\n      });\n    }\n  }\n}\n","import { PblColumnDefinition } from '../../../models/column';\nimport { getValue } from '../../../utils/column';\nimport { PblNgridSortDefinition, PblNgridSortInstructions, PblNgridSorter } from './types';\n\n/**\n * Apply sorting on a collection, based on column and sort definitions.\n * If the sort definition doesn't have a sorting function the default sorter is used.\n */\nexport function applySort<T>(column: PblColumnDefinition, sort: PblNgridSortDefinition, data: T[]): T[] {\n  if (!sort || !sort.order) {\n    return data;\n  }\n\n  const sortFn: PblNgridSorter<T> = typeof sort.sortFn === 'function'\n    ? sort.sortFn\n    : typeof column.sort === 'function'\n      ? column.sort\n      : defaultSorter\n  ;\n\n  return column && data\n    ? sortFn(column, sort, data.slice())\n    : data || []\n  ;\n}\n\nfunction defaultSorter<T>(column: PblColumnDefinition, sort: PblNgridSortInstructions, data: T[]): T[] {\n  return data.sort((a, b) => {\n    const directionMultiplier = (sort.order === 'asc' ? 1 : -1);\n    let valueA = getValue(column, a);\n    let valueB = getValue(column, b);\n\n    valueA = isNaN(+valueA) ? valueA : +valueA;\n    valueB = isNaN(+valueB) ? valueB : +valueB;\n\n    if (valueA && valueB) {\n      return (valueA < valueB ? -1 : valueA === valueB ? 0 : 1) * directionMultiplier;\n    }\n\n    return (valueA ? 1 : -1) * directionMultiplier;\n  });\n}\n","import { PblColumnDefinition } from '../../../models/column';\nimport { getValue } from '../../../utils/column';\nimport { DataSourceFilter, DataSourceFilterToken, DataSourcePredicate, DataSourceColumnPredicate } from './types';\n\nexport function createFilter(value: DataSourceFilterToken, columns: PblColumnDefinition[]): DataSourceFilter {\n  return value === undefined\n    ? undefined\n    : {\n      columns,\n      type: typeof value === 'function' ? 'predicate' : 'value',\n      filter: value\n    };\n}\n\nexport function filter<T>(rawData: T[], filter: DataSourceFilter): T[] {\n  if (!filter || !rawData || rawData.length === 0) {\n    return rawData;\n  } else {\n    const cols = filter.columns;\n    if (filter.type === 'predicate') {\n      const value: DataSourcePredicate = <any>filter.filter;\n      return rawData.filter( v => value(v, cols) );\n    } else if ( filter.type === 'value' ) {\n      const value = typeof filter.filter.toLowerCase === 'function' ? filter.filter.toLowerCase() : filter.filter;\n      return rawData.filter( row => cols.some( col => {\n        const predicate = col.filter || genericColumnPredicate;\n        return predicate(col.filter ? filter.filter : value, getValue(col, row), row, col);\n      }));\n    }\n  }\n  return rawData;\n}\n\n/**\n * A generic column predicate that compares the inclusion (text) of the value in the column value.\n */\nexport const genericColumnPredicate: DataSourceColumnPredicate = (filterValue: any, colValue: any, row?: any, col?: PblColumnDefinition): boolean => {\n  return colValue && colValue.toString().toLowerCase().includes(filterValue);\n}\n","import { DataSourceFilter } from '../triggers/filter/types';\nimport { PblNgridDataSourceSortChange } from '../triggers/sort/types';\n\nimport {\n  RefreshDataWrapper,\n  PblDataSourceTriggerChange,\n  PblDataSourceTriggers,\n  PblDataSourceTriggerCache,\n  PblDataSourceTriggerChangedEvent,\n  TriggerChangedEventFor,\n} from './types';\n\nexport const EMPTY: any = Object.freeze({});\n\n/** @internal */\nexport type DEEP_COMPARATORS<K extends keyof PblDataSourceTriggerCache> = {\n  [P in K]?: (prev: PblDataSourceTriggerCache[P], curr: PblDataSourceTriggerCache[P]) => boolean;\n};\n\nexport const DEEP_COMPARATORS: DEEP_COMPARATORS<keyof PblDataSourceTriggerCache> = {\n  filter(prev: DataSourceFilter, curr: DataSourceFilter): boolean {\n    return prev.filter === curr.filter\n      && prev.type == curr.type;\n      // TODO: deep compare columns\n      // && (prev.columns || []).join() === (curr.columns || []).join();\n  },\n  sort(prev: PblNgridDataSourceSortChange, curr: PblNgridDataSourceSortChange): boolean {\n    if (prev.column === curr.column) {\n      const pSort = prev.sort || {};\n      const cSort = curr.sort || {};\n      return pSort.order === cSort.order && pSort.sortFn === cSort.sortFn;\n    }\n  },\n  data(prev: RefreshDataWrapper<any>, curr: RefreshDataWrapper<any>): boolean {\n    return prev === curr;\n  }\n};\n\nexport function fromRefreshDataWrapper<T>(change: PblDataSourceTriggerChange<RefreshDataWrapper<T>>): PblDataSourceTriggerChange<T> {\n  return {\n    changed: change.changed,\n    prev: change.prev.data,\n    curr: change.hasOwnProperty('curr') ? change.curr.data : change.prev.data,\n  };\n}\n\nexport type CoValue<P extends keyof PblDataSourceTriggerCache> = P extends keyof PblDataSourceTriggers ? PblDataSourceTriggers[P] : PblDataSourceTriggerCache[P];\n\nexport function createChangeContainer<P extends keyof PblDataSourceTriggerCache>(type: P,\n                                                                                 value: CoValue<P>,\n                                                                                 cache: PblDataSourceTriggerCache): TriggerChangedEventFor<P> {\n  if (type === 'pagination') {\n    const pagination: PblDataSourceTriggers['pagination'] = (value || {}) as any;\n    const cached = cache['pagination'];\n    // we compare weak because we dont want changes from undefined to null etc...\n    const changedKeys: Array<keyof PblDataSourceTriggers['pagination']> = Object.keys(pagination).filter( k => cached[k] != pagination[k][1] && k !== 'total') as any;\n\n    const event: PblDataSourceTriggerChangedEvent['pagination'] = {\n      changed: changedKeys.length > 0,\n      page: createNotChangedEvent(cached.page),\n      perPage: createNotChangedEvent(cached.perPage),\n    };\n    if (event.changed) {\n      for (const k of changedKeys) {\n        event[k].changed = true;\n        event[k].prev = pagination[k][0];\n        event[k].curr = cached[k] = pagination[k][1];\n      }\n    }\n    return event as TriggerChangedEventFor<P>;\n  } else {\n    value = value || EMPTY;\n    const cachedValue = cache[type];\n    if (value === cachedValue) {\n      return createNotChangedEvent(cachedValue) as any;\n    } else if (value !== EMPTY && cachedValue !== EMPTY) {\n      const fn: (prev: PblDataSourceTriggerCache[P], curr: PblDataSourceTriggerCache[P]) => boolean = DEEP_COMPARATORS[type as any];\n      if (fn(cachedValue, value as any)) {\n        return createNotChangedEvent(cachedValue) as any;\n      }\n    }\n    cache[type] = value as any;\n    return { changed: true, prev: cachedValue, curr: value } as any;\n  }\n}\n\nfunction createNotChangedEvent<T>(value: T): PblDataSourceTriggerChange<T> {\n  return { changed: false, prev: value, curr: value };\n}\n","import { Observable, Subject, combineLatest, of, from, isObservable, asapScheduler } from 'rxjs';\nimport { filter, map, switchMap, tap, debounceTime, observeOn } from 'rxjs/operators';\n\nimport { PblPaginator, PblPaginatorChangeEvent } from '../triggers/pagination/types';\nimport { DataSourceFilter, filter as filteringFn } from '../triggers/filter';\nimport { PblNgridDataSourceSortChange, applySort } from '../triggers/sort';\n\nimport {\n  RefreshDataWrapper,\n  PblDataSourceConfigurableTriggers,\n  PblDataSourceTriggers,\n  PblDataSourceTriggerCache,\n  PblDataSourceTriggerChangedEvent,\n  TriggerChangedEventFor,\n  PblDataSourceAdapterProcessedResult,\n  PblDataSourceTriggerChangeHandler,\n} from './types';\nimport { createChangeContainer, fromRefreshDataWrapper, EMPTY } from './utils';\n\nconst CUSTOM_BEHAVIOR_TRIGGER_KEYS: Array<keyof PblDataSourceConfigurableTriggers> = ['sort', 'filter', 'pagination'];\nconst TRIGGER_KEYS: Array<keyof PblDataSourceTriggers> = [...CUSTOM_BEHAVIOR_TRIGGER_KEYS, 'data'];\nconst SOURCE_CHANGING_TOKEN = {};\n\nconst DEFAULT_INITIAL_CACHE_STATE: PblDataSourceTriggerCache<any> = { filter: EMPTY, sort: EMPTY, pagination: {}, data: EMPTY };\n\n/**\n * An adapter that handles changes\n */\nexport class PblDataSourceAdapter<T = any,\n                                  TData = any,\n                                  TEvent extends PblDataSourceTriggerChangedEvent<TData> = PblDataSourceTriggerChangedEvent<TData>> {\n\n  static hasCustomBehavior(config: Partial<Record<keyof PblDataSourceConfigurableTriggers, boolean>>): boolean {\n    for (const key of CUSTOM_BEHAVIOR_TRIGGER_KEYS) {\n      if (!!config[key]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /** Returns true if the event is triggered from a custom behavior (filter, sort and/or pagination and the configuration allows it) */\n  static isCustomBehaviorEvent(event: PblDataSourceTriggerChangedEvent, config: Partial<Record<keyof PblDataSourceConfigurableTriggers, boolean>>) {\n    for (const key of CUSTOM_BEHAVIOR_TRIGGER_KEYS) {\n      if (!!config[key] && event[key].changed) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  readonly onSourceChanged: Observable<T[]>;\n  readonly onSourceChanging: Observable<void>;\n\n  get inFlight() { return this._inPreFlight || this._inFlight.size > 0; }\n\n  protected paginator?: PblPaginator<any>;\n  private readonly config: Partial<Record<keyof PblDataSourceConfigurableTriggers, boolean>>;\n  private cache: PblDataSourceTriggerCache<TData>;\n  private _onSourceChange$: Subject<any | T[]>;\n  private _refresh$: Subject<RefreshDataWrapper<TData>>;\n  private _lastSource: T[];\n  private _lastSortedSource: T[];\n  private _lastFilteredSource: T[];\n  private _inFlight = new Set<TEvent>();\n  private _inPreFlight = false;\n\n  /**\n   * A Data Source adapter contains flow logic for the datasource and subsequent emissions of datasource instances.\n   * The logic is determined by the combination of the config object and the sourceFactory provided to this adapter, making this adapter actually a container.\n   *\n   * There are 4 triggers that are responsible for datasource emissions, when one of them is triggered it will invoke the `sourceFactory`\n   * returning a new datasource, i.e. a new datasource emission.\n   *\n   * The triggers are: filter, sort, pagination and refresh.\n   *\n   * The refresh trigger does not effect the input sent to the `sourceFactory` function, it is just a mean to initiate a call to create a new\n   * datasource without changing previous flow variables.\n   * It's important to note that calling `sourceFactory` with the same input 2 or more times does not guarantee identical response. For example\n   * calling a remote server that might change it's data between calls.\n   *\n   * All other triggers (3) will change the input sent to the `sourceFactory` function which will use them to return a datasource.\n   *\n   * The input sent to `sourceFactory` is the values that each of the 3 triggers yields, when one trigger changes a new value for it is sent\n   * and the last values of the other 2 triggers is sent with it. i.e. the combination of the last known value for all 3 triggers is sent.\n   *\n   * To enable smart caching and data management `sourceFactory` does not get the raw values of each trigger. `sourceFactory` will get\n   * an event object that contains metadata about each trigger, whether it triggered the change or not as well as old and new values.\n   *\n   * The returned value from `sourceFactory` is then used as the datasource, applying all triggers that are not overridden by the user.\n   * The returned value of `sourceFactory` can be a `DataSourceOf` or `false`.\n   *   - `DataSourceOf` means a valid datasource, either observable/promise of array or an array.\n   *   - `false` means skip, returning false will instruct the adapter to skip execution for this trigger cycle.\n   *\n   * Using a trigger is a binary configuration option, when a trigger is turned on it means that changes to it will be passed to the `sourceFactory`.\n   * When a trigger is turned off it is not listened to and `undefined` will be sent as a value for it to the `sourceFactory`.\n   *\n   * The adapter comes with built in flow logic for all 3 triggers, when a trigger is turned off the adapter will take the result of `sourceFactory` and\n   * apply the default behavior to it.\n   *\n   * For all triggers, the default behavior means client implementation. For filtering, client side filtering. For sorting, client side sorting.\n   * For Pagination, client side pagination.\n   *\n   * You can opt in to one or more triggers and implement your own behavior inside the `sourceFactory`\n   * @param sourceFactory - A function that returns the datasource based on flow instructions.\n   * The instructions are optional, they might or might not exist depending on the configuration of the adapter.\n   * When `sourceFactory` returns false the entire trigger cycle is skipped.\n   * @param config - A configuration object describing how this adapter should behave.\n   */\n  constructor(public sourceFactory: PblDataSourceTriggerChangeHandler<T, TEvent>,\n              config?: false | Partial<Record<keyof PblDataSourceConfigurableTriggers, boolean>>) {\n    this.config = Object.assign({}, config || {});\n\n    this._refresh$ = new Subject<RefreshDataWrapper<TData>>();\n    this._onSourceChange$ = new Subject<T[]>();\n    this.onSourceChanged = this._onSourceChange$.pipe(filter( d => d !== SOURCE_CHANGING_TOKEN ));\n    this.onSourceChanging = this._onSourceChange$.pipe(filter( d => d === SOURCE_CHANGING_TOKEN ));\n  }\n\n  dispose(): void {\n    this._refresh$.complete();\n    this._onSourceChange$.complete();\n  }\n\n  refresh(data?: TData): void {\n    this._refresh$.next({ data });\n  }\n\n  /**\n   * Clears the cache from any existing datasource trigger such as filter, sort etc.\n   * @returns The cached value or null if not there.\n   */\n  clearCache<P extends keyof PblDataSourceTriggerCache>(cacheKey: P): PblDataSourceTriggerCache<TData>[P] | null {\n    if (cacheKey in this.cache) {\n      const prev = this.cache[cacheKey];\n      this.cache[cacheKey] = DEFAULT_INITIAL_CACHE_STATE[cacheKey];\n      return prev;\n    } else {\n      return null;\n    }\n  }\n\n  setPaginator(paginator: PblPaginator<any> | undefined): void {\n    this.paginator = paginator;\n  }\n\n  updateProcessingLogic(filter$: Observable<DataSourceFilter>,\n                        sort$: Observable<PblNgridDataSourceSortChange & { skipUpdate: boolean }>,\n                        pagination$: Observable<PblPaginatorChangeEvent>,\n                        initialState: Partial<PblDataSourceTriggerCache<TData>> = {}): Observable<PblDataSourceAdapterProcessedResult<T, TData>> {\n    let updates = -1;\n    const changedFilter = e => updates === -1 || e.changed;\n    const skipUpdate = (o: PblNgridDataSourceSortChange & { skipUpdate: boolean }) => o.skipUpdate !== true;\n\n    this._lastSource = undefined;\n\n    this.cache = { ...DEFAULT_INITIAL_CACHE_STATE, ...initialState };\n\n    const combine: [\n      Observable<TriggerChangedEventFor<'filter'>>,\n      Observable<TriggerChangedEventFor<'sort'>>,\n      Observable<TriggerChangedEventFor<'pagination'>>,\n      Observable<TriggerChangedEventFor<'data'>>\n    ] = [\n      filter$.pipe( map( value => createChangeContainer('filter', value, this.cache) ), filter(changedFilter) ),\n      sort$.pipe( filter(skipUpdate), map( value => createChangeContainer('sort', value, this.cache) ), filter(changedFilter) ),\n      pagination$.pipe( map( value => createChangeContainer('pagination', value, this.cache) ), filter(changedFilter) ),\n      this._refresh$.pipe( map( value => fromRefreshDataWrapper(createChangeContainer('data', value, this.cache)) ), filter(changedFilter) ),\n    ];\n\n    const hasCustomBehavior = PblDataSourceAdapter.hasCustomBehavior(this.config);\n\n    return combineLatest([combine[0], combine[1], combine[2], combine[3]])\n      .pipe(\n        tap( () => this._inPreFlight = true),\n        // Defer to next loop cycle, until no more incoming.\n        // We use an async schedular here (instead of asapSchedular) because we want to have the largest debounce window without compromising integrity\n        // With an async schedular we know we will run after all micro-tasks but before \"real\" async operations.\n        debounceTime(0),\n        switchMap( ([filterInput, sort, pagination, data ]) => {\n          this._inPreFlight = false;\n\n          updates++; // if first, will be 0 now (starts from -1).\n          const event: TEvent = {\n            id: Math.random() * 10,\n            filter: filterInput,\n            sort,\n            pagination,\n            data,\n            eventSource: data.changed ? 'data' : 'customTrigger',\n            isInitial: updates === 0,\n            updateTotalLength: (totalLength) => {\n              if (this.paginator) {\n                this.paginator.total = totalLength;\n              }\n            }\n          } as TEvent;\n          this.onStartOfEvent(event);\n\n          const runHandle = data.changed\n            || ( hasCustomBehavior && PblDataSourceAdapter.isCustomBehaviorEvent(event, this.config) );\n\n          const response$ = runHandle\n            ? this.runHandle(event as TEvent)\n                .pipe(\n                  map( data => {\n                    if (data !== false) { // if the user didn't return \"false\" from his handler, we infer data was changed!\n                      event.data.changed = true;\n                    }\n                    return { event, data };\n                  }),\n                )\n              : of({ event, data: this._lastSource })\n            ;\n\n          return response$\n            .pipe(\n              map( response => {\n                // If runHandle() returned false, we do not process and return undefined.\n                if (response.data === false) {\n                  return;\n                }\n                const config = this.config;\n                const event = response.event;\n\n                // mark which of the triggers has changes\n                // The logic is based on the user's configuration and the incoming event\n                const withChanges: Partial<Record<keyof PblDataSourceConfigurableTriggers, boolean>> = {};\n                for (const key of CUSTOM_BEHAVIOR_TRIGGER_KEYS) {\n                  if (!config[key] && (event.isInitial || event[key].changed)) {\n                    withChanges[key] = true;\n                  }\n                }\n\n                // When data changed, apply some logic (caching, operational, etc...)\n                if (event.data.changed) {\n                  // cache the data when it has changed.\n                  this._lastSource = response.data;\n\n                  if (config.sort) {\n                    // When the user is sorting (i.e. server sorting), the last sort cached is always the last source we get from the user.\n                    this._lastSortedSource = this._lastSource;\n                  } else {\n                    // When user is NOT sorting (we sort locally) AND the data has changed we need to apply sorting on it\n                    // this might already be true (if sorting was the trigger)...\n                    withChanges.sort = true;\n\n                    // because we sort and then filter, filtering updates are also triggered by sort updated\n                    withChanges.filter = true;\n                  }\n\n                  if (config.filter) {\n                    // When the user is filtering (i.e. server filtering), the last filter cached is always the last source we get from the user.\n                    this._lastFilteredSource = this._lastSource;\n                  } else {\n                    // When user is NOT filtering (we filter locally) AND the data has changed we need to apply filtering on it\n                    // this might already be true (if filtering was the trigger)...\n                    withChanges.filter = true;\n                  }\n                }\n\n                // When user is NOT applying pagination (we paginate locally) AND if we (sort OR filter) locally we also need to paginate locally\n                if (!config.pagination && (withChanges.sort || withChanges.filter)) {\n                  withChanges.pagination = true;\n                }\n\n                // Now, apply: sort --> filter --> pagination     ( ORDER MATTERS!!! )\n\n                if (withChanges.sort) {\n                  this._lastSortedSource = this.applySort(this._lastSource, event.sort.curr || event.sort.prev);\n                }\n\n                let data: T[] = this._lastSortedSource;\n\n                // we check if filter was asked, but also if we have a filter we re-run\n                // Only sorting is cached at this point filtering is always calculated\n                if (withChanges.filter || (!config.filter && event.filter.curr?.filter)) {\n                  data = this._lastFilteredSource = this.applyFilter(data, event.filter.curr || event.filter.prev);\n                  if (!this.config.pagination) {\n                    if (withChanges.filter || !withChanges.pagination) {\n                      this.resetPagination(data.length);\n                    }\n                  }\n                }\n\n                if (withChanges.pagination) {\n                  data = this.applyPagination(data);\n                }\n\n                const clonedEvent: TEvent = { ...event };\n\n                // We use `combineLatest` which caches pervious events, only new events are replaced.\n                // We need to mark everything as NOT CHANGED, so subsequent calls will not have their changed flag set to true.\n                //\n                // We also clone the object so we can pass on the proper values.\n                // We create shallow clones so complex objects (column in sort, user data in data) will not throw on circular.\n                // For pagination we deep clone because it contains primitives and we need to also clone the internal change objects.\n                for (const k of TRIGGER_KEYS) {\n                  clonedEvent[k] = k === 'pagination'\n                    ? JSON.parse(JSON.stringify(event[k]))\n                    : { ...event[k] }\n                  ;\n                  event[k].changed = false;\n                }\n                event.pagination.page.changed = event.pagination.perPage.changed = false;\n\n                return {\n                  event: clonedEvent,\n                  data,\n                  sorted: this._lastSortedSource,\n                  filtered: this._lastFilteredSource,\n                };\n              }),\n              tap( () => this.onEndOfEvent(event) ),\n              // If runHandle() returned false, we will get undefined here, we do not emit these to the grid, nothing to do.\n              filter( r => !!r ),\n            );\n        }),\n      );\n  }\n\n  protected applyFilter(data: T[], dataSourceFilter: DataSourceFilter): T[] {\n    return filteringFn(data, dataSourceFilter);\n  }\n\n  protected applySort(data: T[], event: PblNgridDataSourceSortChange): T[] {\n    return applySort(event.column, event.sort, data);\n  }\n\n  protected applyPagination(data: T[]):  T[] {\n    if (this.paginator) {\n      // Set the rendered rows length to the virtual page size. Fill in the data provided\n      // from the index start until the end index or pagination size, whichever is smaller.\n      const range = this.paginator.range;\n      return data.slice(range[0], range[1]);\n    }\n    return data;\n  }\n\n  protected resetPagination(totalLength: number): void {\n    if (this.paginator) {\n      this.paginator.total = totalLength;\n      this.paginator.page = totalLength > 0 ? 1 : 0;\n    }\n  }\n\n  protected onStartOfEvent(event: TEvent): void {\n    this._inFlight.add(event);\n  }\n\n  protected onEndOfEvent(event: TEvent): void {\n    this._inFlight.delete(event);\n  }\n\n  protected emitOnSourceChanging(event: TEvent) {\n    this._onSourceChange$.next(SOURCE_CHANGING_TOKEN);\n  }\n\n  protected emitOnSourceChanged(event: TEvent, data: T[]) {\n    this._onSourceChange$.next(data);\n  }\n\n  /**\n   * Execute the user-provided function that returns the data collection.\n   * This method wraps each of the triggers with a container providing metadata for the trigger. (Old value, was changed? and new value if changed)\n   * This is where all cache logic is managed (createChangeContainer).\n   *\n   * To build a data collection the information from all triggers is required, even if it was not changed.\n   * When a trigger is fired with a new value the new value replaces the old value for the trigger and all other triggers will keep their old value.\n   * Sending the triggers to the handlers is not enough, we also need to the handlers which of the trigger's have change so they can return\n   * data without doing redundant work.\n   * For example, fetching paginated data from the server requires a call whenever the pages changes but if the filtering is local for the current page\n   * and the filter trigger is fired the handler needs to know that pagination did not change so it will not go and fetch data from the server.\n   *\n   * The handler can return several data structures, observable, promise, array or false.\n   * This method will normalize the response into an observable and notify that the source changed (onSourceChanged).\n   *\n   * When the response is false that handler wants to skip this cycle, this means that onSourceChanged will not emit and\n   * a dead-end observable is returned (observable that will never emit).\n   */\n  private runHandle(event: TEvent): Observable<false | T[]> {\n\n    const result = this.sourceFactory(event);\n    if (result === false) {\n      return of(false);\n    }\n\n    this.emitOnSourceChanging(event);\n\n    const obs: Observable<T[]> = Array.isArray(result)\n      ? of(result)\n      // else ->            observable : promise\n      : (isObservable(result) ? result : from(result))\n          .pipe(map( data => Array.isArray(data) ? data : [] )) // TODO: should we error? warn? notify?\n    ;\n\n    return obs.pipe(\n      observeOn(asapScheduler, 0), // run as a micro-task\n      tap( data => this.emitOnSourceChanged(event, data as T[]) ),\n    );\n  }\n}\n","import { Observable, BehaviorSubject, Subject, of, asapScheduler } from 'rxjs';\nimport { mapTo, skip, observeOn, tap } from 'rxjs/operators';\n\nimport { SelectionModel, CollectionViewer, ListRange } from '@angular/cdk/collections';\nimport { DataSource } from '@angular/cdk/table';\nimport { moveItemInArray } from '@angular/cdk/drag-drop';\n\nimport { unrx } from '../utils/unrx';\nimport { PblNgridEventEmitter } from '../events/events';\nimport { PblColumnDefinition } from '../models/column';\nimport { PblNgridPaginatorKind, PblPaginator, PblPagingPaginator, PblTokenPaginator } from './triggers/pagination'\nimport { DataSourcePredicate, DataSourceFilter, DataSourceFilterToken, createFilter } from './triggers/filter'\nimport { PblNgridSortDefinition, PblNgridDataSourceSortChange } from './triggers/sort'\nimport { PblDataSourceAdapter, PblDataSourceTriggerCache, PblDataSourceTriggerChangedEvent, PblDataSourceAdapterProcessedResult } from './adapter';\n\nconst PROCESSING_SUBSCRIPTION_GROUP = {};\n\nexport interface PblDataSourceOptions {\n  /**\n   * When set to True will not disconnect upon table disconnection, otherwise does.\n   */\n  keepAlive?: boolean;\n  /**\n   * Skip the first trigger emission.\n   * Use this for late binding, usually with a call to refresh() on the data source.\n   *\n   * Note that only the internal trigger call is skipped, a custom calls to refresh will go through\n   */\n  skipInitial?: boolean;\n}\n\nexport class PblDataSource<T = any,\n                           TData = any,\n                           TEvent extends PblDataSourceTriggerChangedEvent<TData> = PblDataSourceTriggerChangedEvent<TData>,\n                           TDataSourceAdapter extends PblDataSourceAdapter<T, TData, TEvent> = PblDataSourceAdapter<T, TData, TEvent>> extends DataSource<T> {\n\n  get pagination(): PblNgridPaginatorKind | false { return this._pagination; }\n  set pagination(value: PblNgridPaginatorKind | false) {\n    if (this._pagination !== value) {\n      this._pagination = value;\n      switch (value) {\n        case 'pageNumber':\n          this._paginator = new PblPagingPaginator();\n          break;\n        case 'token':\n          this._paginator = new PblTokenPaginator();\n          break;\n        default:\n          this._paginator = undefined;\n          break;\n      }\n      if (this._adapter) {\n        this._adapter.setPaginator(this._paginator);\n      }\n    }\n  }\n\n  /**\n   * An observable that emit events when an new incoming source is expected, before calling the trigger handler to get the new source.\n   * This even is usually followed by the `onSourceChanged` event but not always. This is because the trigger handler\n   * can cancel the operation (when it returns false) which means an `onSourceChanged` event will not fire.\n   *\n   * Emissions occur when the trigger handler is invoked and also when the trigger handler returned an observable and the observable emits.\n   *\n   * > Note that a micro-task delays is applied between the `onSourceChanging` subsequent `onSourceChanged` event (when emitted).\n   */\n  readonly onSourceChanging: Observable<void>;\n  /**\n   * An observable that emit events when a new source has been received from the trigger handler but before any processing is applied.\n   * Emissions occur when the trigger handler is invoked and also when the trigger handler returned an observable and the observable emits.\n   *\n   * Examples: Calling `refresh()`, filter / sort / pagination events.\n   *\n   * > Note that the `onSourceChanged` fired before the data is rendered ane before any client-side filter/sort/pagination are applied.\n   * It only indicates that the source data-set is now updated and the grid is about to apply logic on the data-set and then render it.\n   */\n  readonly onSourceChanged: Observable<void>;\n  /**\n   * An observable that emit events when new source has been received from the trigger handler and after it was processed.\n   * Emissions will occur after `onSourceChanged` event has been fired.\n   *\n   * The main difference between `onSourceChanged` and `onRenderDataChanging` is local processing performed in the datasource.\n   * These are usually client-side operations like filter/sort/pagination. If all of these events are handled manually (custom)\n   * in the trigger handler then `onSourceChanged` and `onRenderDataChanging` have no difference.\n   *\n   * > Note that `onRenderDataChanging` and `onRenderedDataChanged` are not closely related as `onRenderedDataChanged` fires at\n   * a much more rapid pace (virtual scroll). The name `onRenderDataChanging` might change in the future.\n   */\n  readonly onRenderDataChanging: Observable<{ event: PblDataSourceTriggerChangedEvent<TData>, data: T[] }>;\n  /**\n   * An observable that emit events when the grid is about to render data.\n   * The rendered data is updated when the source changed or when the grid is in virtual scroll mode and the user is scrolling.\n   *\n   * Each emission reflects a change in the data that the grid is rendering.\n   */\n  readonly onRenderedDataChanged: Observable<void>;\n  readonly onError: Observable<Error>;\n  /**\n   * An event that fires when the connection state to a table has changed.\n   */\n  readonly tableConnectionChange: Observable<boolean>;\n  readonly sortChange: Observable<PblNgridDataSourceSortChange>;\n\n  /**\n   * When set to True will not disconnect upon table disconnection, otherwise unsubscribe from the\n   * datasource when the table disconnects.\n   */\n  readonly keepAlive: boolean;\n  /**\n   * Skip the first trigger emission.\n   * Use this for late binding, usually with a call to refresh() on the data source.\n   *\n   * Note that only the internal trigger call is skipped, a custom calls to refresh will go through\n   */\n  readonly skipInitial: boolean;\n\n  get adapter(): TDataSourceAdapter { return this._adapter; };\n  set adapter(value: TDataSourceAdapter) {\n    if (this._adapter !== value) {\n      this._adapter = value;\n      if (this.pagination) {\n        this._adapter.setPaginator(this._paginator);\n      }\n    }\n  }\n\n  /** Returns the starting index of the rendered data */\n  get renderStart(): number { return this._lastRange ? this._lastRange.start : 0; }\n  get renderLength(): number { return this._renderData$.value.length; }\n  get renderedData(): T[] { return this._renderData$.value || []; }\n  /**\n   * The `source` with sorting applied.\n   * Valid only when sorting is performed client-side.\n   *\n   * To get real-time notifications use `onRenderDataChanging`.\n   * The sorted data is updated just before `onRenderDataChanging` fire.\n   */\n  get sortedData(): T[] { return (this._lastAdapterEvent && this._lastAdapterEvent.sorted) || []; };\n  /**\n   * The `source` with filtering applied.\n   * Valid only when filtering is performed client-side.\n   * If sorting is applied as well, the filtered results are also sorted.\n   *\n   * To get real-time notifications use `onRenderDataChanging`.\n   * The filtered data is updated just before `onRenderDataChanging` fire.\n   */\n  get filteredData(): T[] { return (this._lastAdapterEvent && this._lastAdapterEvent.filtered) || []; };\n\n  get filter(): DataSourceFilter { return this._filter$.value; }\n  get sort(): PblNgridDataSourceSortChange { return this._sort$.value; }\n  get paginator(): PblPaginator<any> { return this._paginator; }\n\n  get length(): number { return this.source.length; }\n  get source(): T[] { return this._source || []; }\n\n  /** Represents selected items on the data source. */\n  get selection(): SelectionModel<T> { return this._selection; }\n\n  protected readonly _selection = new SelectionModel<T>(true, []);\n  protected readonly _tableConnectionChange$ = new Subject<boolean>();\n  protected readonly _onRenderDataChanging = new Subject<{ event: PblDataSourceTriggerChangedEvent<TData>, data: T[] }>();\n  protected readonly _renderData$ = new BehaviorSubject<T[]>([]);\n  protected readonly _filter$: BehaviorSubject<DataSourceFilter> = new BehaviorSubject<DataSourceFilter>(undefined);\n  protected readonly _sort$ = new BehaviorSubject<PblNgridDataSourceSortChange & { skipUpdate: boolean }>({ column: null, sort: null, skipUpdate: false });\n  protected _onError$ = new Subject<Error>();\n\n  protected _paginator: PblPaginator<any>;\n\n  private _pagination: PblNgridPaginatorKind | false;\n  private _adapter: TDataSourceAdapter;\n  private _source: T[];\n  private _disposed: boolean;\n  private _tableConnected: boolean;\n  private _lastRefresh: TData;\n  private _lastRange: ListRange;\n  private _lastAdapterEvent: PblDataSourceAdapterProcessedResult<T, TData>;\n  private _eventEmitter: PblNgridEventEmitter;\n\n  constructor(adapter: TDataSourceAdapter, options?: PblDataSourceOptions) {\n    super();\n    options = options || {};\n\n    this.adapter = adapter;\n\n    this.onSourceChanging = this._adapter.onSourceChanging;\n    // emit source changed event every time adapter gets new data\n    this.onSourceChanged = this.adapter.onSourceChanged\n    .pipe(\n      observeOn(asapScheduler, 0), // emit on the end of the current turn (micro-task) to ensure `onSourceChanged` emission in `_updateProcessingLogic` run's first.\n      mapTo(undefined)\n    );\n    this.onRenderDataChanging = this._onRenderDataChanging.asObservable();\n    this.onRenderedDataChanged = this._renderData$.pipe(skip(1), mapTo(undefined));\n    this.onError = this._onError$.asObservable();\n    this.tableConnectionChange = this._tableConnectionChange$.asObservable();\n\n    this.keepAlive = options.keepAlive || false;\n    this.skipInitial = options.skipInitial || false;\n    this.sortChange = this._sort$.asObservable();\n  }\n\n  /**\n   * A custom trigger that invokes a manual data source change with the provided data value in the `data` property at tht event.\n   */\n  refresh(data?: TData): void {\n    if (this._tableConnected) {\n      this._adapter.refresh(data);\n    } else {\n      this._lastRefresh = data;\n    }\n  }\n\n  /**\n   * Clear the filter definition for the current data set.\n   */\n  setFilter(): void;\n  /**\n   * Set the filter definition for the current data set using a function predicate.\n   *\n   * > Note that when using a custom predicate function all logic is passed to the predicate and the datasource / grid does not handle the filtering process.\n   * This means that any column specific filter, set in the column definitions is ignored, if you want to take these filters into consideration\n   * use the column instance provided to identify and use these filters (the `filter` property in `PblColumn`).\n   */\n  setFilter(value: DataSourcePredicate, columns?: PblColumnDefinition[]): void;\n  /**\n   * Set the filter definition for the current data set using a value to compare with and a list of columns with the values to compare to.\n   *\n   * When a column instance has a specific predicate set (`PblColumn.filter`) then it will be used, otherwise\n   * the `genericColumnPredicate` will be used.\n   */\n  setFilter(value: any, columns: PblColumnDefinition[]): void;\n  setFilter(value?: DataSourceFilterToken, columns?: PblColumnDefinition[]): void {\n    if (value && typeof value !== 'function' && (!columns || columns.length === 0)) {\n      throw new Error('Invalid filter definitions, columns are mandatory when using a single value input.');\n    }\n    this._filter$.next(createFilter(value, columns || []));\n  }\n\n  /**\n   * Refresh the filters result.\n   *\n   * Note that this should only be used when using a predicate function filter and not the simple value filter.\n   * In general the filter is refreshed every time it is set and each time the data is updated so manually refreshing a value filter\n   * has no impact.\n   *\n   * For custom predicate function filters this might be useful.\n   *\n   */\n  syncFilter(): void {\n    const currentFilter = this._adapter.clearCache('filter');\n    if (currentFilter) {\n      this.setFilter(currentFilter.filter, currentFilter.columns);\n    }\n  }\n\n  /**\n   * Clear the current sort definitions.\n   * @param skipUpdate When true will not update the datasource, use this when the data comes sorted and you want to sync the definitions with the current data set.\n   * default to false.\n   */\n  setSort(skipUpdate?: boolean): void;\n  /**\n   * Set the sorting definition for the current data set.\n   * @param column\n   * @param sort\n   * @param skipUpdate When true will not update the datasource, use this when the data comes sorted and you want to sync the definitions with the current data set.\n   * default to false.\n   */\n  setSort(column: PblColumnDefinition, sort: PblNgridSortDefinition, skipUpdate?: boolean): void;\n  setSort(column?: PblColumnDefinition | boolean, sort?: PblNgridSortDefinition, skipUpdate = false): void {\n    if (!column || typeof column === 'boolean') {\n      this._sort$.next({ column: null, sort: {}, skipUpdate: !!column });\n    } else {\n      this._sort$.next({ column, sort, skipUpdate });\n    }\n  }\n\n  dispose(): void {\n    if (!this._disposed) {\n      unrx.kill(this);\n      this._adapter.dispose();\n      this._onRenderDataChanging.complete();\n      this._renderData$.complete();\n      this._filter$.complete();\n      this._sort$.complete();\n      this._onError$.complete();\n      this._disposed = true;\n    }\n  }\n\n  disconnect(cv: CollectionViewer): void {\n    this._lastRefresh = undefined;\n    this._tableConnectionChange$.next(this._tableConnected = false);\n    if (this.keepAlive === false) {\n      this.dispose();\n    }\n  }\n\n  connect(cv: CollectionViewer): Observable<T[]> {\n    if (this._disposed) {\n      throw new Error('PblDataSource is disposed. Use `keepAlive` if you move datasource between tables.');\n    }\n    this._tableConnected = true\n    this._updateProcessingLogic(cv);\n    this._tableConnectionChange$.next(this._tableConnected);\n    return this._renderData$;\n  }\n\n  /**\n   * Move's an item (in the entire source) from one index to the other, pushing the item in the destination one item backwards.\n   *\n   * Note that if the rendered data is a subset of the entire source (i.e virtual scroll & range) the indices are considered\n   * local to the rendered view and are translated to fit the entire source.\n   *\n   * Tp disable this behavior, set the `absolute` parameter to `true`\n   */\n  moveItem(fromIndex: number, toIndex: number, absolute = false): void {\n    if (absolute !== true && this._lastRange) {\n      fromIndex = this._lastRange.start + fromIndex;\n      toIndex = this._lastRange.start + toIndex;\n    }\n\n    if (this.length > 0) {\n      this._eventEmitter.emitEvent({ source: 'ds', kind: 'onBeforeMoveItem', fromIndex, toIndex });\n      moveItemInArray(this._source, fromIndex, toIndex)\n      const data = this._lastRange\n        ? this._source.slice(this._lastRange.start, this._lastRange.end)\n        : this._source\n      ;\n      this._renderData$.next(data);\n    }\n  }\n\n  _attachEmitter(emitter: PblNgridEventEmitter): void {\n    this._eventEmitter = emitter;\n  }\n\n  _detachEmitter(): void {\n    this._eventEmitter = undefined;\n  }\n\n  private _updateProcessingLogic(cv: CollectionViewer): void {\n    const initialState: Partial<PblDataSourceTriggerCache<TData>> = { filter: this.filter,  sort: this.sort };\n    const paginator = this._paginator;\n    if (paginator) {\n      initialState.pagination = { page: paginator.page, perPage: paginator.perPage };\n    }\n    const stream = this._adapter.updateProcessingLogic(\n      this._filter$,\n      this._sort$,\n      paginator ? paginator.onChange : of(undefined),\n      initialState,\n    );\n\n    unrx.kill(this, PROCESSING_SUBSCRIPTION_GROUP)\n\n    const trimToRange = (range: ListRange, data: any[]) => data.slice(range.start, range.end + 1) ;\n\n    /* We use this flag to skip handling `viewChange` events\n       This is on when a call to get data from the adapter (stream) is initiated and set off once the data arrives.\n       In this period, we don't want to update the view, instead, we save the last view range and when the data arrive we trim it to fit the view. */\n    let skipViewChange: boolean;\n    let lastEmittedSource: T[];\n\n    // We listen to view changes (scroll updates, practical only in virtual scroll) and trim the data displayed based on what\n    // the view change instructs us.\n    cv.viewChange\n      .pipe(unrx(this, PROCESSING_SUBSCRIPTION_GROUP))\n      .subscribe( range => {\n        if (this._lastRange?.start === range.start && this._lastRange?.end === range.end) {\n          return;\n        }\n        this._lastRange = range;\n        if (!skipViewChange) {\n          if (range && lastEmittedSource?.length) {\n            this._renderData$.next(trimToRange(this._lastRange, lastEmittedSource));\n          }\n        }\n      });\n\n    // We listen to incoming data update triggers when the data is about to change\n    stream\n      .pipe(\n        unrx(this, PROCESSING_SUBSCRIPTION_GROUP),\n        tap( result => {\n          lastEmittedSource = result.data;\n          skipViewChange = true;\n          this._onRenderDataChanging.next(this._lastAdapterEvent = result);\n        })\n      )\n      .subscribe(\n        ({data}) => {\n          if (this._lastRange && data?.length) {\n            data = trimToRange(this._lastRange, data);\n          }\n          this._renderData$.next(data);\n          skipViewChange = false;\n        },\n        error => { this._onError$.next(error) }\n      );\n\n    this._adapter.onSourceChanged\n      .pipe(unrx(this, PROCESSING_SUBSCRIPTION_GROUP))\n      .subscribe( source => this._source = source || [] );\n\n    if (this._lastRefresh !== undefined) {\n      this._adapter.refresh(this._lastRefresh);\n      this._lastRefresh = undefined;\n    } else if (!this.skipInitial) {\n      // _refresh$ is a Subject, we must emit once so combineLatest will work\n      this.refresh();\n    }\n  }\n}\n\n","import { PblDataSource, PblDataSourceOptions } from '../data-source';\nimport { PblDataSourceAdapter } from '../adapter/adapter';\nimport { PblDataSourceConfigurableTriggers, PblDataSourceTriggerChangedEvent, PblDataSourceTriggerChangeHandler } from '../adapter/types';\n\ninterface AdapterParams<T, TEvent extends PblDataSourceTriggerChangedEvent<any> = PblDataSourceTriggerChangedEvent<any>> {\n  onTrigger?: PblDataSourceTriggerChangeHandler<T, TEvent>;\n  customTriggers?: false | Partial<Record<keyof PblDataSourceConfigurableTriggers, boolean>>;\n}\n\nexport abstract class PblDataSourceBaseFactory<T,\n                                               TData = any,\n                                               TEvent extends PblDataSourceTriggerChangedEvent<TData> = PblDataSourceTriggerChangedEvent<TData>,\n                                               TDataSourceAdapter extends PblDataSourceAdapter<T, TData, TEvent> = PblDataSourceAdapter<T, TData, TEvent>,\n                                               TDataSource extends PblDataSource<T, TData, TEvent> = PblDataSource<T, TData, TEvent>,\n                                              > {\n  protected _adapter: AdapterParams<T, TEvent> = { };\n  protected _dsOptions: PblDataSourceOptions = { };\n  protected _onCreated: (dataSource: TDataSource) => void;\n\n  /**\n   * Set the main trigger handler.\n   * The trigger handler is the core of the datasource, responsible for returning the data collection.\n   *\n   * By default the handler is triggered only when the datasource is required.\n   * This can happened when:\n   *   - The table connected to the datasource.\n   *   - A manual call to `PblDataSource.refresh()` was invoked.\n   *\n   * There are additional triggers (filter/sort/pagination) which occur when their values change, e.g. when\n   * a filter has change or when a page in the paginator was changed.\n   *\n   * By default, these triggers are handled automatically, resulting in a client-side behavior for each of them.\n   * For example, a client side paginator will move to the next page based on an already existing data collection (no need to fetch from the server).\n   *\n   * To handle additional trigger you need to explicitly set them using `setCustomTriggers`.\n   */\n  onTrigger(handler: PblDataSourceTriggerChangeHandler<T, TEvent>): this {\n    this._adapter.onTrigger = handler;\n    return this;\n  }\n\n  /**\n   * A list of triggers that will be handled by the trigger handler.\n   * By default all triggers are handled by the adapter, resulting in a client-side filter/sort/pagination that works out of the box.\n   * To implement server side filtering, sorting and/or pagination specify which should be handled by the on trigger handler.\n   *\n   * You can mix and match, e.g. support only paging from the server, or only paging and sorting, and leave filtering for the client side.\n   */\n  setCustomTriggers(...triggers: Array<keyof PblDataSourceConfigurableTriggers>): this {\n    if (triggers.length === 0) {\n      this._adapter.customTriggers = false;\n    } else {\n      const customTriggers = this._adapter.customTriggers = {};\n      for (const t of triggers) {\n        customTriggers[t] = true;\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Skip the first trigger emission.\n   * Use this for late binding, usually with a call to refresh() on the data source.\n   *\n   * Note that only the internal trigger call is skipped, a custom calls to refresh will go through\n   */\n  skipInitialTrigger(): this {\n    this._dsOptions.skipInitial = true;\n    return this;\n  }\n\n  keepAlive(): this {\n    this._dsOptions.keepAlive = true;\n    return this;\n  }\n\n  onCreated(handler: (dataSource: TDataSource) => void ): this {\n    this._onCreated = handler;\n    return this;\n  }\n\n  create(): TDataSource {\n    const ds = this.createDataSource(this.createAdapter());\n    if (this._onCreated) {\n      this._onCreated(ds);\n    }\n    return ds;\n  }\n\n  protected abstract createAdapter(): TDataSourceAdapter;\n  protected abstract createDataSource(adapter: TDataSourceAdapter): TDataSource;\n}\n\n","import { PblDataSource } from './data-source';\nimport { PblDataSourceAdapter } from './adapter/adapter';\nimport { PblDataSourceBaseFactory } from './base/factory';\n\nexport class PblDataSourceFactory<T, TData = any> extends PblDataSourceBaseFactory<T, TData> {\n  protected createAdapter(): PblDataSourceAdapter<T, TData> {\n    return new PblDataSourceAdapter<T, TData>(this._adapter.onTrigger, this._adapter.customTriggers || false);\n  }\n\n  protected createDataSource(adapter: PblDataSourceAdapter<T, TData>): PblDataSource<T, TData> {\n    return new PblDataSource<T, TData>(adapter, this._dsOptions);\n  }\n}\n\nexport function createDS<T, TData = T[]>(): PblDataSourceFactory<T, TData> {\n  return new PblDataSourceFactory<T, TData>();\n}\n","import { Observable, ReplaySubject } from 'rxjs';\nimport { Inject, Injectable, InjectionToken, Optional } from '@angular/core';\nimport { PblNgridConfig } from './type';\n\nconst DEFAULT_TABLE_CONFIG: PblNgridConfig['table'] = {\n  showHeader: true,\n  showFooter: false,\n  noFiller: false,\n  clearContextOnSourceChanging: false,\n};\n\nexport const PEB_NGRID_CONFIG = new InjectionToken<PblNgridConfig>('PEB_NGRID_CONFIG');\n\n@Injectable({ providedIn: 'root' })\nexport class PblNgridConfigService {\n\n  private config = new Map<keyof PblNgridConfig, any>();\n  private configNotify = new Map<keyof PblNgridConfig, ReplaySubject<any>>();\n\n  constructor(@Optional() @Inject(PEB_NGRID_CONFIG) _config: PblNgridConfig) {\n    if (_config) {\n      for (const key of Object.keys(_config)) {\n        (this.config as any).set(key, _config[key]);\n      }\n    }\n\n    const gridConfig = this.config.get('table') || {};\n    this.config.set('table', {\n      ...DEFAULT_TABLE_CONFIG,\n      ...gridConfig,\n    });\n  }\n\n  has(section: keyof PblNgridConfig): boolean {\n    return this.config.has(section);\n  }\n\n  get<T extends keyof PblNgridConfig>(section: T, fallback?: Partial<PblNgridConfig[T]>): PblNgridConfig[T] | undefined {\n    return this.config.get(section) || fallback;\n  }\n\n  set<T extends keyof PblNgridConfig>(section: T, value: PblNgridConfig[T]): void {\n    const prev = this.get(section);\n    value = Object.assign({}, value);\n    Object.freeze(value);\n    this.config.set(section, value);\n    this.notify(section, value, prev);\n  }\n\n  onUpdate<T extends keyof PblNgridConfig>(section: T): Observable<{ curr: PblNgridConfig[T]; prev: PblNgridConfig[T] | undefined; }> {\n    return this.getGetNotifier(section);\n  }\n\n  private getGetNotifier<T extends keyof PblNgridConfig>(section: T): ReplaySubject<any> {\n    let notifier = this.configNotify.get(section);\n    if (!notifier) {\n      this.configNotify.set(section, notifier = new ReplaySubject<any>(1));\n    }\n    return notifier;\n  }\n\n  private notify<T extends keyof PblNgridConfig>(section: T, curr: PblNgridConfig[T], prev: PblNgridConfig[T]): void {\n    this.getGetNotifier(section).next({ curr, prev });\n  }\n}\n","export function deprecatedWarning(deprecated: string, version: string, alt: string) {\n  console.warn(`\"${deprecated}\" is deprecated and will be removed in version ${version}, use \"${alt}\" instead.`);\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["filter","filteringFn"],"mappings":"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"}