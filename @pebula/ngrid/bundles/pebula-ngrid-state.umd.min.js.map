{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","ng://@pebula/ngrid/state/lib/core/state-visor.ts","ng://@pebula/ngrid/state/lib/core/persistance/local-storage.ts","ng://@pebula/ngrid/state/lib/core/handling/base.ts","ng://@pebula/ngrid/state/lib/core/identification/index.ts","ng://@pebula/ngrid/state/lib/core/utils.ts","ng://@pebula/ngrid/state/lib/core/state.ts","ng://@pebula/ngrid/state/lib/core/built-in-handlers/grid-primitives/index.ts","ng://@pebula/ngrid/state/lib/core/built-in-handlers/column-def/index.ts","ng://@pebula/ngrid/state/lib/core/built-in-handlers/column-def/children.ts","ng://@pebula/ngrid/state/lib/core/built-in-handlers/column-order/index.ts","ng://@pebula/ngrid/state/lib/presets.ts","ng://@pebula/ngrid/state/lib/core/built-in-handlers/_register.ts","ng://@pebula/ngrid/state/lib/state-plugin.ts","ng://@pebula/ngrid/state/lib/ngrid-state.module.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__assign","assign","t","s","i","n","arguments","length","prototype","call","apply","this","__decorate","decorators","target","key","desc","c","r","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__metadata","metadataKey","metadataValue","metadata","__values","o","m","Symbol","iterator","next","value","done","__read","e","ar","push","error","__spread","concat","StateVisor","rootChunkSections","Map","chunkHandlers","get","_instance","registerRootChunkSection","chunkId","config","has","set","registerChunkHandlerDefinition","chunkHandlerDefs","handlersForGroup","getRootSections","from","entries","getDefinitionsForSection","stateVisor","PblNgridLocalStoragePersistAdapter","save","id","state","store","loadGlobalStateStore","__metadata__","updatedAt","Date","toISOString","saveGlobalStateStore","Promise","resolve","err","reject","load","exists","raw","localStorage","getItem","globalStateKey","JSON","parse","setItem","stringify","PblNgridStateChunkHandlerHost","keys","Set","rKeys","handleKeys","_i","keys_1","tslib_1.__values","keys_1_1","k","add","requiredKeys","keys_2","keys_2_1","serialize","fn","sFn","deserialize","dFn","register","size","Error","values","createStateChunkHandler","section","PblNgridIdAttributeIdentResolver","resolveId","ctx","grid","options","identResolver","createChunkSectionContext","def","keyPredicate","stateKeyPredicateFactory","_b","_c","indexOf","normalizeOptions","mode","persistenceAdapter","opt","strategy","getExtApi","controller","PblNgridPluginController","find","extApi","createChunkContext","sectionContext","chunkConfig","source","sourceMatcher","runChildChunk","childChunkId","data","childContext","defs","action","defs_1","defs_1_1","rootPredicate","filter","include","exclude","chunkFilter_1","isArray","hasState","then","U.normalizeOptions","U.resolveId","saveState","context","U.createChunkSectionContext","_d","_e","U.stateKeyPredicateFactory","sectionState","stateMatcher","chunkContext","U.createChunkContext","U.serialize","loadState","defs_2","defs_2_1","U.deserialize","registerGridHandlers","stateValue","runChildChunksForRowMetaColumns","columns","stateColumns","columns_1","columns_1_1","col","runChildChunkForDataMetaRows","columnStore","table","kind","src","dest","active","headerColumnDef","footerColumnDef","runChildChunksForRowDataColumns","colState","pblColumn","cols","tCol","utils","isPblColumn","orgProp","prop","activeColumn","columnApi","findColumn","registerColumnDefHandlers","header","footer","headerGroup","rows","row","metaColumnIds","isGroup","rowDef","rowIndex","source_1","source_1_1","headerGroupSource","headerGroupSource_1","headerGroupSource_1_1","metaRowsState","rowState","activeColStore","metaRowsState_1","metaRowsState_1_1","updateWidth","typeValue","stateTypeDef","name","registerColumnOrderHandlers","columnOrder","visibleColumnIds","slice","lastMove","len","column","anchor","moveColumn","updateGroups","avoidRedraw","userSessionPref","basedOn","resultFilter","dataColumn","basedOn_1","basedOn_1_1","mergeStateChunkKeyFilter","mergeHead","mergeTail","tailValue","tailHead","registerBuiltInHandlers","PLUGIN_KEY","PblNgridStatePlugin","injector","pluginCtrl","_this","_events","Subject","_removePlugin","setPlugin","afterLoadState","pipe","phase","position","mapTo","undefined","afterSaveState","onError","map","events","take","subscribe","event","initialLoadOptions","loadOptions","_load","skip","debounceTime","wait","complete","create","PblNgridStatePlugin_1","saveOptions","catch","destroy","PblNgridComponent","Injector","NgridPlugin","factory","runOnce","UnRx","PblNgridStatePluginDirective","_super","__","constructor","tslib_1.__extends","ngOnDestroy","Directive","args","selector","outputs","Input","PblNgridStatePluginModule","parentModule","configService","created","targetEventsConfig","autoEnable","pluginCtrl_1","subscription_1","evt","hasPlugin","instance","createPlugin","autoEnableOptions","unsubscribe","NgModule","imports","CommonModule","PblNgridModule","declarations","exports","providers","entryComponents","type","Optional","SkipSelf","PblNgridConfigService"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { PblNgridGlobalState, StateChunks, RootStateChunks, PblNgridStateChunkSectionContext } from './models/index';\nimport { PblNgridStateChunkHandlerDefinition } from './handling';\n\nexport let _instance: StateVisor;\n\nexport interface PblNgridStateChunkSectionConfig<T extends keyof RootStateChunks = keyof RootStateChunks> {\n  stateMatcher: (state: PblNgridGlobalState) => RootStateChunks[T]['state'];\n  sourceMatcher: (context: PblNgridStateChunkSectionContext) => RootStateChunks[T]['value'];\n}\n\nexport class StateVisor<T extends keyof StateChunks = keyof StateChunks> {\n\n  private rootChunkSections = new Map<keyof RootStateChunks, PblNgridStateChunkSectionConfig<keyof RootStateChunks>>();\n  private chunkHandlers = new Map<T, PblNgridStateChunkHandlerDefinition<T>[]>();\n\n  private constructor() { }\n\n  static get(): StateVisor { return _instance || (_instance = new StateVisor()); }\n\n  registerRootChunkSection<Z extends keyof RootStateChunks>(chunkId: Z, config: PblNgridStateChunkSectionConfig<Z>): void {\n    if (!this.rootChunkSections.has(chunkId)) {\n      this.rootChunkSections.set(chunkId, config);\n    }\n  }\n\n  registerChunkHandlerDefinition<Z extends T>(chunkHandlerDefs: PblNgridStateChunkHandlerDefinition<Z>): void {\n    const { chunkId } = chunkHandlerDefs;\n    const handlersForGroup = this.chunkHandlers.get(chunkId) || [];\n    handlersForGroup.push(chunkHandlerDefs);\n    this.chunkHandlers.set(chunkId, handlersForGroup);\n  }\n\n  getRootSections(): Array<[keyof RootStateChunks, PblNgridStateChunkSectionConfig<keyof RootStateChunks>]> {\n    return Array.from(this.rootChunkSections.entries());\n  }\n\n  getDefinitionsForSection(chunkId: T): PblNgridStateChunkHandlerDefinition<T>[] {\n    return this.chunkHandlers.get(chunkId) || [];\n  }\n}\n\nexport const stateVisor: StateVisor = StateVisor.get();\n","import { PblNgridGlobalState, PblNgridPersistAdapter } from '../models/index';\n\nexport class PblNgridLocalStoragePersistAdapter implements PblNgridPersistAdapter {\n  private static globalStateKey: string = 'pebulaNgridState';\n\n  save(id: string, state: PblNgridGlobalState): Promise<void> {\n    try {\n      const store = this.loadGlobalStateStore();\n      store[id] = state;\n      if (!state.__metadata__) {\n        state.__metadata__ = {} as any;\n      }\n      state.__metadata__.updatedAt = new Date().toISOString();\n\n      this.saveGlobalStateStore(store);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n\n  load(id: string): Promise<PblNgridGlobalState> {\n    return Promise.resolve(this.loadGlobalStateStore()[id] || {} as any);\n  }\n\n  exists(id: string): Promise<boolean> {\n    const store = this.loadGlobalStateStore() || {};\n    return Promise.resolve(id in store);\n  }\n\n  private loadGlobalStateStore(): { [id: string]: PblNgridGlobalState } {\n    const raw = localStorage.getItem(PblNgridLocalStoragePersistAdapter.globalStateKey);\n    return raw ? JSON.parse(raw) : {};\n  }\n\n  private saveGlobalStateStore(store: { [id: string]: PblNgridGlobalState }): void {\n    localStorage.setItem(PblNgridLocalStoragePersistAdapter.globalStateKey, JSON.stringify(store));\n  }\n}\n","import { StateChunks, PblNgridStateChunkContext } from '../models/index';\nimport { stateVisor } from '../state-visor';\n\nexport class PblNgridStateChunkHandlerHost<T extends keyof StateChunks, Z extends keyof StateChunks[T]['state'] = keyof StateChunks[T]['state']> {\n  private keys = new Set<Z>();\n  private rKeys = new Set<Z>();\n  private sFn: Parameters<PblNgridStateChunkHandlerHost<T, Z>['serialize']>[0];\n  private dFn: Parameters<PblNgridStateChunkHandlerHost<T, Z>['deserialize']>[0];\n\n  constructor(private chunkId: T) { }\n\n  handleKeys(...keys: Array<Z>): this {\n    for (const k of keys) { this.keys.add(k) }\n    return this;\n  }\n\n  /**\n   * Required keys are keys that cannot get excluded.\n   * Either by adding the to the `exclude` option or by omitting them from the `include` option.\n   */\n  requiredKeys(...keys: Array<Z>): this {\n    for (const k of keys) {\n      this.keys.add(k)\n      this.rKeys.add(k);\n    }\n    return this;\n  }\n\n  serialize(fn: (key: Z, ctx: PblNgridStateChunkContext<T>) => StateChunks[T]['state'][Z]): this {\n    this.sFn = fn;\n    return this;\n  }\n\n  deserialize(fn: (key: Z, stateValue: StateChunks[T]['state'][Z],  ctx: PblNgridStateChunkContext<T>) => void): this {\n    this.dFn = fn;\n    return this;\n  }\n\n  register(): void {\n    if (this.keys.size === 0) {\n      throw new Error('Invalid state chunk handler, no keys defined.');\n    }\n    if (!this.sFn) {\n      throw new Error('Invalid state chunk handler, missing serialize handler.');\n    }\n    if (!this.dFn) {\n      throw new Error('Invalid state chunk handler, missing deserialize handler.');\n    }\n\n    stateVisor.registerChunkHandlerDefinition({\n      chunkId: this.chunkId,\n      keys: Array.from(this.keys.values()),\n      rKeys: Array.from(this.rKeys.values()),\n      serialize: this.sFn,\n      deserialize: this.dFn,\n    })\n  }\n}\n\nexport interface PblNgridStateChunkHandlerDefinition<T extends keyof StateChunks, Z extends keyof StateChunks[T]['state'] = keyof StateChunks[T]['state']>{\n  chunkId: T;\n  keys: Array<Z>;\n  rKeys: Array<Z>;\n  serialize: Parameters<PblNgridStateChunkHandlerHost<T, Z>['serialize']>[0];\n  deserialize: Parameters<PblNgridStateChunkHandlerHost<T, Z>['deserialize']>[0];\n}\n\nexport function createStateChunkHandler<T extends keyof StateChunks>(section: T) {\n  return new PblNgridStateChunkHandlerHost(section);\n}\n","import { PblNgridIdentResolver, PblNgridIdentResolverContext } from '../models/index';\n\nexport class PblNgridIdAttributeIdentResolver implements PblNgridIdentResolver {\n  resolveId(ctx: PblNgridIdentResolverContext): string | undefined {\n    return ctx.grid.id;\n  }\n}\n","import { PblNgridComponent, PblNgridPluginController, PblNgridExtensionApi } from '@pebula/ngrid';\nimport {\n  RootStateChunks,\n  StateChunks,\n  PblNgridStateChunkSectionContext,\n  PblNgridStateChunkContext,\n  PblNgridStateOptions,\n  PblNgridStateLoadOptions,\n} from './models/index';\nimport { PblNgridStateChunkHandlerDefinition } from './handling/base';\nimport { stateVisor, PblNgridStateChunkSectionConfig } from './state-visor';\nimport { PblNgridLocalStoragePersistAdapter } from './persistance/local-storage';\nimport { PblNgridIdAttributeIdentResolver } from './identification/index';\n\n/**\n * Pick Partial No Partial\n * Like Pick but some are partial some are not partial\n */\nexport type PickPNP<T, P extends keyof T, NP extends keyof T> = Partial<Pick<T, P>> & Pick<T, NP>\n\nexport function resolveId(grid: PblNgridComponent, options?: PblNgridStateOptions): string {\n  const id = options.identResolver.resolveId(createChunkSectionContext(grid, options));\n  if (!id) {\n    throw new Error('Could not resolve a unique id for an ngrid instance, state is disabled');\n  }\n  return id;\n}\n\nexport function serialize(def: PblNgridStateChunkHandlerDefinition<any>, state: any, ctx: PblNgridStateChunkContext<any>): void {\n  const keyPredicate = stateKeyPredicateFactory(def.chunkId, ctx.options);\n  for (const key of def.keys) {\n    if (!keyPredicate || def.rKeys.indexOf(key) > -1 || keyPredicate(key as string)) {\n      state[key] = def.serialize(key, ctx);\n    }\n  }\n}\n\nexport function deserialize(def: PblNgridStateChunkHandlerDefinition<any>, state: any, ctx: PblNgridStateChunkContext<any>): void {\n  const keyPredicate = stateKeyPredicateFactory(def.chunkId, ctx.options);\n  for (const key of def.keys) {\n    if (key in state) {\n      if (!keyPredicate || def.rKeys.indexOf(key) > -1 || keyPredicate(key as string)) {\n        def.deserialize(key, state[key], ctx);\n      }\n    }\n  }\n}\n\nexport function normalizeOptions(mode: 'save', options?: PblNgridStateOptions): PblNgridStateOptions;\nexport function normalizeOptions(mode: 'load', options?: PblNgridStateLoadOptions): PblNgridStateLoadOptions;\nexport function normalizeOptions(mode: 'save' | 'load', options?: PblNgridStateOptions | PblNgridStateLoadOptions): PblNgridStateOptions | PblNgridStateLoadOptions {\n  if (!options) {\n    options = {} as any;\n  }\n\n  if (!options.persistenceAdapter) {\n    options.persistenceAdapter = new PblNgridLocalStoragePersistAdapter();\n  }\n  if (!options.identResolver) {\n    options.identResolver = new PblNgridIdAttributeIdentResolver();\n  }\n\n  if (mode === 'load') {\n    const opt: PblNgridStateLoadOptions = options;\n    if (!opt.strategy) {\n      opt.strategy = 'overwrite'\n    }\n  }\n\n  return options;\n}\n\nexport function getExtApi(grid: PblNgridComponent): PblNgridExtensionApi {\n  const controller = PblNgridPluginController.find(grid);\n  if (controller) {\n    return controller.extApi;\n  }\n}\n\nexport function createChunkSectionContext(grid: PblNgridComponent,\n                                          options: PblNgridStateOptions | PblNgridStateLoadOptions): PblNgridStateChunkSectionContext {\n  return { grid, extApi: getExtApi(grid), options };\n}\n\nexport function createChunkContext<T extends keyof RootStateChunks>(sectionContext: PblNgridStateChunkSectionContext,\n                                                                   chunkConfig: PblNgridStateChunkSectionConfig<T>,\n                                                                   mode: 'serialize' | 'deserialize'): PblNgridStateChunkContext<T> {\n  return {\n    ...sectionContext,\n    source: chunkConfig.sourceMatcher(sectionContext),\n    runChildChunk<TChild extends keyof StateChunks>(childChunkId: TChild, state: StateChunks[TChild]['state'], source: StateChunks[TChild]['value'], data?: StateChunks[TChild]['data']) {\n      const childContext = { ...sectionContext, source, data };\n      const defs = stateVisor.getDefinitionsForSection(childChunkId);\n\n      const action = mode === 'serialize' ? serialize : deserialize;\n      for (const def of defs) {\n        action(def, state, childContext);\n      }\n    }\n  }\n}\n\nexport function stateKeyPredicateFactory(chunkId: keyof StateChunks, options: PblNgridStateOptions, rootPredicate = false): ((key: string) => boolean) | undefined {\n  // TODO: chunkId ans options include/exclude combination does not change\n  // we need to cache it... e.g. each column def will create a new predicate if we don't cache.\n  const filter = options.include || options.exclude;\n  if (filter) {\n    // -1: Exclude, 1: Include\n    const mode: -1 | 1 = filter === options.include ? 1 : -1;\n    const chunkFilter: boolean | string[] = filter[chunkId];\n    if (typeof chunkFilter === 'boolean') {\n      return mode === 1\n        ? (key: string) => chunkFilter\n        : (key: string) => !chunkFilter\n      ;\n    } else if (Array.isArray(chunkFilter)) {\n      if (rootPredicate) {\n        // root predicate is for RootStateChunks and when set to true\n        // the key itself has no impact on the predicate. If the filter is boolean nothing changes\n        // but if it's an array, the array is ignored and considered as true ignoring the key because a key does not existing when checking the root\n        return k => true;\n      } else {\n        return mode === 1\n          ? (key: string) => chunkFilter.indexOf(key) > -1\n          : (key: string) => chunkFilter.indexOf(key) === -1\n        ;\n      }\n    } else if (mode === 1) {\n      return (key: string) => false\n    }\n  }\n}\n\n","import { PblNgridComponent } from '@pebula/ngrid';\nimport { PblNgridGlobalState, PblNgridStateOptions, PblNgridStateSaveOptions, PblNgridStateLoadOptions } from './models/index';\nimport { stateVisor } from './state-visor';\nimport * as U from './utils';\n\nexport function hasState(grid: PblNgridComponent, options?: PblNgridStateOptions): Promise<boolean> {\n  return Promise.resolve()\n    .then( () => {\n      options = U.normalizeOptions('save', options);\n      const id = U.resolveId(grid, options);\n      return options.persistenceAdapter.exists(id);\n    });\n}\n\nexport function saveState(grid: PblNgridComponent, options?: PblNgridStateSaveOptions): Promise<void> {\n  return Promise.resolve()\n    .then( () => {\n      options = U.normalizeOptions('save', options);\n      const id = U.resolveId(grid, options);\n      const state: PblNgridGlobalState = {} as any;\n      const context = U.createChunkSectionContext(grid, options);\n\n      for (const [chunkId, chunkConfig] of stateVisor.getRootSections()) {\n        const keyPredicate = U.stateKeyPredicateFactory(chunkId, options, true);\n\n        if (!keyPredicate || keyPredicate(chunkId)) {\n          const sectionState = chunkConfig.stateMatcher(state);\n          const chunkContext = U.createChunkContext(context, chunkConfig, 'serialize');\n\n          const defs = stateVisor.getDefinitionsForSection(chunkId);\n          for (const def of defs) {\n            U.serialize(def, sectionState, chunkContext);\n          }\n        }\n      }\n      return options.persistenceAdapter.save(id, state);\n    });\n}\n\nexport function loadState(grid: PblNgridComponent, options?: PblNgridStateLoadOptions): Promise<PblNgridGlobalState> {\n  return Promise.resolve()\n    .then( () => {\n      options = U.normalizeOptions('load', options);\n      const id = U.resolveId(grid, options);\n      return options.persistenceAdapter.load(id)\n        .then( state => {\n          const context = U.createChunkSectionContext(grid, options);\n\n          for (const [chunkId, chunkConfig] of stateVisor.getRootSections()) {\n            const keyPredicate = U.stateKeyPredicateFactory(chunkId, options, true);\n\n            if (!keyPredicate || keyPredicate(chunkId)) {\n              const sectionState = chunkConfig.stateMatcher(state);\n              const chunkContext = U.createChunkContext(context, chunkConfig, 'deserialize');\n\n              const defs = stateVisor.getDefinitionsForSection(chunkId);\n              for (const def of defs) {\n                U.deserialize(def, sectionState, chunkContext);\n              }\n            }\n          }\n          return state;\n        });\n    });\n}\n\n","import { PblNgridComponent } from '@pebula/ngrid';\nimport { PickPNP } from '../../utils';\nimport { createStateChunkHandler } from '../../handling';\nimport { stateVisor } from '../../state-visor';\n\nexport interface PblNgridSurfaceState extends\n  PickPNP <\n    PblNgridComponent,\n    'showHeader' | 'showFooter' | 'focusMode' | 'usePagination' | 'hideColumns' | 'fallbackMinHeight',\n    never\n  > { }\n\nexport function registerGridHandlers() {\n  stateVisor.registerRootChunkSection(\n    'grid',\n    {\n      sourceMatcher: ctx => ctx.grid,\n      stateMatcher: state => state.grid || (state.grid = {} as any)\n    }\n  );\n\n  createStateChunkHandler('grid')\n    .handleKeys('showHeader', 'showFooter', 'focusMode', 'usePagination', 'hideColumns', 'fallbackMinHeight')\n    .serialize( (key, ctx) => ctx.source[key] )\n    .deserialize( (key, stateValue, ctx) => {\n      // We must assert the type starting from 3.5 onwards\n      // See \"Fixes to unsound writes to indexed access types\" in https://devblogs.microsoft.com/typescript/announcing-typescript-3-5\n      ctx.source[key as any] = stateValue;\n    })\n    .register();\n}\n","import { PblNgridColumnDefinitionSet, PblColumnDefinition, PblColumn, utils } from '@pebula/ngrid';\nimport { createStateChunkHandler } from '../../handling';\nimport { stateVisor } from '../../state-visor';\nimport { StateChunks, PblNgridStateChunkContext } from '../../models/index';\nimport { PblNgridMetaRowSetState, PblNgridMetaColumnState, PblNgridGroupColumnState, PblNgridColumnDefinitionSetState } from './model';\nimport { registerColumnDefChildHandlers } from './children';\n\nfunction runChildChunksForRowMetaColumns<TCol, TChild extends keyof StateChunks>(childChunkId: TChild, ctx: PblNgridStateChunkContext<\"columns\">, columns: TCol[]) {\n  const stateColumns = [];\n  for (const col of columns) {\n    const c: StateChunks[TChild]['state'] = {} as any;\n    ctx.runChildChunk(childChunkId, c, col);\n    stateColumns.push(c);\n  }\n  return stateColumns;\n}\n\n/** Runs the process for the `header` and `footer` sections in the `table` section (if they exist) */\nfunction runChildChunkForDataMetaRows(mode: 's' | 'd', state: PblNgridColumnDefinitionSetState['table'], ctx: PblNgridStateChunkContext<\"columns\">) {\n  const { columnStore } = ctx.extApi;\n  const { table } = ctx.source;\n  for (const kind of ['header', 'footer'] as Array<'header' | 'footer'>) {\n    // This is a mapping of the from->to relationship (i.e serializing or deserializing)\n    const src = mode === 's' ? table : state;\n    const dest = src === table ? state : table;\n\n    // we need to have a source\n    if (src[kind]) {\n      const active = kind === 'header' ? columnStore.headerColumnDef : columnStore.footerColumnDef;\n      if (!dest[kind]) { dest[kind] = {}; }\n      ctx.runChildChunk('dataMetaRow', state[kind], table[kind], { kind, active });\n    }\n  }\n}\n\nfunction runChildChunksForRowDataColumns(mode: 's' | 'd', state: PblNgridColumnDefinitionSetState['table'], ctx: PblNgridStateChunkContext<\"columns\">) {\n  const { table } = ctx.source;\n  const src = mode === 's' ? table : state;\n\n  const resolve = src === state\n    ? col => ({ colState: col, pblColumn: table.cols.find( tCol => (utils.isPblColumn(tCol) && tCol.orgProp === col.prop) || (tCol.id === col.id || tCol.prop === col.prop) ) })\n    : col => ({ colState: state.cols[state.cols.push({} as any) - 1] , pblColumn: utils.isPblColumn(col) && col })\n  ;\n\n  if (src.cols && src.cols.length > 0) {\n    for (const col of src.cols) {\n      const { colState, pblColumn } = resolve(col)\n\n      const data = {\n        pblColumn: utils.isPblColumn(pblColumn) && pblColumn,\n        activeColumn: ctx.grid.columnApi.findColumn(col.id || col.prop),\n      }\n      ctx.runChildChunk('dataColumn', colState, pblColumn, data);\n    }\n  }\n}\n\nexport function registerColumnDefHandlers() {\n  stateVisor.registerRootChunkSection(\n    'columns',\n    {\n      sourceMatcher: ctx => ctx.grid.columns,\n      stateMatcher: state => state.columns || (state.columns = {\n        table: {\n          cols: [],\n        },\n        header: [],\n        footer: [],\n        headerGroup: [],\n      })\n    }\n  );\n\n  createStateChunkHandler('columns')\n    .handleKeys('table', 'header', 'headerGroup', 'footer')\n    .serialize( (key, ctx) => {\n      switch (key) {\n        case 'table':\n          const state: PblNgridColumnDefinitionSetState['table'] = { cols: [] };\n          runChildChunkForDataMetaRows('s', state, ctx);\n          runChildChunksForRowDataColumns('s', state, ctx);\n          return state;\n        case 'header':\n        case 'footer':\n          const source = ctx.source[key];\n          if (source && source.length > 0) {\n            const rows = [];\n            for (const row of source) {\n              const active = ctx.extApi.columnStore.metaColumnIds[key].find( r => !r.isGroup && r.rowDef.rowIndex === row.rowIndex );\n              const r: PblNgridMetaRowSetState<PblNgridMetaColumnState> = {} as any;\n              ctx.runChildChunk('metaRow', r, row);\n              r.cols = runChildChunksForRowMetaColumns('metaColumn', ctx, row.cols);\n              rows.push(r);\n            }\n            return rows;\n          }\n          break;\n        case 'headerGroup':\n          const headerGroupSource = ctx.source.headerGroup;\n          if (headerGroupSource && headerGroupSource.length > 0) {\n            const rows = [];\n            for (const row of headerGroupSource) {\n              const active = ctx.extApi.columnStore.metaColumnIds.header.find( r => !r.isGroup && r.rowDef.rowIndex === row.rowIndex );\n              const r: PblNgridMetaRowSetState<PblNgridGroupColumnState> = {} as any;\n              ctx.runChildChunk('metaGroupRow', r, row);\n              r.cols = runChildChunksForRowMetaColumns('metaColumn', ctx, row.cols);\n              rows.push(r);\n            }\n            return rows;\n          }\n          break;\n      }\n    })\n    .deserialize( (key, stateValue, ctx) => {\n      switch (key) {\n        case 'table':\n          const state = stateValue as PblNgridColumnDefinitionSetState['table'];\n          runChildChunkForDataMetaRows('d', state, ctx);\n          runChildChunksForRowDataColumns('d', state, ctx);\n          break;\n        case 'header':\n        case 'footer':\n          const source = ctx.source[key];\n          const metaRowsState = stateValue as PblNgridColumnDefinitionSetState['header'];\n          if (metaRowsState && metaRowsState.length > 0) {\n            for (const rowState of metaRowsState) {\n              const row = source.find( r => r.rowIndex === rowState.rowIndex );\n              if (row) {\n                const active = ctx.extApi.columnStore.metaColumnIds[key].find( r => !r.isGroup && r.rowDef.rowIndex === rowState.rowIndex );\n                ctx.runChildChunk('metaRow', rowState, row);\n                for (const colState of rowState.cols) {\n                  const col = row.cols.find( r => r.id === colState.id);\n                  if (col) {\n                    const activeColStore = ctx.extApi.columnStore.find(colState.id);\n                    const activeCol = activeColStore && activeColStore.header;\n                    ctx.runChildChunk('metaColumn', colState, col);\n                  }\n                }\n              }\n            }\n          }\n          break;\n        case 'headerGroup':\n          break;\n      }\n    })\n    .register();\n\n    registerColumnDefChildHandlers();\n}\n\nexport {\n  PblNgridMetaColumnState,\n  PblNgridGroupColumnState,\n  PblNgridColumnState,\n  PblNgridMetaRowState,\n  PblNgridMetaRowSetState,\n  PblNgridColumnDefinitionSetState,\n} from './model';\n","import { PblColumnTypeDefinition, PblColumn, PblColumnDefinition, PblMetaRowDefinitions } from '@pebula/ngrid';\nimport { createStateChunkHandler } from '../../handling';\n\nexport function registerColumnDefChildHandlers() {\n  /* ====================================================================================================================================================== */\n\n  createStateChunkHandler('dataColumn')\n    .requiredKeys('id', 'prop')\n    .handleKeys(\n      'label', 'css', 'type', 'width', 'minWidth', 'maxWidth',              // PblNgridBaseColumnState (all optional)\n      'headerType', 'footerType', 'sort', 'sortAlias', 'editable', 'pin'    // All Optional\n    )\n    .serialize( (key, ctx) => {\n      const c = ctx.data.activeColumn || ctx.data.pblColumn;\n      if (c) {\n        switch (key) {\n          case 'prop':\n            return c.orgProp;\n          default:\n            break;\n        }\n      }\n\n      const value = c ? c[key] : ctx.source[key];\n\n      switch (key) {\n        case 'sort':\n          if (typeof value === 'boolean') {\n            return value;\n          } else {\n            return;\n          }\n        default:\n          break;\n      }\n\n      return value;\n    })\n    .deserialize( (key, stateValue, ctx) => {\n      const { activeColumn } = ctx.data;\n      if (activeColumn) {\n        switch (key) {\n          case 'width':\n            activeColumn.updateWidth(stateValue as any);\n            break;\n        }\n      }\n      if (ctx.source) {\n        switch (key) {\n          case 'prop':\n            return;\n          case 'type':\n          case 'headerType':\n          case 'footerType':\n            const typeValue = ctx.source[key];\n            const stateTypeDef: PblColumnTypeDefinition = stateValue as any;\n            if (stateTypeDef && typeof stateTypeDef !== 'string' && typeValue && typeof typeValue !== 'string') {\n              typeValue.name = stateTypeDef.name;\n              if (stateTypeDef.data) {\n                typeValue.data = Object.assign(typeValue.data || {}, stateTypeDef.data);\n              }\n              return;\n            }\n            break;\n        }\n\n        // We must assert the type starting from 3.5 onwards\n        // See \"Fixes to unsound writes to indexed access types\" in https://devblogs.microsoft.com/typescript/announcing-typescript-3-5\n        ctx.source[key as keyof (PblColumn | PblColumnDefinition)] = stateValue;\n      }\n\n    })\n    .register();\n\n  /* ====================================================================================================================================================== */\n\n  createStateChunkHandler('dataMetaRow')\n    .handleKeys('rowClassName', 'type')    // All Optional\n    .serialize( (key, ctx) => {\n      const active = ctx.data.active || ctx.source;\n      if (active) {\n        return active[key];\n      }\n    })\n    .deserialize( (key, stateValue, ctx) => {\n      // We must assert the type starting from 3.5 onwards\n      // See \"Fixes to unsound writes to indexed access types\" in https://devblogs.microsoft.com/typescript/announcing-typescript-3-5\n      ctx.source[key] = stateValue as any;\n    })\n    .register();\n\n\n  /* ====================================================================================================================================================== */\n\n  createStateChunkHandler('metaRow')\n    // Note that we are not handling `cols`, this should be called from the parent, as a different child chunk handling process for each column\n    .handleKeys(\n      'rowClassName', 'type',    // All Optional like dataMetaRow\n      'rowIndex',                // Required\n      )\n    .serialize( (key, ctx) => {\n      return ctx.source[key];\n    })\n    .deserialize( (key, stateValue, ctx) => {\n\n    })\n    .register();\n\n  /* ====================================================================================================================================================== */\n\n  createStateChunkHandler('metaGroupRow')\n    // Note that we are not handling `cols`, this should be called from the parent, as a different child chunk handling process for each column\n    .handleKeys(\n      'rowClassName', 'type',    // All Optional like dataMetaRow\n      'rowIndex',                // Required\n      )\n    .serialize( (key, ctx) => {\n      return ctx.source[key];\n    })\n    .deserialize( (key, stateValue, ctx) => {\n\n    })\n    .register();\n\n  /* ====================================================================================================================================================== */\n\n  createStateChunkHandler('metaColumn')\n    .requiredKeys('kind', 'rowIndex')\n    .handleKeys(\n      'id', 'label', 'css', 'type', 'width', 'minWidth', 'maxWidth',        // PblNgridBaseColumnState (all optional)\n    )\n    .serialize( (key, ctx) => {\n      return ctx.source[key];\n    })\n    .deserialize( (key, stateValue, ctx) => {\n\n    })\n    .register();\n\n  /* ====================================================================================================================================================== */\n\n  createStateChunkHandler('metaGroupColumn')\n    .requiredKeys('prop', 'rowIndex', 'span')\n    .handleKeys(\n      'id', 'label', 'css', 'type', 'width', 'minWidth', 'maxWidth',        // PblNgridBaseColumnState (all optional)\n    )\n    .serialize( (key, ctx) => {\n      return ctx.source[key];\n    })\n    .deserialize( (key, stateValue, ctx) => {\n\n    })\n    .register();\n}\n","import { PblColumn } from '@pebula/ngrid';\nimport { createStateChunkHandler } from '../../handling';\nimport { stateVisor } from '../../state-visor';\nimport { PblNgridStateLoadOptions } from '../../models/index';\n\nexport function registerColumnOrderHandlers() {\n  stateVisor.registerRootChunkSection(\n    'columnOrder',\n    {\n      sourceMatcher: ctx => ctx.grid.columnApi,\n      stateMatcher: state => {\n        if (!state.columnOrder) {\n          state.columnOrder = [];\n        }\n        return state;\n      }\n    }\n  );\n\n  createStateChunkHandler('columnOrder')\n    .handleKeys('columnOrder')\n    .serialize( (key, ctx) => ctx.source.visibleColumnIds.slice() )\n    .deserialize( (key, columnOrder, ctx) => {\n      const { extApi, grid } = ctx;\n      let lastMove: [PblColumn, PblColumn];\n\n      const { visibleColumnIds } = grid.columnApi;\n      if (columnOrder && columnOrder.length === visibleColumnIds.length) {\n        for (let i = 0, len = columnOrder.length; i < len; i++) {\n          if (columnOrder[i] !== visibleColumnIds[i]) {\n            const column = grid.columnApi.findColumn(columnOrder[i]);\n            if (!column) {\n              return;\n            }\n            const anchor = grid.columnApi.findColumn(visibleColumnIds[i]);\n            lastMove = [column, anchor];\n            grid.columnApi.moveColumn(column, anchor, true);\n            extApi.columnStore.updateGroups();\n          }\n        }\n      }\n      // With this revert/redo of the last move we just trigger a redraw.\n      if (lastMove) {\n        grid.columnApi.moveColumn(lastMove[1], lastMove[0], true);\n        grid.columnApi.moveColumn(lastMove[0], lastMove[1], (ctx.options as PblNgridStateLoadOptions).avoidRedraw);\n      }\n    })\n    .register();\n  }\n","import { StateChunkKeyFilter } from './core/models/index';\n\n/**\n * Return's the `User Preferences` preset which focuses on saving and restoring state that the user\n * can define and would want to restore between sessions.\n *\n * For example, saving column width's which the user might have changed using the mouse or any other custom way provided to him (through API).\n * Saving the column order, so if the user re-ordered the table the order can be loaded back again...\n */\nexport function userSessionPref(...basedOn: StateChunkKeyFilter[]): StateChunkKeyFilter {\n  const resultFilter: StateChunkKeyFilter = {\n    grid: [\n      'hideColumns',\n      'showFooter',\n      'showHeader',\n    ],\n    columnOrder: true,\n    columns: [ 'table' ],\n    dataColumn: [\n      'width',\n    ]\n  }\n\n  if (basedOn.length > 0) {\n    for (const b of basedOn)\n    mergeStateChunkKeyFilter(resultFilter, b);\n  }\n\n  return resultFilter;\n}\n\n\n/**\n * Merge a head and tail chunk filters so keys from tail will be merged into head if:\n *\n * - The key does not exist in head\n * - The key exist in head but the value of it is an Array and the value of tail is an Array as well.\n *   In such case, both array's are merged into a single unique array.\n */\nfunction mergeStateChunkKeyFilter(mergeHead: StateChunkKeyFilter, mergeTail: StateChunkKeyFilter) {\n  for (const k of Object.keys(mergeTail)) {\n    const tailValue = mergeTail[k];\n    if (k in mergeHead) {\n      const tailHead = mergeHead[k];\n      if (Array.isArray(tailHead) && Array.isArray(tailValue)) {\n        const s = new Set<string>([...tailHead, ...tailValue]);\n        mergeHead[k] = Array.from(s.values());\n      }\n    } else {\n      mergeHead[k] = mergeTail[k];\n    }\n  }\n}\n","import { registerGridHandlers } from './grid-primitives/index';\nimport { registerColumnOrderHandlers } from './column-order/index';\nimport { registerColumnDefHandlers } from './column-def/index';\n\nexport function registerBuiltInHandlers() {\n  registerGridHandlers();\n  registerColumnOrderHandlers();\n  registerColumnDefHandlers();\n}\n","import { Subject, Observable, from } from 'rxjs';\nimport { map, mapTo, filter, take, skip, debounceTime } from 'rxjs/operators';\nimport { Directive, OnDestroy, Injector, Input } from '@angular/core';\n\nimport { UnRx } from '@pebula/utils';\nimport { PblNgridComponent, PblNgridPluginController, NgridPlugin } from '@pebula/ngrid';\nimport { hasState, saveState, loadState, PblNgridStateLoadOptions, PblNgridStateSaveOptions } from './core/index';\nimport { registerBuiltInHandlers } from './core/built-in-handlers/_register';\n\nimport { userSessionPref } from './presets';\n\ndeclare module '@pebula/ngrid/lib/grid/services/config' {\n  interface PblNgridConfig {\n    state?: {\n      /** When set to true will enable the state plugin on all table instances by default. */\n      autoEnable?: boolean;\n      /**\n       * Options to use when auto-loading the plugin\n       */\n      autoEnableOptions?: {\n        loadOptions?: PblNgridStateLoadOptions;\n        saveOptions?: PblNgridStateSaveOptions;\n      }\n    };\n  }\n}\n\ndeclare module '@pebula/ngrid/lib/ext/types' {\n  interface PblNgridPluginExtension {\n    state?: PblNgridStatePlugin;\n  }\n  interface PblNgridPluginExtensionFactories {\n    state: keyof typeof PblNgridStatePlugin;\n  }\n}\n\ninterface InternalStatePluginEvents {\n  phase: 'load' | 'save';\n  position: 'before' | 'after';\n  error?: Error;\n}\n\nexport const PLUGIN_KEY: 'state' = 'state';\n\n@NgridPlugin({ id: PLUGIN_KEY, factory: 'create', runOnce: registerBuiltInHandlers })\n@UnRx()\nexport class PblNgridStatePlugin {\n\n  loadOptions?: PblNgridStateLoadOptions;\n  saveOptions?: PblNgridStateSaveOptions;\n\n  afterLoadState: Observable<void>;\n  afterSaveState: Observable<void>;\n  onError: Observable<{ phase: 'save' | 'load'; error: Error; }>;\n\n  private _removePlugin: (table: PblNgridComponent<any>) => void;\n  private _events = new Subject<InternalStatePluginEvents>();\n\n  constructor(public grid: PblNgridComponent<any>, protected injector: Injector, protected pluginCtrl: PblNgridPluginController) {\n    this._removePlugin = pluginCtrl.setPlugin(PLUGIN_KEY, this);\n\n    this.afterLoadState = this._events.pipe(filter( e => e.phase === 'load' && e.position === 'after'), mapTo(undefined) );\n    this.afterSaveState = this._events.pipe(filter( e => e.phase === 'save' && e.position === 'after'), mapTo(undefined) );\n    this.onError = this._events.pipe(filter( e => !!e.error ), map( e => ({ phase: e.phase, error: e.error })) );\n\n    pluginCtrl.events\n      .pipe(\n        filter( e => e.kind === 'onInvalidateHeaders'),\n        take(1),\n      )\n      .subscribe( event => {\n        const initialLoadOptions = { ...(this.loadOptions || {}), avoidRedraw: true };\n        hasState(grid, initialLoadOptions)\n          .then( value => {\n            if (value) {\n              return this._load(initialLoadOptions);\n            }\n          })\n          .then( () => {\n            pluginCtrl.events\n            .pipe(\n              filter( e => e.kind === 'onResizeRow'),\n              skip(1),\n              debounceTime(500),\n            )\n            .subscribe( event => this.save() );\n          });\n      });\n\n    pluginCtrl.events\n      .subscribe( event => {\n        if (event.kind === 'onDestroy') {\n          event.wait(this.save());\n          this._events.complete();\n        }\n      });\n  }\n\n  static create(table: PblNgridComponent<any>, injector: Injector): PblNgridStatePlugin {\n    const pluginCtrl = PblNgridPluginController.find(table);\n    return new PblNgridStatePlugin(table, injector, pluginCtrl);\n  }\n\n  load(): Promise<void> {\n    return this._load(this.loadOptions);\n  }\n\n  save(): Promise<void> {\n    return saveState(this.grid, this.saveOptions)\n      .then( () => this._events.next({phase: 'save', position: 'after'}) )\n      .catch( error => this._events.next({phase: 'save', position: 'after', error }) );\n  }\n\n  destroy(): void {\n    this._removePlugin(this.grid);\n  }\n\n  private _load(loadOptions: PblNgridStateLoadOptions): Promise<void> {\n    return loadState(this.grid, loadOptions)\n      .then( () => this._events.next({phase: 'load', position: 'after'}) )\n      .catch( error => this._events.next({phase: 'load', position: 'after', error }) );\n  }\n\n}\n\n@Directive({\n  selector: 'pbl-ngrid[persistState]', // tslint:disable-line:directive-selector\n  outputs: ['afterLoadState', 'afterSaveState', 'onError'],\n})\n@UnRx()\nexport class PblNgridStatePluginDirective extends PblNgridStatePlugin implements OnDestroy {\n\n  @Input() loadOptions: PblNgridStateLoadOptions = { include: userSessionPref() };\n  @Input() saveOptions: PblNgridStateSaveOptions = { include: userSessionPref() };\n\n  constructor(grid: PblNgridComponent<any>, injector: Injector, pluginCtrl: PblNgridPluginController) {\n    super(grid, injector, pluginCtrl);\n  }\n\n  ngOnDestroy() {\n    this.destroy();\n  }\n\n}\n","import { NgModule, Optional, SkipSelf } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { PblNgridPluginController, PblNgridModule, PblNgridConfigService } from '@pebula/ngrid';\n\nimport { PLUGIN_KEY, PblNgridStatePluginDirective } from './state-plugin';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    PblNgridModule,\n  ],\n  declarations: [\n    PblNgridStatePluginDirective,\n  ],\n  exports: [\n    PblNgridStatePluginDirective,\n  ],\n  providers: [ ],\n  entryComponents: [ ],\n})\nexport class PblNgridStatePluginModule {\n  constructor(@Optional() @SkipSelf() parentModule: PblNgridStatePluginModule,\n              configService: PblNgridConfigService) {\n\n  if (parentModule) {\n    return;\n  }\n\n  PblNgridPluginController.created\n    .subscribe( event => {\n      const targetEventsConfig = configService.get(PLUGIN_KEY);\n      if (targetEventsConfig && targetEventsConfig.autoEnable === true) {\n        const pluginCtrl = event.controller;\n        let subscription = pluginCtrl.events\n          .subscribe( evt => {\n            if (evt.kind === 'onInit') {\n              if (!pluginCtrl.hasPlugin(PLUGIN_KEY)) {\n                const instance = pluginCtrl.createPlugin(PLUGIN_KEY);\n                if (targetEventsConfig.autoEnableOptions) {\n                  instance.loadOptions = targetEventsConfig.autoEnableOptions.loadOptions;\n                  instance.saveOptions = targetEventsConfig.autoEnableOptions.saveOptions;\n                }\n              }\n              subscription.unsubscribe();\n              subscription = undefined;\n            }\n          });\n      }\n    });\n  }\n}\n"]}