{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","ng://@pebula/ngrid/clipboard/lib/clipboard.service.ts","ng://@pebula/ngrid/clipboard/lib/clipboard.plugin.ts","ng://@pebula/ngrid/clipboard/lib/clipboard.module.ts"],"names":["__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","Clipboard","document","this","_document","prototype","copy","text","pendingCopy","beginCopy","successful","destroy","PendingCopy","Injectable","args","providedIn","Inject","DOCUMENT","textarea","_textarea","createElement","setAttribute","body","appendChild","currentFocus","activeElement","select","execCommand","HTMLElement","focus","_a","removeChild","undefined","IS_OSX","test","navigator","platform","toLowerCase","PblNgridClipboardPlugin","grid","injector","pluginCtrl","config","get","PblNgridConfigService","clipboard","init","create","PblNgridPluginController","find","ngOnDestroy","utils","unrx","kill","_removePlugin","isCopyEvent","event","KeyboardEvent","key","ctrlKey","metaKey","doCopy","_this","cellSeparator","rowSeparator","_b","getSelectedRowData","rows","minIndex","map","row","slice","join","clpCellSep","clpRowSep","columnApi","contextApi","data","Map","Number","MAX_SAFE_INTEGER","selectedCells","_c","point","col","columns","colIndex","renderIndexOf","rowIndex","findRowInCache","rowIdent","dataIndex","dataItem","getValue","ds","source","set","Math","min","entries","Array","from","sort","a","b","e","setPlugin","hasPlugin","createPlugin","getPlugin","keyDown","pipe","filter","subscribe","Directive","selector","exportAs","PblNgridComponent","Injector","Input","PblNgridClipboardPluginModule","parentModule","configService","created","autoEnable","pluginCtrl_1","controller","events","kind","first","NGRID_PLUGIN","ngridPlugin","id","factory","NgModule","imports","CommonModule","PblNgridModule","PblNgridTargetEventsModule","declarations","exports","decorators","type","Optional","SkipSelf"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable} from '@angular/core';\n\n /**\n * A service for copying text to the clipboard.\n *\n * Example usage:\n *\n * clipboard.copy(\"copy this text\");\n */\n@Injectable({providedIn: 'root'})\nexport class Clipboard {\n  private _document: Document;\n\n   constructor(@Inject(DOCUMENT) document: any) {\n    this._document = document;\n  }\n\n   /**\n   * Copies the provided text into the user's clipboard.\n   *\n   * @param text The string to copy.\n   * @returns Whether the operation was successful.\n   */\n  copy(text: string): boolean {\n    const pendingCopy = this.beginCopy(text);\n    const successful = pendingCopy.copy();\n    pendingCopy.destroy();\n\n     return successful;\n  }\n\n   /**\n   * Prepares a string to be copied later. This is useful for large strings\n   * which take too long to successfully render and be copied in the same tick.\n   *\n   * The caller must call `destroy` on the returned `PendingCopy`.\n   *\n   * @param text The string to copy.\n   * @returns the pending copy operation.\n   */\n  beginCopy(text: string): PendingCopy {\n    return new PendingCopy(text, this._document);\n  }\n}\n\n /**\n * A pending copy-to-clipboard operation.\n *\n * The implementation of copying text to the clipboard modifies the DOM and\n * forces a relayout. This relayout can take too long if the string is large,\n * causing the execCommand('copy') to happen too long after the user clicked.\n * This results in the browser refusing to copy. This object lets the\n * relayout happen in a separate tick from copying by providing a copy function\n * that can be called later.\n *\n * Destroy must be called when no longer in use, regardless of whether `copy` is\n * called.\n */\nexport class PendingCopy {\n  private _textarea: HTMLTextAreaElement|undefined;\n\n   constructor(text: string, private readonly _document: Document) {\n    const textarea = this._textarea = this._document.createElement('textarea');\n\n     // Hide the element for display and accessibility.\n    textarea.setAttribute('style', 'opacity: 0;');\n    textarea.setAttribute('aria-hidden', 'true');\n\n     textarea.value = text;\n    this._document.body.appendChild(textarea);\n  }\n\n   /** Finishes copying the text. */\n  copy(): boolean {\n    const textarea = this._textarea;\n    let successful = false;\n\n     try {  // Older browsers could throw if copy is not supported.\n      if (textarea) {\n        const currentFocus = document.activeElement;\n\n         textarea.select();\n        successful = this._document.execCommand('copy');\n\n         if (currentFocus instanceof HTMLElement) {\n          currentFocus.focus();\n        }\n      }\n    } catch {\n      // Discard error.\n      // Initial setting of {@code successful} will represent failure here.\n    }\n\n     return successful;\n  }\n\n   /** Cleans up DOM changes used to perform the copy operation. */\n  destroy() {\n    if (this._textarea) {\n      this._document.body.removeChild(this._textarea);\n      this._textarea = undefined;\n    }\n  }\n}\n","import { filter } from 'rxjs/operators';\nimport { Directive, Injector, OnDestroy, Input } from '@angular/core';\n\n// import { Clipboard } from '@angular/cdk-experimental/clipboard';\n// TODO: remove internal implementation in the next version of cdk-experimental (right after 8.1.3)\nimport { Clipboard } from './clipboard.service';\n\nimport { PblNgridComponent, PblNgridPluginController, PblNgridConfigService, utils } from '@pebula/ngrid';\n\ndeclare module '@pebula/ngrid/lib/ext/types' {\n  interface PblNgridPluginExtension {\n    clipboard?: PblNgridClipboardPlugin;\n  }\n  interface PblNgridPluginExtensionFactories {\n    clipboard: keyof typeof PblNgridClipboardPlugin;\n  }\n}\n\ndeclare module '@pebula/ngrid/lib/grid/services/config' {\n  interface PblNgridConfig {\n    clipboard?: {\n      /** When set to true will enable the clipboard plugin on all grid instances by default. */\n      autoEnable?: boolean;\n      /**\n       * The separator to use when multiple cells are copied\n       * @default \\t\n       */\n      cellSeparator?: string;\n      /**\n       * The separator to use when multiple rows are copied\n       * @default \\n\n       */\n      rowSeparator?: string;\n    };\n  }\n}\n\nconst IS_OSX = /^mac/.test(navigator.platform.toLowerCase())\nconst DEFAULT_CELL_SEP = '\\t';\nconst DEFAULT_ROW_SEP = '\\n';\n\nexport const PLUGIN_KEY: 'clipboard' = 'clipboard';\n\n@Directive({ selector: 'pbl-ngrid[clipboard]', exportAs: 'pblNgridClipboard' })\nexport class PblNgridClipboardPlugin implements OnDestroy {\n\n  static create(grid: PblNgridComponent, injector: Injector): PblNgridClipboardPlugin {\n    const pluginCtrl = PblNgridPluginController.find(grid);\n    return new PblNgridClipboardPlugin(grid, injector, pluginCtrl);\n  }\n\n  /**\n   * The separator to use when multiple cells are copied.\n   * If not set, taken from `PblNgridConfig.clipboard.cellSeparator`\n   * @default \\t\n   */\n  @Input() clpCellSep: string;\n\n  /**\n   * The separator to use when multiple rows are copied\n   * If not set, taken from `PblNgridConfig.clipboard.rowSeparator`\n   * @default \\n\n   */\n  @Input() clpRowSep: string;\n\n  private config: PblNgridConfigService;\n  private clipboard: Clipboard;\n  private _removePlugin: (grid: PblNgridComponent) => void;\n\n  constructor(public grid: PblNgridComponent<any>, protected injector: Injector, protected pluginCtrl: PblNgridPluginController) {\n    this.config = injector.get(PblNgridConfigService)\n    this.clipboard = injector.get(Clipboard);\n    this.init();\n  }\n\n  ngOnDestroy(): void {\n    utils.unrx.kill(this);\n    this._removePlugin(this.grid);\n  }\n\n  protected isCopyEvent(event: Event): boolean {\n    if (event instanceof KeyboardEvent && event.key === 'c') {\n      if ((!IS_OSX && event.ctrlKey) || (IS_OSX && event.metaKey)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  protected doCopy(): void {\n    const { cellSeparator, rowSeparator } = this.config.get('clipboard', {});\n    const { rows, minIndex } = this.getSelectedRowData(this.grid);\n    const createRow = (row: any[]) => row.slice(minIndex).join(this.clpCellSep || cellSeparator || DEFAULT_CELL_SEP);\n    // For each row (collection of items), slice the initial items that are not copied across all selections\n\n    this.clipboard.copy(rows.map(createRow).join(this.clpRowSep || rowSeparator || DEFAULT_ROW_SEP));\n    // TODO: Consider using `beginCopy` to support large copy operations\n  }\n\n  protected getSelectedRowData(grid: PblNgridComponent) {\n    const { columnApi, contextApi } = grid;\n    const data = new Map<any, any[]>();\n\n    // The minIndex represents the first column being copied out of all visible columns (0 being the first visible column).\n    // For every selected cell, the column is tracked and it's index is being set to `minIndex` if it is lower then the current `minIndex` (Math.Min).\n    // We start with the biggest int but right away get a valid column index...\n    // Later on, each row is sliced to remove the items in indices lower then the `minIndex`.\n    //\n    // All of this is to make the paste start without leading cell separators.\n    let minIndex = Number.MAX_SAFE_INTEGER;\n\n    for (const point of contextApi.selectedCells) {\n      const col = columnApi.columns[point.colIndex];\n      if (col) {\n        const colIndex = columnApi.renderIndexOf(col);\n        if (colIndex > -1) {\n          const rowIndex = contextApi.findRowInCache(point.rowIdent).dataIndex;\n          const dataItem = col.getValue(grid.ds.source[rowIndex]);\n          const row = data.get(point.rowIdent) || [];\n          row[colIndex] = dataItem;\n          data.set(point.rowIdent, row);\n          minIndex = Math.min(minIndex, colIndex);\n        }\n      }\n    }\n\n    // contextApi.selectedCells are un-ordered, their order is based on the order in which user have selected cells.\n    // It means that the row's will not paste in the proper order unless we re-order them based on the data index.\n    // This is a very native and simple implementation that will hold most copy actions 1k +-\n    // TODO: Consider a better logic, taking performance into consideration.\n\n    const entries = Array.from(data.entries());\n    entries.sort((a, b) => {\n      const aIndex = contextApi.findRowInCache(a[0]).dataIndex;\n      const bIndex = contextApi.findRowInCache(b[0]).dataIndex;\n      if (aIndex < bIndex) {\n        return -1;\n      } else {\n        return 1;\n      }\n    });\n\n    return {\n      minIndex,\n      rows: entries.map( e => e[1] ),\n    };\n  }\n\n  private init(): void {\n    this._removePlugin = this.pluginCtrl.setPlugin(PLUGIN_KEY, this);\n\n    if (!this.pluginCtrl.hasPlugin('targetEvents')) {\n      this.pluginCtrl.createPlugin('targetEvents');\n    }\n\n    const targetEvents = this.pluginCtrl.getPlugin('targetEvents');\n    targetEvents.keyDown\n      .pipe(\n        filter( event => this.isCopyEvent(event.source) ),\n        utils.unrx(this)\n      )\n      .subscribe( event => this.doCopy() );\n  }\n}\n","import { first, filter } from 'rxjs/operators';\nimport { NgModule, Optional, SkipSelf } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { PblNgridModule, PblNgridConfigService, PblNgridPluginController, ngridPlugin } from '@pebula/ngrid';\nimport { PblNgridTargetEventsModule } from '@pebula/ngrid/target-events';\n\nimport { PLUGIN_KEY, PblNgridClipboardPlugin } from './clipboard.plugin';\n\n@NgModule({\n  imports: [ CommonModule, PblNgridModule, PblNgridTargetEventsModule ],\n  declarations: [ PblNgridClipboardPlugin ],\n  exports: [ PblNgridClipboardPlugin ],\n})\nexport class PblNgridClipboardPluginModule {\n\n  static readonly NGRID_PLUGIN = ngridPlugin({ id: PLUGIN_KEY, factory: 'create' }, PblNgridClipboardPlugin);\n\n  constructor(@Optional() @SkipSelf() parentModule: PblNgridClipboardPluginModule,\n              configService: PblNgridConfigService) {\n\n    if (parentModule) {\n      return;\n    }\n    PblNgridPluginController.created\n      .subscribe( event => {\n        const config = configService.get(PLUGIN_KEY, {});\n        if (config.autoEnable === true) {\n          const pluginCtrl = event.controller;\n          pluginCtrl.events\n            .pipe(\n              filter( e => e.kind === 'onInit' ),\n              first(),\n            )\n            .subscribe( e => {\n              if (!pluginCtrl.hasPlugin(PLUGIN_KEY)) {\n                pluginCtrl.createPlugin(PLUGIN_KEY);\n              }\n            });\n        }\n      });\n  }\n}\n"]}