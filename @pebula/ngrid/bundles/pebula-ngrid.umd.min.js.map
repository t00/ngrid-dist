{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","ng://@pebula/ngrid/lib/table/services/config.ts","ng://@pebula/ngrid/lib/ext/table-plugin.ts","ng://@pebula/ngrid/lib/ext/plugin-control.ts","ng://@pebula/ngrid/lib/ext/table-ext-api.ts","ng://@pebula/ngrid/lib/data-source/filtering.ts","ng://@pebula/ngrid/lib/data-source/sorting.ts","ng://@pebula/ngrid/lib/data-source/data-source-adapter.helpers.ts","ng://@pebula/ngrid/lib/data-source/data-source-adapter.ts","ng://@pebula/ngrid/lib/paginator/paginator.ts","ng://@pebula/ngrid/lib/data-source/data-source.ts","ng://@pebula/ngrid/lib/data-source/factory.ts","ng://@pebula/ngrid/lib/table/utils/helpers.ts","ng://@pebula/ngrid/lib/table/columns/utils.ts","ng://@pebula/ngrid/lib/table/columns/meta-column.ts","ng://@pebula/ngrid/lib/table/columns/group-column.ts","ng://@pebula/ngrid/lib/table/columns/column.ts","ng://@pebula/ngrid/lib/table/columns/factory.ts","ng://@pebula/ngrid/lib/table/col-width-logic/static-column-width.ts","ng://@pebula/ngrid/lib/table/columns/column-store.ts","ng://@pebula/ngrid/lib/table/columns/column-size-info.ts","ng://@pebula/ngrid/lib/table/services/table-registry.service.ts","ng://@pebula/ngrid/lib/table/directives/cell-def.ts","ng://@pebula/ngrid/lib/table/context/cell.ts","ng://@pebula/ngrid/lib/table/context/row.ts","ng://@pebula/ngrid/lib/table/context/utils.ts","ng://@pebula/ngrid/lib/table/context/api.ts","ng://@pebula/ngrid/lib/table/col-width-logic/dynamic-column-width.ts","ng://@pebula/ngrid/lib/table/column-api.ts","ng://@pebula/ngrid/lib/table/meta-rows/meta-row.service.ts","ng://@pebula/ngrid/lib/table/meta-rows/meta-row-container.ts","ng://@pebula/ngrid/lib/table/meta-rows/meta-row.directive.ts","ng://@pebula/ngrid/lib/table/table.deprecate-at-1.0.0.ts","ng://@pebula/ngrid/lib/table/table.component.ts","ng://@pebula/ngrid/lib/table/bind-to-datasource.ts","ng://@pebula/ngrid/lib/table/directives/cell-style-class/styling_differ.ts","ng://@pebula/ngrid/lib/table/directives/row.ts","ng://@pebula/ngrid/lib/table/directives/registry.directives.ts","ng://@pebula/ngrid/lib/table/directives/directives.ts","ng://@pebula/ngrid/lib/table/circular-dep-bridge.ts","ng://@pebula/ngrid/lib/table/directives/column-def.ts","ng://@pebula/ngrid/lib/table/directives/cell.ts","ng://@pebula/ngrid/lib/table/directives/cell-style-class/index.ts","ng://@pebula/ngrid/lib/table/directives/editing.ts","ng://@pebula/ngrid/lib/table/features/virtual-scroll/utils.ts","ng://@pebula/ngrid/lib/table/features/virtual-scroll/meta-row-sticky-scroll.ts","ng://@pebula/ngrid/lib/table/features/virtual-scroll/virtual-scroll-for-of.ts","ng://@pebula/ngrid/lib/table/pbl-cdk-table/pbl-cdk-table.component.ts","ng://@pebula/ngrid/lib/table/features/column-size-observer/column-size-observer.directive.ts","ng://@pebula/ngrid/lib/table/features/virtual-scroll/strategies.ts","ng://@pebula/ngrid/lib/table/features/virtual-scroll/virtual-scroll-viewport.component.ts","ng://@pebula/ngrid/lib/table/features/virtual-scroll/scrolling-plugin.directive.ts","ng://@pebula/ngrid/lib/table.module.ts","ng://@pebula/ngrid/index.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__decorate","decorators","target","key","desc","c","r","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__metadata","metadataKey","metadataValue","metadata","__values","o","m","Symbol","iterator","next","value","done","__read","e","ar","push","error","__spread","concat","DEFAULT_TABLE_CONFIG","showHeader","showFooter","noFiller","PEB_NGRID_CONFIG","InjectionToken","PblNgridConfigService","_config","config","Map","configNotify","_b","tslib_1.__values","keys","_c","set","tableConfig","get","has","section","fallback","prev","freeze","notify","onUpdate","getGetNotifier","notifier","ReplaySubject","curr","Injectable","args","providedIn","Optional","type","Inject","PLUGIN_STORE","TABLE_PLUGIN_CONTEXT","WeakMap","PblNgridPluginContext","_events","Subject","events","asObservable","table","injector","extApi","Error","instance","controller","PblNgridPluginController","emitEvent","event","destroy","complete","delete","context","plugins","grid","created$","find","hasPlugin","name","getPlugin","setPlugin","plugin","_this","tbl","createPlugin","methodName","factory","created","EXT_API_TOKEN","genericColumnPredicate","filterValue","colValue","row","col","toString","toLowerCase","includes","applySort","column","sort","data","order","sortFn","defaultSorter","slice","a","valueA","getValue","valueB","isNaN","EMPTY","DEEP_COMPARATORS","filter","pSort","cSort","createChangeContainer","cache","pagination_1","cached_1","changedKeys","k","event_1","changed","page","createNotChangedEvent","perPage","changedKeys_1","changedKeys_1_1","cachedValue","fn","CUSTOM_BEHAVIOR_TRIGGER_KEYS","TRIGGER_KEYS","SOURCE_CHANGING_TOKEN","DEFAULT_INITIAL_CACHE_STATE","pagination","PblDataSourceAdapter","sourceFactory","initStreams","dispose","_refresh$","_onSourceChange$","refresh","clearCache","cacheKey","setPaginator","paginator","updateProcessingLogic","filter$","sort$","pagination$","initialState","updates","changedFilter","_lastSource","undefined","combine","pipe","map","skipUpdate","change","hasCustomBehavior","some","combineLatest","debounceTime","switchMap","_a","isInitial","updateTotalLength","totalLength","total","runHandle","tap","of","response","withChanges","CUSTOM_BEHAVIOR_TRIGGER_KEYS_1","CUSTOM_BEHAVIOR_TRIGGER_KEYS_1_1","_lastSortedSource","_lastFilteredSource","applyFilter","applyPagination","clonedEvent","TRIGGER_KEYS_1","TRIGGER_KEYS_1_1","JSON","parse","stringify","sorted","filtered","dataSourceFilter","rawData","cols_1","columns","value_1","v","value_2","filteringFn","resetPagination","range","onSourceChanged","onSourceChanging","result","isObservable","isArray","from","observeOn","asapScheduler","PblTokenPaginator","kind","_perPage","_total","onChange$","BehaviorSubject","onChange","reset","changes","emit","_page","idx","_tokens","indexOf","_cursor","_range","start","end","Math","min","noCacheMode","canMove","hasNext","hasPrev","move","nextPage","prevPage","addNext","nextPointer","splice","queuedChanges","setTimeout","PblPagingPaginator","_totalPages","calcPages","totalPages","ceil","PROCESSING_SUBSCRIPTION_GROUP","PblDataSource","adapter","options","_super","_selection","SelectionModel","_tableConnectionChange$","_onRenderDataChanging","_renderData$","_filter$","_sort$","_onError$","_adapter","mapTo","onRenderDataChanging","onRenderedDataChanged","skip","onError","tableConnectionChange","keepAlive","skipInitial","sortChange","tslib_1.__extends","_pagination","_paginator","_lastRange","_lastAdapterEvent","source","_source","_tableConnected","_lastRefresh","setFilter","createFilter","syncFilter","currentFilter","setSort","_disposed","UnRx","kill","disconnect","cv","connect","_updateProcessingLogic","moveItem","fromIndex","toIndex","absolute","moveItemInArray","stream","skipViewChange","lastEmittedSource","trimToRange","viewChange","subscribe","DataSource","PblDataSourceFactory","_dsOptions","onTrigger","handler","setCustomTriggers","triggers","_i","customTriggers","triggers_1","triggers_1_1","skipInitialTrigger","onCreated","_onCreated","ds","createDS","deepPathGet","item","path","prop","resetColumnWidths","rowWidth","tableColumns","metaColumns","_d","defaultColumnWidth","defaultWidth","pct","px","mark","tableMarkForCheck","tableColumns_1","tableColumns_1_1","setDefaultWidth","updateWidth","metaMarkForCheck","metaColumns_1","metaColumns_1_1","_e","header","footer","_f","columnDef","markForCheck","RE_PARSE_STYLE_LENGTH_UNIT","parseStyleWidth","exp","match","exec","Number","initDefinitions","def","forEach","PBL_NGRID_META_COLUMN_MARK","CLONE_PROPERTIES","isPblMetaColumn","PblMetaColumn","CLONE_PROPERTIES_1","CLONE_PROPERTIES_1_1","_width","_parsedWidth","isFixedWidth","configurable","_columnDef","extendProperty","attach","detach","width","fallbackDefault","PBL_NGRID_COLUMN_GROUP_MARK","isPblColumnGroup","PblColumnGroup","getId","id","PblColumnGroupStore","store","_all","group","g","_find","activeColumns","add","findGhosts","values","size","Set","updateAll","remove","clone","placeholder","span","rowIndex","columns_1","columns_1_1","markInGroup","hidden","createSlave","slave","Date","now","slaveOf","template","replace","newColumn","findIndex","PBL_NGRID_COLUMN_MARK","isPblColumn","PblColumn","groupStore","_groups","orgProp","split","pop","label","headerType","footerType","alias","transform","setValue","deepPathSet","markNotInGroup","isInGroup","getGroupOfRow","groupIds","groups","groupIds_1","groupIds_1_1","groupLogic","columnGroups","groupExists","gPrev","gCurr","gNext","prevPH","nextPH","groupWithPlaceholder","checkMaxWidthLock","actualWidth","maxWidth","maxWidthLock","PblColumnFactory","_raw","cols","headerGroup","_defaults","_currentHeaderRow","_currentFooterRow","fromDefinitionSet","defs","f","build","h","rowClassName","hg","buildHeaderGroups","default","rowOptions","shift","processRowOptions","genRowClass","headers","footers","headerGroups","mustHaveProperty","fallbackRowIndex","headerGroupDefs","tableDefs","len","columnGroupDef","take","z","out_i_1","StaticColumnWidthLogic","_agg","minRowWidth","pctCount","pxCount","count","agg","addColumn","parsedWidth","minWidth","PblColumnStore","_groupBy","byId","resetIds","resetColumns","_primary","_hidden","setHidden","_groupStore","addGroupBy","groupBy","removeGroupBy","this_1","gbc","column_1","column_1_1","moveColumn","anchor","columnIds","allColumns","anchorIndex","columnIndex","_allHidden","swapColumns","col1","col2","col1Index","col2Index","getAllHeaderGroup","all","getStaticWidth","invalidate","columnOrDefinitionSet","columnSet","lastSet","headerColumnDef","footerColumnDef","_g","_h","getColumnRecord","pIndex","isDevMode","console","warn","header_1","header_1_1","rowDef","_j","_k","metaCol","_metaRows","headerGroup_1","headerGroup_1_1","_updateGroup","footer_1","footer_1_1","_l","_m","updateGroups","rows","allKeys","tIndex","lastIndexOf","gColumn","isVisible","ghost","id_1","this_2","updateMetaRow","isGroup","collection","columnRecord","clear","metaColumnIds","array","clamp","to","delta","max","ColumnSizeInfo","_column","attachColumn","detachColumn","sizeInfo","updateSize","isDragging","el","rect","getBoundingClientRect","height","style","getComputedStyle","onResize","PblNgridRegistryService","_parent","_multi","_multiDefaults","_singles","changes$","root","getRoot","getSingle","setSingle","emitChanges","op","getMultiDefault","setMultiDefault","getMulti","addMulti","cellDef","removeMulti","multi","forMulti","registry","hasSome","parent","ngOnDestroy","bufferStart","bufferedData","bufferEnd","SkipSelf","PblNgridBaseCellDef","tRef","ngOnInit","PblNgridHeaderCellDefDirective","PblNgridCellDefDirective","PblNgridEditorCellDefDirective","PblNgridFooterCellDefDirective","Directive","selector","inputs","TemplateRef","findCellDef","colDef","searchParent","cellDefs","cellDefs_1","cellDefs_1_1","findCellDefById","MetaCellContext","PblCellContext","_editing","_focused","_selected","rowContext","$implicit","_rowContext","defineProperties","index","columnApi","defaultState","editing","focused","selected","ctx","fromState","getState","state","skipRowUpdate","requiresReset","updateCell","startEdit","editorTpl","_cdkTable","syncRows","stopEdit","viewport","isScrolling","PblRowContext","identity","dataIndex","cdkTable","multiTemplateDataRows","renderIndex","cells","cellContext","cellsCount","firstRender","updateContext","cell","getCells","updateOutOfViewState","contextApi","matches","element","closest","Node","Element","parentNode","findRowRenderedIndex","querySelectorAll","resolveCellReference","cellRef","rowIdent","colIndex","rowEl","obj","isCellContext","viewCache","findColumnAt","rowState","findRowInView","ContextApi","activeSelected","focusChanged$","selectionChanged$","focusChanged","buffer","selectionChanged","vcRef","_rowOutlet","viewContainer","viewPortRect","getViewRect","lastView","unmatchedRefs","keepProcessOutOfView","viewRef","findViewRef","findRowContext","pair","processOutOfView","arr","entries","entry","lastOp","arr_1","arr_1_1","to_1","ident","onRenderRows","activeFocused","focusCell","ref","updateState","selectCells","emitFocusChanged","cellRefs","clearCurrent","toMarkRendered","unselectCells","added","cellRefs_1","cellRefs_1_1","dataPoint","removed","toUnselect","removeAll","rowIdent_1","colIndex_1","removeFromArray","rowState_1","colIndex_2","toUnselect_1","toUnselect_1_1","pblRowContext","getRow","getCell","rowOrCellElement","getDataItem","createCellContext","renderRowIndex","rowIdentity","rowStateOrCellIndex","cellState","currentRowState","currentCellState","renderStart","findRowInCache","offset","getRowIdentity","primary","columnStore","gap","siblingViewRef","siblingRowContext","onDestroy","elementRef","nativeElement","location","isInsideOfView","rootNodes","elRect","bottom","top","outOfView","DynamicColumnWidthLogic","strategy","_minimumRowWidth","widthBreakout","columnInfo","nonContent","content","maxWidthLockChanged","addGroup","columnInfos","sum","columnInfos_1","columnInfos_1_1","DYNAMIC_PADDING_BOX_MODEL_SPACE_STRATEGY","parseInt","paddingLeft","paddingRight","groupCell","ColumnApi","renderColumnIndex","findColumn","renderIndexOf","resizeColumn","resetColumnsWidth","resizeColumns","autoSizeColumn","findColumnAutoSize","autoSizeColumns","visibleColumns","cols_1_1","autoSizeToFit","totalWidth","wLogic","dynamicColumnWidthFactory","columnBehavior","overflowTotalWidth","totalMinWidth","withMinWidth","widthBreakouts","instructions","keepMinWidth","level","withMinWidth_1","withMinWidth_1_1","addition","keepMaxWidth","forceWidthType","skipRedraw","afterColumnPositionChange","queryCellElements","cells_1","cells_1_1","firstElementChild","scrollWidth","PblNgridMetaRowService","fixed","sticky","sync$","hzScroll$","sync","hzScroll","onInit","hzOffset","measureScrollOffset","trackScroll","elementScrolled","auditTime","animationFrameScheduler","newOffset","scrolling","addMetaRow","metaRow","meta","addToSection","removeMetaRow","elRef","PblNgridMetaRowContainerComponent","metaRows","syncRowDefinitions","_innerWidth","innerWidth","_minWidth","_type","init","scrollContainerElement","scrollLeft","container","appendChild","Component","host","[style.width.px]","ElementRef","Input","PblMetaRowDirective","_meta","update","oldMeta","classList","setIdentityProp","identityProp","genericMsg","internalApiFactory","_extApi","pluginControllerFactory","_plugin","metaRowServiceFactory","metaRowService","PblNgridComponent","differs","ngZone","cdr","rowClassUpdateFreq","rowFocus","cellFocus","_fallbackMinHeight","_store","_noCachePaginator","initExtApi","initPlugins","_showHeader","coerceBooleanProperty","_showFooter","_noFiller","__identityProp","setDataSource","_dataSource","setupPaginator","_hideColumns","_hideColumnsDirty","coerceNumberProperty","_viewport","ngDoCheck","_colHideDiffer","hideColumns","diff","attachCustomCellTemplates","attachCustomHeaderCellTemplates","ngAfterContentInit","tableCell","headerFooterCell","changes_1","changes_1_1","setupNoData","ngAfterViewInit","invalidateColumns","div","document","createElement","_element","insertBefore","_footerRowOutlet","listenToResize","view","cellViewIndex","cellElement","focus","ngOnChanges","processColumns","focusMode","isInit","detachViewPort","wait","_p","then","catch","trackBy","columnOrSortAlias","columnInstances","colId","dataSource","bind","renderLength","previousRenderLength","startWith","pairwise","noDataShowing","_noDateEmbeddedVRef","measureRenderedContentSize","minHeight","enabled","rebuildRows","clearHeaderRowDefs","clearFooterRowDefs","detectChanges","resetHeaderRowDefs","resetFooterRowDefs","syncColumnGroupsSize","dynamicWidthLogic","colSizeInfos","groupWidth","minimumRowWidth","run","createView","templateRef","getInternalVcRef","createEmbeddedView","removeView","autoSizeColumnToFit","outerWidth","findInitialRowHeight","rowElement","_vcRefBeforeContent","display","addClass","cls","cls_1","cls_1_1","removeClass","cls_2","cls_2_1","pluginInjector","Injector","providers","provide","ViewContainerRef","useValue","ChangeDetectorRef","hostGrid","resizeObserver","ro$","fromEventPattern","ResizeObserver","observe","unobserve","skipValue","contains","checkViewportSize","u_1","onInit_1","onInit_1_1","onInitFn","unsubscribe","setViewport","force","noData","noDataTemplate","_vcRefBeforeTable","_vcRefAfterContent","usePagination","_paginatorEmbeddedVRef","paginatorTemplate","cellTpl","defaultCellTemplate","_fbTableCell","editorCell","defaultHeaderCellTemplate","_fbHeaderCell","defaultFooterCellTemplate","_fbFooterCell","columns_2","columns_2_1","headerCellDef","footerCellDef","headerCellTpl","footerCellTpl","_headerRowDefs","toArray","addHeaderRowDef","_footerRowDefs","addFooterRowDef","useFactory","deps","forwardRef","PblNgridComponent_1","changeDetection","ChangeDetectionStrategy","OnPush","encapsulation","ViewEncapsulation","None","IterableDiffers","NgZone","Attribute","ViewChild","read","static","CdkRowDef","ViewChildren","CdkHeaderRowDef","CdkFooterRowDef","String","StylingDiffer","_name","_options","_lastSetValue","_lastSetValueType","_lastSetValueIdentityChange","hasValueChanged","valueHasChanged","finalValue","trimValues","parseOutUnits","allowSubKeys","tokens","token","reduce","str","oldKeys","newKeys","arrayEqualsArray","mapHasChanged","bulidMapFromValues","errorPrefix","trim","setMapValues","assertValidValue","innerKeys","j","setIndividualMapValue","unit","substr","substring","normalizeStyleKeyAndValue","PBL_NGRID_ROW_TEMPLATE","CDK_ROW_TEMPLATE","PblNgridRowComponent","updateRow","rowRenderIndex","getRend","setAttribute","rowClassUpdate","updateHostClass","_classDiffer","_lastClass","newValue","lastClass","class","role","CdkRow","useExisting","exportAs","PblNgridSingleTemplateRegistry","PblNgridMultiTemplateRegistry","PblNgridDataHeaderExtensionContext","createDateHeaderCtx","headerCell","PblNgridHeaderExtensionRefDirective","_id","PblNgridPaginatorRefDirective","PblNgridNoDataRefDirective","PblNgridOuterSectionDirective","position","COLUMN_NAME_CSS_PREFIX","COLUMN_EDITABLE_CELL_CLASS","uniqueColumnCss","cssClassFriendlyName","PblNgridColumnDef","_differs","_isDirty","_markedForCheck","_colDiffer","_widths","_netWidth","minWidthPx","parsed","applyWidth","widths","endsWith","boxSizing","cssId","query","filter_1","filter_1_1","join","prevNetWidth","updatePin","pin","stickyEnd","updateStickyColumnStyles","CdkColumnDef","KeyValueDiffers","HEADER_GROUP_CSS","HEADER_GROUP_PLACE_HOLDER_CSS","initCellElement","css","css_1","css_1_1","lastDataHeaderExtensions","PblNgridHeaderCellComponent","zone","cellCtx","context_1","onStable","first","runHeaderExtensions","destroyed","isDirty","extensions","dataHeaderExtensions_1","values_1","values_1_1","extensions_1","extensions_1_1","ext","shouldRender","PblNgridMultiComponentRegistry","createComponent","getFactory","projectedContent","projectContent","cmpRef","CdkHeaderCell","PblNgridCellDirective","editable","_rowCtx","CdkCell","PblNgridFooterCellDirective","CdkFooterCell","PblNgridCellStyling","_lastStyle","_styleDiffer","parentElement","updateParent","lastStyle","PblNgridCellEditAutoFocusDirective","doFocus","runOutsideAngular","Promise","resolve","_destroyed","splitRange","headerLen","dataLen","updateStickyRows","stickyState","coeff","reverse","getSize","orientation","node","MetaRowStickyScroll","viewPortEl","runningHeader","runningFooter","canMoveHeader","canMoveFooter","movedFooterRows","movedHeaderRows","isRunning","viewPortElRect","moveHeader","moveFooter","restore","renderedContentOffset","restoreHeader","restoreFooter","stickyAndRendered","headerRows","mostTopRect","rendered","calc","stickyRowHeaderContainer","cloneAndMoveRow","footerRows","stickyRowFooterContainer","restoreRows","stickyRowContainer","restoreRef","innerRowContainer","stickyAndRendered_1","stickyAndRendered_1_1","cloneNode","restoreRef_1","restoreRef_1_1","zIndex","removeChild","FIXED_HEADER_MODE","sortByIndex","PblVirtualScrollForOf","takeUntil","detachView","attachView","scrollPosition_1","offset_1","viewPort_1","metaRowStickyScroll_1","wheelListen_1","addEventListener","handler_1","wheelUnListen_1","removeEventListener","updateScrollPosition_1","scrollHeight","getViewportSize","deltaY","scrollEnd$","restore_1","removedEvent_1","wheelMode","wheelMode_1","scrollFrameRate","frameRate","lastWheel$","fromEvent","race","timer","scrollToOffset","preventDefault","stopPropagation","offsetChange","vcRefs","_headerRowOutlet","measureRangeSize","renderedRanges","_renderedRanges","ranges","stickyStates","renderedRange","renderedStartIndex","totalSize","renderedRangeStream","headerLength","footerLength","htmlRows","renderedRows","stickyRows","dataStream","onSourceLengthChange","PblCdkTableComponent","_changeDetectorRef","_elementRef","_dir","_document","platform","_cachedRowDefs","_lastSticky","_lastStickyEnd","onRenderRows$","_isStickyPending","_updateStickyColumnStyles","virtualScrollDestroy","cssClassName","headerRowDef","removeHeaderRowDef","footerRowDef","removeFooterRowDef","attachViewPort","forOf","updateRowDefCache","_cacheRowDefs","renderRows","gridInstance","rowType","useSpecificRows","pblForceRenderDataRows","_forceRenderDataRows","ex","CDK_TABLE_TEMPLATE","Directionality","DOCUMENT","Platform","CdkTable","PBL_NGRID_MAP","PblNgridGroupHeaderSizeController","ro","requestAnimationFrame","resized","entries_1","entries_1_1","resized_1","resized_1_1","PblColumnSizeObserver","noop","nv","nv1","NoVirtualScrollStrategy","onContentScrolled","onDataLengthChanged","onContentRendered","onRenderedOffsetChanged","scrollToIndex","TableItemSizeAverager","addSample","rowInfo","rowLength","setRowInfo","ItemSizeAverager","PblNgridFixedSizeVirtualScrollStrategy","itemSize","minBufferPx","maxBufferPx","_ngridViewport","getRenderedRange","rangeLength","dataLength","getDataLength","setRenderedRange","setRenderedContentOffset","FixedSizeVirtualScrollStrategy","TableAutoSizeVirtualScrollStrategy","averager","AutoSizeVirtualScrollStrategy","TYPES","PblCdkVirtualScrollDirective","_minBufferPx","_maxBufferPx","types","hasAttribute","_vScrollAuto","_vScrollFixed","_wheelMode","vScrollFixed","_scrollStrategy","updateItemAndBufferSize","updateBufferSize","scrolledIndexChange","behavior","VIRTUAL_SCROLL_STRATEGY","PblCdkVirtualScrollViewportComponent","pblScrollStrategy","dir","scrollDispatcher","pluginCtrl","scrollStrategy","virtualScrollConfig","defaultStrategy","resolveScrollStrategy","EventEmitter","ngeRenderedContentSize","_totalContentWidth","_totalContentHeight","_totalContentSizeTransform","offsetChange$","_isScrolling","wheelModeDefault","querySelector","CdkScrollable","initScrollWatcher","setTotalContentSize","updateFiller","offsetHeight","outerHeight","innerHeight","pblFillerHeight","isCDPending","lastOffset","measure_1","performance","raf_1","time","[class.cdk-virtual-scroll-disabled]","[class.cdk-virtual-scroll-orientation-horizontal]","[class.cdk-virtual-scroll-orientation-vertical]","ScrollDispatcher","Output","CdkVirtualScrollViewport","PblNgridScrolling","subscription","COMMON_TABLE_TEMPLATE_INIT","provideCommon","components","ANALYZE_FOR_ENTRY_COMPONENTS","PblNgridModule","ngRef","components_1","components_1_1","multi_1","multi_1_1","loadCommonTemplates","component","forRoot","ngModule","withCommon","componentFactoryResolver","resolveComponentFactory","changeDetectorRef","err","NgModule","imports","CommonModule","ScrollingModule","ScrollingModuleExp","CdkTableModule","declarations","exports","NgModuleRef","Self","utils","runOnce"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { Observable, ReplaySubject } from 'rxjs';\n\nimport { Inject, Injectable, InjectionToken, Optional } from '@angular/core';\n\nexport interface PblNgridConfig {\n  table?: {\n    showHeader?: boolean;\n    showFooter?: boolean;\n    noFiller?: boolean;\n  }\n}\n\nconst DEFAULT_TABLE_CONFIG: PblNgridConfig['table'] = {\n  showHeader: true,\n  showFooter: false,\n  noFiller: false,\n};\n\nexport const PEB_NGRID_CONFIG = new InjectionToken<PblNgridConfig>('PEB_NGRID_CONFIG');\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PblNgridConfigService {\n\n  private config = new Map<keyof PblNgridConfig, any>();\n  private configNotify = new Map<keyof PblNgridConfig, ReplaySubject<any>>();\n\n  constructor(@Optional() @Inject(PEB_NGRID_CONFIG) _config: PblNgridConfig) {\n    if (_config) {\n      for (const key of Object.keys(_config)) {\n        (this.config as any).set(key, _config[key]);\n      }\n    }\n\n    const tableConfig = this.config.get('table') || {};\n    this.config.set('table', {\n      ...DEFAULT_TABLE_CONFIG,\n      ...tableConfig,\n    });\n  }\n\n  has(section: keyof PblNgridConfig): boolean {\n    return this.config.has(section);\n  }\n\n  get<T extends keyof PblNgridConfig>(section: T, fallback?: Partial<PblNgridConfig[T]>): PblNgridConfig[T] | undefined {\n    return this.config.get(section) || fallback;\n  }\n\n  set<T extends keyof PblNgridConfig>(section: T, value: PblNgridConfig[T]): void {\n    const prev = this.get(section);\n    value = Object.assign({}, value);\n    Object.freeze(value);\n    this.config.set(section, value);\n    this.notify(section, value, prev);\n  }\n\n  onUpdate<T extends keyof PblNgridConfig>(section: T): Observable<{ curr: PblNgridConfig[T]; prev: PblNgridConfig[T] | undefined; }> {\n    return this.getGetNotifier(section);\n  }\n\n  private getGetNotifier<T extends keyof PblNgridConfig>(section: T): ReplaySubject<any> {\n    let notifier = this.configNotify.get(section);\n    if (!notifier) {\n      this.configNotify.set(section, notifier = new ReplaySubject<any>(1));\n    }\n    return notifier;\n  }\n\n  private notify<T extends keyof PblNgridConfig>(section: T, curr: PblNgridConfig[T], prev: PblNgridConfig[T]): void {\n    this.getGetNotifier(section).next({ curr, prev });\n  }\n}\n","import { PblNgridPluginExtension, PblNgridPluginExtensionFactories } from './types';\n\n/** @internal */\nexport const PLUGIN_STORE = new Map<keyof PblNgridPluginExtension, TablePluginMetadata & { target: any }>();\n\nexport interface TablePluginMetadata<P extends keyof PblNgridPluginExtension = keyof PblNgridPluginExtension> {\n  id: P;\n  factory?: P extends keyof PblNgridPluginExtensionFactories\n    ? PblNgridPluginExtensionFactories[P]\n    : never\n  ;\n  runOnce?: () => void;\n}\n\nexport function TablePlugin(metadata: TablePluginMetadata) {\n  if (metadata.runOnce) {\n    metadata.runOnce();\n  }\n  return target => {\n    PLUGIN_STORE.set(metadata.id, { ...metadata, target });\n  }\n}\n","import { Observable, Subject } from 'rxjs';\nimport { Injector } from '@angular/core';\n\nimport { PblNgridComponent } from '../table/table.component';\nimport {\n  PblNgridPlugin,\n  PblNgridPluginExtension,\n  PblNgridPluginExtensionFactories,\n  PblNgridEvents,\n} from './types';\nimport { PblNgridExtensionApi } from './table-ext-api';\nimport { PLUGIN_STORE } from './table-plugin';\n\nconst TABLE_PLUGIN_CONTEXT = new WeakMap<PblNgridComponent<any>, PblNgridPluginContext>();\n\n/** @internal */\nexport class PblNgridPluginContext<T = any> {\n\n  // workaround, we need a parameter-less constructor since @ngtools/webpack@8.0.4\n  // Non @Injectable classes are now getting addded with hard reference to the ctor params which at the class creation point are undefined\n  // forwardRef() will not help since it's not inject by angular, we instantiate the class..\n  // probably due to https://github.com/angular/angular-cli/commit/639198499973e0f437f059b3c933c72c733d93d8\n  static create<T = any>(table: PblNgridComponent<any>, injector: Injector, extApi: PblNgridExtensionApi): PblNgridPluginContext<T> {\n    if (TABLE_PLUGIN_CONTEXT.has(table)) {\n      throw new Error(`Table is already registered for extensions.`);\n    }\n\n    const instance = new PblNgridPluginContext<T>();\n    TABLE_PLUGIN_CONTEXT.set(table, instance);\n\n    instance.table = table;\n    instance.injector = injector;\n    instance.extApi = extApi;\n    instance.controller = new PblNgridPluginController(instance);\n\n    return instance;\n  }\n\n  table: PblNgridComponent<any>;\n  injector: Injector;\n  extApi: PblNgridExtensionApi;\n  controller: PblNgridPluginController<T>;\n  readonly events: Observable<PblNgridEvents>;\n  private _events = new Subject<PblNgridEvents>();\n\n  private constructor() {\n    this.events = this._events.asObservable();\n  }\n\n  emitEvent(event: PblNgridEvents): void {\n    this._events.next(event);\n  }\n\n  destroy(): void  {\n    if (!TABLE_PLUGIN_CONTEXT.has(this.table)) {\n      throw new Error(`Table is not registered.`);\n    }\n    this._events.complete();\n    TABLE_PLUGIN_CONTEXT.delete(this.table);\n  }\n}\n\nexport class PblNgridPluginController<T = any> {\n  private static readonly created$ = new Subject<{ table: PblNgridComponent<any>, controller: PblNgridPluginController<any> }>();\n  static readonly created = PblNgridPluginController.created$.asObservable();\n\n  get injector(): Injector { return this.context.injector; }\n\n  readonly extApi: PblNgridExtensionApi\n  readonly events: Observable<PblNgridEvents>;\n  private readonly grid: PblNgridComponent<T>\n  private readonly plugins = new Map<keyof PblNgridPluginExtension, PblNgridPlugin>();\n\n  constructor(private context: PblNgridPluginContext) {\n    this.grid = context.table;\n    this.extApi = context.extApi;\n    this.events = context.events;\n    PblNgridPluginController.created$.next({ table: this.grid, controller: this });\n  }\n\n  static find<T = any>(grid: PblNgridComponent<T>): PblNgridPluginController<T> | undefined {\n    const context = TABLE_PLUGIN_CONTEXT.get(grid);\n    if (context) {\n      return context.controller;\n    }\n  }\n\n  hasPlugin<P extends keyof PblNgridPluginExtension>(name: P): boolean {\n    return this.plugins.has(name);\n  }\n\n  getPlugin<P extends keyof PblNgridPluginExtension>(name: P): PblNgridPluginExtension[P] | undefined  {\n    return this.plugins.get(name) as any;\n  }\n\n  /**\n   * Registers the `plugin` with the `name` with the `table`\n   */\n  setPlugin<P extends keyof PblNgridPluginExtension>(name: P, plugin: PblNgridPluginExtension[P]): (table: PblNgridComponent<any>) => void {\n    if (!PLUGIN_STORE.has(name)) {\n      throw new Error(`Unknown plugin ${name}.`);\n    }\n    if (this.plugins.has(name)) {\n      throw new Error(`Plugin ${name} is not registered for this table.`);\n    }\n    this.plugins.set(name, plugin);\n    return (tbl: PblNgridComponent<any>) => this.grid === tbl && this.plugins.delete(name);\n  }\n\n  createPlugin<P extends (keyof PblNgridPluginExtensionFactories & keyof PblNgridPluginExtension)>(name: P): PblNgridPluginExtension[P] {\n    if (!PLUGIN_STORE.has(name)) {\n      throw new Error(`Unknown plugin ${name}.`);\n    }\n    const metadata = PLUGIN_STORE.get(name);\n    const methodName = metadata.factory;\n    if (!methodName) {\n      throw new Error(`Invalid plugin configuration for ${name}, no factory metadata.`);\n    } else if (typeof metadata.target[methodName] !== 'function') {\n      throw new Error(`Invalid plugin configuration for ${name}, factory metadata does not point to a function.`);\n    }\n    return metadata.target[methodName](this.grid, this.context.injector);\n  }\n}\n","import { Observable } from 'rxjs';\nimport { InjectionToken } from '@angular/core';\n\nimport { PblCdkTableComponent } from '../table';\nimport { ContextApi } from '../table/context/api';\nimport { PblNgridComponent } from '../table/table.component';\nimport { PblColumnStore } from '../table/columns/column-store';\nimport { DynamicColumnWidthLogic } from '../table/col-width-logic/dynamic-column-width';\nimport { PblCdkVirtualScrollViewportComponent } from '../table/features/virtual-scroll/virtual-scroll-viewport.component'\nimport { PblNgridEvents } from './types';\nimport { PblNgridMetaRowService } from '../table/meta-rows/index';\n\nexport const EXT_API_TOKEN = new InjectionToken('PBL_NGRID_EXTERNAL_API');\n\nexport interface PblNgridExtensionApi<T = any> {\n  table: PblNgridComponent<T>;\n  element: HTMLElement;\n  cdkTable: PblCdkTableComponent<T>;\n  columnStore: PblColumnStore;\n  contextApi: ContextApi<T>;\n  events: Observable<PblNgridEvents>;\n  metaRowService: PblNgridMetaRowService;\n  onInit(fn: () => void): void;\n  setViewport(viewport: PblCdkVirtualScrollViewportComponent): void;\n  dynamicColumnWidthFactory(): DynamicColumnWidthLogic;\n}\n","import { PblColumn } from '../table/columns';\nimport { DataSourceFilter, DataSourceFilterToken, DataSourcePredicate, DataSourceColumnPredicate } from './types';\n\nexport function createFilter(value: DataSourceFilterToken, columns: PblColumn[]): DataSourceFilter {\n  return value === undefined\n    ? undefined\n    : {\n      columns,\n      type: typeof value === 'function' ? 'predicate' : 'value',\n      filter: value\n    };\n}\n\nexport function filter<T>(rawData: T[], filter: DataSourceFilter): T[] {\n  if (!filter || !rawData || rawData.length === 0) {\n    return rawData;\n  } else {\n    const cols = filter.columns;\n    if (filter.type === 'predicate') {\n      const value: DataSourcePredicate = <any>filter.filter;\n      return rawData.filter( v => value(v, cols) );\n    } else if ( filter.type === 'value' ) {\n      const value = typeof filter.filter.toLowerCase === 'function' ? filter.filter.toLowerCase() : filter.filter;\n      return rawData.filter( row => cols.some( col => {\n        const predicate = col.filter || genericColumnPredicate;\n        return predicate(col.filter ? filter.filter : value, col.getValue(row), row, col);\n      }));\n    }\n  }\n  return rawData;\n}\n\n/**\n * A generic column predicate that compares the inclusion (text) of the value in the column value.\n */\nexport const genericColumnPredicate: DataSourceColumnPredicate = (filterValue: any, colValue: any, row?: any, col?: PblColumn): boolean => {\n  return colValue && colValue.toString().toLowerCase().includes(filterValue);\n}\n","import { PblColumn } from '../table/columns';\nimport { PblNgridSortDefinition, PblNgridSortInstructions, PblNgridSorter } from './types';\n\n/**\n * Apply sorting on a collection, based on column and sort definitions.\n * If the sort definition doesn't have a sorting function the default sorter is used.\n */\nexport function applySort<T>(column: PblColumn, sort: PblNgridSortDefinition, data: T[]): T[] {\n  if (!sort || !sort.order) {\n    return data;\n  }\n\n  const sortFn: PblNgridSorter<T> = typeof sort.sortFn === 'function'\n    ? sort.sortFn\n    : typeof column.sort === 'function'\n      ? column.sort\n      : defaultSorter\n  ;\n\n  return column && data\n    ? sortFn(column, sort, data.slice())\n    : data || []\n  ;\n}\n\nfunction defaultSorter<T>(column: PblColumn, sort: PblNgridSortInstructions, data: T[]): T[] {\n  return data.sort((a, b) => {\n    let valueA = column.getValue(a);\n    let valueB = column.getValue(b);\n\n    valueA = isNaN(+valueA) ? valueA : +valueA;\n    valueB = isNaN(+valueB) ? valueB : +valueB;\n\n    return (valueA < valueB ? -1 : valueA === valueB ? 0 : 1) * (sort.order === 'asc' ? 1 : -1);\n  });\n}\n","import { PblNgridDataSourceSortChange, DataSourceFilter } from './types';\n\nimport {\n  RefreshDataWrapper,\n  PblDataSourceTriggerChange,\n  PblDataSourceTriggers,\n  PblDataSourceTriggerCache,\n  PblDataSourceTriggerChangedEvent,\n  TriggerChangedEventFor,\n} from './data-source-adapter.types';\n\nexport const EMPTY: any = Object.freeze({});\n\n/** @internal */\nexport type DEEP_COMPARATORS<K extends keyof PblDataSourceTriggerCache> = {\n  [P in K]?: (prev: PblDataSourceTriggerCache[P], curr: PblDataSourceTriggerCache[P]) => boolean;\n};\n\nexport const DEEP_COMPARATORS: DEEP_COMPARATORS<keyof PblDataSourceTriggerCache> = {\n  filter(prev: DataSourceFilter, curr: DataSourceFilter): boolean {\n    return prev.filter === curr.filter\n      && prev.type == curr.type;\n      // TODO: deep compare columns\n      // && (prev.columns || []).join() === (curr.columns || []).join();\n  },\n  sort(prev: PblNgridDataSourceSortChange, curr: PblNgridDataSourceSortChange): boolean {\n    if (prev.column === curr.column) {\n      const pSort = prev.sort || {};\n      const cSort = curr.sort || {};\n      return pSort.order === cSort.order && pSort.sortFn === cSort.sortFn;\n    }\n  },\n  data(prev: RefreshDataWrapper<any>, curr: RefreshDataWrapper<any>): boolean {\n    return prev === curr;\n  }\n};\n\nexport function fromRefreshDataWrapper<T>(change: PblDataSourceTriggerChange<RefreshDataWrapper<T>>): PblDataSourceTriggerChange<T> {\n  return {\n    changed: change.changed,\n    prev: change.prev.data,\n    curr: change.hasOwnProperty('curr') ? change.curr.data : change.prev.data,\n  };\n}\n\nexport type CoValue<P extends keyof PblDataSourceTriggerCache> = P extends keyof PblDataSourceTriggers ? PblDataSourceTriggers[P] : PblDataSourceTriggerCache[P];\n\nexport function createChangeContainer<P extends keyof PblDataSourceTriggerCache>(type: P,\n                                                                                 value: CoValue<P>,\n                                                                                 cache: PblDataSourceTriggerCache): TriggerChangedEventFor<P> {\n  if (type === 'pagination') {\n    const pagination: PblDataSourceTriggers['pagination'] = (value || {}) as any;\n    const cached = cache['pagination'];\n    // we compare weak because we dont want changes from undefined to null etc...\n    const changedKeys: Array<keyof PblDataSourceTriggers['pagination']> = Object.keys(pagination).filter( k => cached[k] != pagination[k][1] && k !== 'total') as any;\n\n    const event: PblDataSourceTriggerChangedEvent['pagination'] = {\n      changed: changedKeys.length > 0,\n      page: createNotChangedEvent(cached.page),\n      perPage: createNotChangedEvent(cached.perPage),\n    };\n    if (event.changed) {\n      for (const k of changedKeys) {\n        event[k].changed = true;\n        event[k].prev = pagination[k][0];\n        event[k].curr = cached[k] = pagination[k][1];\n      }\n    }\n    return event as TriggerChangedEventFor<P>;\n  } else {\n    value = value || EMPTY;\n    const cachedValue = cache[type];\n    if (value === cachedValue) {\n      return createNotChangedEvent(cachedValue) as any;\n    } else if (value !== EMPTY && cachedValue !== EMPTY) {\n      const fn: (prev: PblDataSourceTriggerCache[P], curr: PblDataSourceTriggerCache[P]) => boolean = DEEP_COMPARATORS[type as any];\n      if (fn(cachedValue, value as any)) {\n        return createNotChangedEvent(cachedValue) as any;\n      }\n    }\n    cache[type] = value as any;\n    return { changed: true, prev: cachedValue, curr: value } as any;\n  }\n}\n\nfunction createNotChangedEvent<T>(value: T): PblDataSourceTriggerChange<T> {\n  return { changed: false, prev: value, curr: value };\n}\n","import { Observable, Subject, combineLatest, of, from, isObservable, asapScheduler } from 'rxjs';\nimport { filter, map, switchMap, tap, debounceTime, observeOn } from 'rxjs/operators';\n\nimport { DataSourceOf } from './data-source';\nimport { PblPaginator, PblPaginatorChangeEvent } from '../paginator';\nimport { PblNgridDataSourceSortChange, DataSourceFilter } from './types';\nimport { filter as filteringFn } from './filtering';\nimport { applySort } from './sorting';\n\nimport {\n  RefreshDataWrapper,\n  PblDataSourceConfigurableTriggers,\n  PblDataSourceTriggers,\n  PblDataSourceTriggerCache,\n  PblDataSourceTriggerChangedEvent,\n  TriggerChangedEventFor,\n  PblDataSourceAdapterProcessedResult,\n} from './data-source-adapter.types';\n\nimport { createChangeContainer, fromRefreshDataWrapper, EMPTY } from './data-source-adapter.helpers';\n\nconst CUSTOM_BEHAVIOR_TRIGGER_KEYS: Array<keyof PblDataSourceConfigurableTriggers> = ['sort', 'filter', 'pagination'];\nconst TRIGGER_KEYS: Array<keyof PblDataSourceTriggers> = [...CUSTOM_BEHAVIOR_TRIGGER_KEYS, 'data'];\nconst SOURCE_CHANGING_TOKEN = {};\n\nconst DEFAULT_INITIAL_CACHE_STATE: PblDataSourceTriggerCache<any> = { filter: EMPTY, sort: EMPTY, pagination: {}, data: EMPTY };\n\n/**\n * An adapter that handles changes\n */\nexport class PblDataSourceAdapter<T = any, TData = any> {\n  onSourceChanged: Observable<T[]>;\n  onSourceChanging: Observable<void>;\n\n  protected paginator?: PblPaginator<any>;\n  private readonly config: Partial<Record<keyof PblDataSourceConfigurableTriggers, boolean>>;\n  private cache: PblDataSourceTriggerCache<TData>;\n  private _onSourceChange$: Subject<any | T[]>;\n  private _refresh$: Subject<RefreshDataWrapper<TData>>;\n  private _lastSource: T[];\n  private _lastSortedSource: T[];\n  private _lastFilteredSource: T[];\n\n  /**\n   * A Data Source adapter contains flow logic for the datasource and subsequent emissions of datasource instances.\n   * The logic is determined by the combination of the config object and the sourceFactory provided to this adapter, making this adapter actually a container.\n   *\n   * There are 4 triggers that are responsible for datasource emissions, when one of them is triggered it will invoke the `sourceFactory`\n   * returning a new datasource, i.e. a new datasource emission.\n   *\n   * The triggers are: filter, sort, pagination and refresh.\n   *\n   * The refresh trigger does not effect the input sent to the `sourceFactory` function, it is just a mean to initiate a call to create a new\n   * datasource without changing previous flow variables.\n   * It's important to note that calling `sourceFactory` with the same input 2 or more times does not guarantee identical response. For example\n   * calling a remote server that might change it's data between calls.\n   *\n   * All other triggers (3) will change the input sent to the `sourceFactory` function which will use them to return a datasource.\n   *\n   * The input sent to `sourceFactory` is the values that each of the 3 triggers yields, when one trigger changes a new value for it is sent\n   * and the last values of the other 2 triggers is sent with it. i.e. the combination of the last known value for all 3 triggers is sent.\n   *\n   * To enable smart caching and data management `sourceFactory` does not get the raw values of each trigger. `sourceFactory` will get\n   * an event object that contains metadata about each trigger, whether it triggered the change or not as well as old and new values.\n   *\n   * The returned value from `sourceFactory` is then used as the datasource, applying all triggers that are not overridden by the user.\n   * The returned value of `sourceFactory` can be a `DataSourceOf` or `false`.\n   *   - `DataSourceOf` means a valid datasource, either observable/promise of array or an array.\n   *   - `false` means skip, returning false will instruct the adapter to skip execution for this trigger cycle.\n   *\n   * Using a trigger is a binary configuration option, when a trigger is turned on it means that changes to it will be passed to the `sourceFactory`.\n   * When a trigger is turned off it is not listened to and `undefined` will be sent as a value for it to the `sourceFactory`.\n   *\n   * The adapter comes with built in flow logic for all 3 triggers, when a trigger is turned off the adapter will take the result of `sourceFactory` and\n   * apply the default behavior to it.\n   *\n   * For all triggers, the default behavior means client implementation. For filtering, client side filtering. For sorting, client side sorting.\n   * For Pagination, client side pagination.\n   *\n   * You can opt in to one or more triggers and implement your own behavior inside the `sourceFactory`\n   * @param sourceFactory - A function that returns the datasource based on flow instructions.\n   * The instructions are optional, they might or might not exist depending on the configuration of the adapter.\n   * When `sourceFactory` returns false the entire trigger cycle is skipped.\n   * @param config - A configuration object describing how this adapter should behave.\n   */\n  constructor(public sourceFactory: (event: PblDataSourceTriggerChangedEvent) => (false | DataSourceOf<T>),\n              config?: false | Partial<Record<keyof PblDataSourceConfigurableTriggers, boolean>>) {\n    this.config = Object.assign({}, config || {});\n    this.initStreams();\n  }\n\n  dispose(): void {\n    this._refresh$.complete();\n    this._onSourceChange$.complete();\n  }\n\n  refresh(data?: TData): void {\n    this._refresh$.next({ data });\n  }\n\n  /**\n   * Clears the cache from any existing datasource trigger such as filter, sort etc.\n   * @returns The cached value or null if not there.\n   */\n  clearCache<P extends keyof PblDataSourceTriggerCache>(cacheKey: P): PblDataSourceTriggerCache<TData>[P] | null {\n    if (cacheKey in this.cache) {\n      const prev = this.cache[cacheKey];\n      this.cache[cacheKey] = DEFAULT_INITIAL_CACHE_STATE[cacheKey];\n      return prev;\n    } else {\n      return null;\n    }\n  }\n\n  setPaginator(paginator: PblPaginator<any> | undefined): void {\n    this.paginator = paginator;\n  }\n\n  updateProcessingLogic(filter$: Observable<DataSourceFilter>,\n                        sort$: Observable<PblNgridDataSourceSortChange & { skipUpdate: boolean }>,\n                        pagination$: Observable<PblPaginatorChangeEvent>,\n                        initialState: Partial<PblDataSourceTriggerCache<TData>> = {}): Observable<PblDataSourceAdapterProcessedResult<T, TData>> {\n    let updates = -1;\n    const changedFilter = e => updates === -1 || e.changed;\n    const skipUpdate = (o: PblNgridDataSourceSortChange & { skipUpdate: boolean }) => o.skipUpdate !== true;\n\n    this._lastSource = undefined;\n\n    this.cache = { ...DEFAULT_INITIAL_CACHE_STATE, ...initialState };\n\n    const combine: [\n      Observable<TriggerChangedEventFor<'filter'>>,\n      Observable<TriggerChangedEventFor<'sort'>>,\n      Observable<TriggerChangedEventFor<'pagination'>>,\n      Observable<TriggerChangedEventFor<'data'>>\n    ] = [\n      filter$.pipe( map( value => createChangeContainer('filter', value, this.cache) ), filter(changedFilter) ),\n      sort$.pipe( filter(skipUpdate), map( value => createChangeContainer('sort', value, this.cache) ), filter(changedFilter) ),\n      pagination$.pipe( map( value => createChangeContainer('pagination', value, this.cache) ), filter(changedFilter) ),\n      this._refresh$.pipe( map( value => fromRefreshDataWrapper(createChangeContainer('data', value, this.cache)) ), filter(changedFilter) ),\n    ];\n\n    const hasCustomBehavior = CUSTOM_BEHAVIOR_TRIGGER_KEYS.some( key => !!this.config[key] );\n\n    return combineLatest(combine[0], combine[1], combine[2], combine[3])\n      .pipe(\n        // Defer to next loop cycle, until no more incoming.\n        // We use an async schedular here (instead of asapSchedular) because we want to have the largest debounce window without compromising integrity\n        // With an async schedular we know we will run after all micro-tasks but before \"real\" async operations.\n        debounceTime(0),\n        switchMap( ([filter, sort, pagination, data ]) => {\n          updates++; // if first, will be 0 now (starts from -1).\n          const event: PblDataSourceTriggerChangedEvent<TData> = {\n            filter,\n            sort,\n            pagination,\n            data,\n            isInitial: updates === 0,\n            updateTotalLength: (totalLength) => {\n              if (this.paginator) {\n                this.paginator.total = totalLength;\n              }\n            }\n          };\n\n          const runHandle = data.changed\n            || ( hasCustomBehavior && CUSTOM_BEHAVIOR_TRIGGER_KEYS.some( k => !!this.config[k] && event[k].changed) );\n\n          if (runHandle) {\n            return this.runHandle(event).pipe(\n              tap( () => event.data.changed = true ), // if the user didn't return \"false\" from his handler, we infer data was changed!\n              map( data => ({ event, data })),\n            );\n          } else {\n            return of({ event, data: this._lastSource });\n          }\n        }),\n        map( response => {\n          const config = this.config;\n          const event = response.event;\n\n          // mark which of the triggers has changes\n          // The logic is based on the user's configuration and the incoming event\n          const withChanges: Partial<Record<keyof PblDataSourceConfigurableTriggers, boolean>> = {};\n          for (const key of CUSTOM_BEHAVIOR_TRIGGER_KEYS) {\n            if (!config[key] && (event.isInitial || event[key].changed)) {\n              withChanges[key] = true;\n            }\n          }\n\n          // When data changed, apply some logic (caching, operational, etc...)\n          if (event.data.changed) {\n            // cache the data when it has changed.\n            this._lastSource = response.data;\n\n            if (config.sort) {\n              // When the user is sorting (i.e. server sorting), the last sort cached is always the last source we get from the user.\n              this._lastSortedSource = this._lastSource;\n            } else {\n              // When user is NOT sorting (we sort locally) AND the data has changed we need to apply sorting on it\n              // this might already be true (if sorting was the trigger)...\n              withChanges.sort = true;\n\n              // because we sort and then filter, filtering updates are also triggered by sort updated\n              withChanges.filter = true;\n            }\n\n            if (config.filter) {\n              // When the user is filtering (i.e. server filtering), the last filter cached is always the last source we get from the user.\n              this._lastFilteredSource = this._lastSource;\n            } else {\n              // When user is NOT filtering (we filter locally) AND the data has changed we need to apply filtering on it\n              // this might already be true (if filtering was the trigger)...\n              withChanges.filter = true;\n            }\n          }\n\n          // When user is NOT applying pagination (we paginate locally) AND if we (sort OR filter) locally we also need to paginate locally\n          if (!config.pagination && (withChanges.sort || withChanges.filter)) {\n            withChanges.pagination = true;\n          }\n\n          // Now, apply: sort --> filter --> pagination     ( ORDER MATTERS!!! )\n\n          if (withChanges.sort) {\n            this._lastSortedSource = this.applySort(this._lastSource, event.sort.curr || event.sort.prev);\n          }\n\n          let data: T[] = this._lastSortedSource;\n\n          // we check if filter was asked, but also if we have a filter we re-run\n          // Only sorting is cached at this point filtering is always calculated\n          if (withChanges.filter || (event.filter.curr && event.filter.curr.filter)) {\n            data = this._lastFilteredSource = this.applyFilter(data, event.filter.curr || event.filter.prev);\n          }\n\n          if (withChanges.pagination) {\n            data = this.applyPagination(data);\n          }\n\n          const clonedEvent: PblDataSourceTriggerChangedEvent<TData> = { ...event };\n\n          // We use `combineLatest` which caches pervious events, only new events are replaced.\n          // We need to mark everything as NOT CHANGED, so subsequent calls will not have their changed flag set to true.\n          //\n          // We also clone the object so we can pass on the proper values.\n          // We create shallow clones so complex objects (column in sort, user data in data) will not throw on circular.\n          // For pagination we deep clone because it contains primitives and we need to also clone the internal change objects.\n          for (const k of TRIGGER_KEYS) {\n            clonedEvent[k] = k === 'pagination'\n              ? JSON.parse(JSON.stringify(event[k]))\n              : { ...event[k] }\n            ;\n            event[k].changed = false;\n          }\n          event.pagination.page.changed = event.pagination.perPage.changed = false;\n\n          return {\n            event: clonedEvent,\n            data,\n            sorted: this._lastSortedSource,\n            filtered: this._lastFilteredSource,\n          };\n        })\n      );\n  }\n\n  protected applyFilter(data: T[], dataSourceFilter: DataSourceFilter): T[] {\n    data = filteringFn(data, dataSourceFilter);\n    if (!this.config.pagination) {\n      this.resetPagination(data.length);\n    }\n    return data;\n  }\n\n  protected applySort(data: T[], event: PblNgridDataSourceSortChange): T[] {\n    return applySort(event.column, event.sort, data);\n  }\n\n  protected applyPagination(data: T[]):  T[] {\n    if (this.paginator) {\n      // Set the rendered rows length to the virtual page size. Fill in the data provided\n      // from the index start until the end index or pagination size, whichever is smaller.\n      const range = this.paginator.range;\n      return data.slice(range[0], range[1]);\n    }\n    return data;\n  }\n\n  protected resetPagination(totalLength: number): void {\n    if (this.paginator) {\n      this.paginator.total = totalLength;\n      this.paginator.page = totalLength > 0 ? 1 : 0;\n    }\n  }\n\n  /* Note:  Currently this is only used in the constructor.\n            However, if called elsewhere (i.e. if we can re-init the adapter) we need to track all code that is using\n            `onSourceChanged` and or `onSourceChanging` and make it support the replacement of the observable.\n            Because the API is public it will probably won't work so the best solution might be to switch\n            `onSourceChanged` and `onSourceChanging` to subjects that are alive always and emit them internally in this class. */\n  private initStreams(): void {\n    this._onSourceChange$ = new Subject<T[]>();\n    this.onSourceChanged = this._onSourceChange$.pipe(filter( d => d !== SOURCE_CHANGING_TOKEN ));\n    this.onSourceChanging = this._onSourceChange$.pipe(filter( d => d === SOURCE_CHANGING_TOKEN ));\n    this._refresh$ = new Subject<RefreshDataWrapper<TData>>();\n    this._lastSource = undefined;\n  }\n\n  /**\n   * Execute the user-provided function that returns the data collection.\n   * This method wraps each of the triggers with a container providing metadata for the trigger. (Old value, was changed? and new value if changed)\n   * This is where all cache logic is managed (createChangeContainer).\n   *\n   * To build a data collection the information from all triggers is required, even if it was not changed.\n   * When a trigger is fired with a new value the new value replaces the old value for the trigger and all other triggers will keep their old value.\n   * Sending the triggers to the handlers is not enough, we also need to the handlers which of the trigger's have change so they can return\n   * data without doing redundant work.\n   * For example, fetching paginated data from the server requires a call whenever the pages changes but if the filtering is local for the current page\n   * and the filter trigger is fired the handler needs to know that pagination did not change so it will not go and fetch data from the server.\n   *\n   * The handler can return several data structures, observable, promise, array or false.\n   * This method will normalize the response into an observable and notify that the source changed (onSourceChanged).\n   *\n   * When the response is false that handler wants to skip this cycle, this means that onSourceChanged will not emit and\n   * a dead-end observable is returned (observable that will never emit).\n   */\n  private runHandle(event: PblDataSourceTriggerChangedEvent<TData>): Observable<T[]> {\n    this._onSourceChange$.next(SOURCE_CHANGING_TOKEN);\n\n    const result = this.sourceFactory(event);\n    if (result === false) {\n      return of(false).pipe(filter( () => false )) as any; // stop emissions if got false.\n    }\n\n    const obs: Observable<T[]> = isObservable(result)\n      ? result\n      : Array.isArray(result)\n        ? of(result)\n        : from(result) // promise...\n    ;\n\n    return obs.pipe(\n      // run as a micro-task\n      observeOn(asapScheduler, 0),\n      map( data => Array.isArray(data) ? data : [] ),\n      tap( data => this._onSourceChange$.next(data) )\n    );\n  }\n}\n","import { Observable, BehaviorSubject } from 'rxjs';\n\nexport type PblNgridPaginatorKind = 'pageNumber' | 'token';\n\n/**\n * An object with properties representing the change in the paginator.\n * Each property point to a tuple with 2 items.\n * The first item is the old value, the 2nd item is the new value.\n *\n * The properties that can change are page, perPage and total.\n */\nexport interface PblPaginatorChangeEvent<T = any> {\n  page?: [T, T];\n  perPage?: [number, number];\n  total?: [number, number];\n}\n\nexport interface PblPaginator<TPage> {\n  kind: PblNgridPaginatorKind;\n  /**\n   * When true will assume that the datasource represents a single page.\n   * This is common in server side pagination where pervious data is not cached and each pages is fetched and set as is, i.e. the datasource\n   * represents a single page at a time.\n   *\n   * For example, consider a paginator with 10 items per page, pointing to page 4.\n   * When `noCacheMode` is set to `true` the range is [30, 39]\n   * When `noCacheMode` is set to `false` the range is [0, 9]\n   */\n  noCacheMode: boolean;\n\n  perPage: number;\n  page: TPage;\n  total: number;\n  readonly totalPages: number;\n  readonly range: [number, number];\n\n  onChange: Observable<PblPaginatorChangeEvent<TPage>>;\n  reset(): void;\n  canMove(value: TPage): boolean;\n  hasNext(): boolean;\n  hasPrev(): boolean;\n  move(value: TPage): void;\n  nextPage(): void;\n  prevPage(): void;\n\n}\n\nexport class PblTokenPaginator implements PblPaginator<string> {\n  readonly kind: 'token' = 'token';\n  noCacheMode: boolean;\n\n  get perPage(): number { return this._perPage; }\n  set perPage(value: number) {\n    if (value < 1) {\n      throw new Error(`Invalid total size value ${value}`);\n    }\n\n    if (this._perPage !== value) {\n      const changes: PblPaginatorChangeEvent<string> = { perPage: [this._perPage, this._perPage = value] };\n      this.emit(changes);\n    }\n  }\n\n  get page(): string { return this._page; }\n  set page(value: string) {\n    if (this._page !== value) {\n      const idx = this._tokens.indexOf(value);\n      if (idx === -1) {\n        throw new Error(`Invalid page token ${value}`);\n      }\n      this._cursor = idx;\n      const prev = this._page;\n      this._page = value;\n      this.emit({ page: [prev, value] });\n    }\n  }\n\n  get total(): number { return this._total; }\n  set total(value: number) {\n    const changes: PblPaginatorChangeEvent<string> = { total: [this._total, this._total = value] };\n    this.emit(changes);\n  }\n\n  get totalPages(): number {\n    return this._tokens.length;\n  }\n\n  get range(): [number, number] {\n    if (!this._range) {\n      const start = (this._cursor) * this.perPage;\n      const end = Math.min(this._total, start + this.perPage);\n      this._range = this.noCacheMode\n        ? [ 0, end - start ]\n        : [ start, end ]\n      ;\n    }\n    return this._range;\n  }\n\n  readonly onChange: Observable<PblPaginatorChangeEvent<string>>;\n  protected onChange$: BehaviorSubject<PblPaginatorChangeEvent<string>>;\n  protected queuedChanges: PblPaginatorChangeEvent<string> | undefined;\n  protected _range: [number, number];\n  protected _perPage: number = 10;\n  protected _page: any;\n  protected _total: number = 0;\n  protected _tokens: any[];\n  protected _cursor: number;\n\n  constructor() {\n    this.onChange$ = new BehaviorSubject<PblPaginatorChangeEvent<string>>({page: [null, null]});\n    this.onChange = this.onChange$.asObservable();\n    this.reset();\n  }\n\n  reset(): void {\n    this._tokens = [null];\n    this._cursor = 0;\n    this._total = 0;\n    this.page = null;\n  }\n\n  canMove(value: string): boolean {\n    return this._tokens.indexOf(value) > -1;\n  }\n\n  hasNext(): boolean { return this._cursor < this._tokens.length - 1; }\n  hasPrev(): boolean { return this._cursor > 0; }\n\n  move(value: string): void { this.page = value; }\n  nextPage(): void { this.page = this._tokens[++this._cursor]; }\n  prevPage(): void { this.page = this._tokens[--this._cursor]; }\n\n  addNext(value: any): void {\n    const nextPointer = this._cursor + 1;\n    // if next pointer is not like what we got, set it and delete all after (invalidate them)\n    if (this._tokens[nextPointer] !== value) {\n      this._tokens[nextPointer] = value;\n      this._tokens.splice(nextPointer + 1);\n    }\n  }\n\n  private emit(changes: PblPaginatorChangeEvent<string>): void {\n    this._range = undefined;\n    if (this.queuedChanges) {\n      Object.assign(this.queuedChanges, changes);\n    } else {\n      this.queuedChanges = changes;\n      setTimeout(() => {\n        this.queuedChanges = undefined;\n        this.onChange$.next(changes);\n      });\n    }\n  }\n}\n\nexport class PblPagingPaginator implements PblPaginator<number> {\n  readonly kind: 'pageNumber' = 'pageNumber';\n  noCacheMode: boolean;\n\n  get perPage(): number { return this._perPage; }\n  set perPage(value: number) {\n    if (value < 1) {\n      throw new Error(`Invalid total size value ${value}`);\n    }\n\n    if (this._perPage !== value) {\n      const changes: PblPaginatorChangeEvent<number> = { perPage: [this._perPage, this._perPage = value] };\n\n      const prev = this._page;\n      this.calcPages();\n      if (prev !== this._page) {\n        changes.page = [prev, this._page];\n      }\n      this.emit(changes);\n    }\n\n  }\n\n  /**\n   * Get / Set the current page\n   */\n  get page(): number { return this._page; }\n  set page(value: number) {\n    if (value < 0 || value > this._totalPages) {\n      throw new Error(`Invalid page index ${value}`);\n    }\n\n    if (this._page !== value) {\n      const prev = this._page;\n      this._page = value;\n      this.emit({ page: [prev, value] });\n    }\n  }\n\n  get total(): number { return this._total; }\n  set total(value: number) {\n    if (value < 0) {\n      throw new Error(`Invalid total size value ${value}`);\n    }\n\n    if (this._total !== value) {\n      const changes: PblPaginatorChangeEvent<number> = { total: [this._total, this._total = value] };\n\n      const prev = this._page;\n      this.calcPages();\n      if (prev !== this._page) {\n        changes.page = [prev, this._page];\n      }\n\n      this.emit(changes);\n    }\n  }\n\n  /**\n   * The amount of pages in this paginator\n   */\n  get totalPages(): number {\n    return this._totalPages;\n  }\n\n  get range(): [number, number] {\n    if (!this._range) {\n      const start = (this.page - 1) * this.perPage;\n      const end = Math.min(this._total, start + this.perPage);\n      this._range = this.noCacheMode\n        ? [ 0, end - start ]\n        : [ start, end ]\n      ;\n    }\n    return this._range;\n  }\n\n  readonly onChange: Observable<PblPaginatorChangeEvent<number>>;\n  protected onChange$: BehaviorSubject<PblPaginatorChangeEvent<number>>;\n\n  private _total = 0;\n  private _perPage = 10;\n  private _page = 1;\n  private _totalPages = 0;\n  private _range: [number, number];\n\n  private queuedChanges: PblPaginatorChangeEvent<number> | undefined;\n\n  constructor() {\n    this.onChange$ = new BehaviorSubject<PblPaginatorChangeEvent<number>>({page: [null, 1]});\n    this.onChange = this.onChange$.asObservable();\n  }\n\n  canMove(value: number): boolean {\n    const p = this._page + value;\n    return p >= 1 && p <= this.totalPages;\n  }\n  hasNext(): boolean { return this.canMove(1); }\n  hasPrev(): boolean { return this.canMove(-1); }\n\n  move(value: number): void { this.page = this._page + value; }\n  nextPage(): void { this.move(1); }\n  prevPage(): void { this.move(-1); }\n\n\n  reset(): void {\n    this.page = 1;\n  }\n\n  /**\n   * Calculate the number of pages.\n   * returns true if the current page has changed due to calculation. (current page \\> new pages value)\n   */\n  protected calcPages(): void {\n    this._totalPages = Math.ceil(this._total / this.perPage);\n    if (this._totalPages > 0 && this._page > this._totalPages) {\n      this.page = this._totalPages;\n    }\n  }\n\n  private emit(changes: PblPaginatorChangeEvent<number>): void {\n    this._range = undefined;\n    if (this.queuedChanges) {\n      Object.assign(this.queuedChanges, changes);\n    } else {\n      this.queuedChanges = changes;\n      setTimeout(() => {\n        this.queuedChanges = undefined;\n        this.onChange$.next(changes);\n      });\n    }\n  }\n}\n","import { Observable, BehaviorSubject, Subject, of, asapScheduler } from 'rxjs';\nimport { mapTo, skip, observeOn, tap } from 'rxjs/operators';\n\nimport { SelectionModel, CollectionViewer, ListRange } from '@angular/cdk/collections';\nimport { DataSource } from '@angular/cdk/table';\nimport { moveItemInArray } from '@angular/cdk/drag-drop';\n\nimport { UnRx } from '@pebula/utils';\n\nimport { PblColumn } from '../table/columns';\nimport { PblNgridPaginatorKind, PblPaginator, PblPagingPaginator, PblTokenPaginator } from '../paginator';\nimport { DataSourcePredicate, DataSourceFilter, DataSourceFilterToken, PblNgridSortDefinition, PblNgridDataSourceSortChange } from './types';\nimport { createFilter } from './filtering';\nimport { PblDataSourceAdapter } from './data-source-adapter';\nimport { PblDataSourceTriggerCache, PblDataSourceTriggerChangedEvent, PblDataSourceAdapterProcessedResult } from './data-source-adapter.types';\n\nexport type DataSourceOf<T> = T[] | Promise<T[]> | Observable<T[]>;\n\nconst PROCESSING_SUBSCRIPTION_GROUP = {};\n\nexport interface PblDataSourceOptions {\n  /**\n   * When set to True will not disconnect upon table disconnection, otherwise does.\n   */\n  keepAlive?: boolean;\n  /**\n   * Skip the first trigger emission.\n   * Use this for late binding, usually with a call to refresh() on the data source.\n   *\n   * Note that only the internal trigger call is skipped, a custom calls to refresh will go through\n   */\n  skipInitial?: boolean;\n}\n\nexport class PblDataSource<T = any, TData = any> extends DataSource<T> {\n\n  get pagination(): PblNgridPaginatorKind | false { return this._pagination; }\n  set pagination(value: PblNgridPaginatorKind | false) {\n    if (this._pagination !== value) {\n      this._pagination = value;\n      switch (value) {\n        case 'pageNumber':\n          this._paginator = new PblPagingPaginator();\n          break;\n        case 'token':\n          this._paginator = new PblTokenPaginator();\n          break;\n        default:\n          this._paginator = undefined;\n          break;\n      }\n      if (this._adapter) {\n        this._adapter.setPaginator(this._paginator);\n      }\n    }\n  }\n\n  /**\n   * An observable that emit events when an new incoming source is expected, before calling the trigger handler to get the new source.\n   * This even is usually followed by the `onSourceChanged` event but not always. This is because the trigger handler\n   * can cancel the operation (when it returns false) which means an `onSourceChanged` event will not fire.\n   *\n   * Emissions occur when the trigger handler is invoked and also when the trigger handler returned an observable and the observable emits.\n   *\n   * > Note that a micro-task delays is applied between the `onSourceChanging` subsequent `onSourceChanged` event (when emitted).\n   */\n  readonly onSourceChanging: Observable<void>;\n  /**\n   * An observable that emit events when a new source has been received from the trigger handler but before any processing is applied.\n   * Emissions occur when the trigger handler is invoked and also when the trigger handler returned an observable and the observable emits.\n   *\n   * Examples: Calling `refresh()`, filter / sort / pagination events.\n   *\n   * > Note that the `onSourceChanged` fired before the data is rendered ane before any client-side filter/sort/pagination are applied.\n   * It only indicates that the source data-set is now updated and the grid is about to apply logic on the data-set and then render it.\n   */\n  readonly onSourceChanged: Observable<void>;\n  /**\n   * An observable that emit events when new source has been received from the trigger handler and after it was processed.\n   * Emissions will occur after `onSourceChanged` event has been fired.\n   *\n   * The main difference between `onSourceChanged` and `onRenderDataChanging` is local processing performed in the datasource.\n   * These are usually client-side operations like filter/sort/pagination. If all of these events are handled manually (custom)\n   * in the trigger handler then `onSourceChanged` and `onRenderDataChanging` have no difference.\n   *\n   * > Note that `onRenderDataChanging` and `onRenderedDataChanged` are not closely related as `onRenderedDataChanged` fires at\n   * a much more rapid pace (virtual scroll). The name `onRenderDataChanging` might change in the future.\n   */\n  readonly onRenderDataChanging: Observable<{ event: PblDataSourceTriggerChangedEvent<TData>, data: T[] }>;\n  /**\n   * An observable that emit events when the grid is about to render data.\n   * The rendered data is updated when the source changed or when the grid is in virtual scroll mode and the user is scrolling.\n   *\n   * Each emission reflects a change in the data that the grid is rendering.\n   */\n  readonly onRenderedDataChanged: Observable<void>;\n  readonly onError: Observable<Error>;\n  /**\n   * An event that fires when the connection state to a table has changed.\n   */\n  readonly tableConnectionChange: Observable<boolean>;\n  readonly sortChange: Observable<PblNgridDataSourceSortChange>;\n\n  /**\n   * When set to True will not disconnect upon table disconnection, otherwise unsubscribe from the\n   * datasource when the table disconnects.\n   */\n  readonly keepAlive: boolean;\n  /**\n   * Skip the first trigger emission.\n   * Use this for late binding, usually with a call to refresh() on the data source.\n   *\n   * Note that only the internal trigger call is skipped, a custom calls to refresh will go through\n   */\n  readonly skipInitial: boolean;\n\n  get adapter(): PblDataSourceAdapter { return this._adapter; };\n  set adapter(value: PblDataSourceAdapter) {\n    if (this._adapter !== value) {\n      this._adapter = value;\n      if (this.pagination) {\n        this._adapter.setPaginator(this._paginator);\n      }\n    }\n  }\n\n  // TODO(1.0.0): remove\n  /** @deprecated BREAKING CHANGE: removed in 1.0.0 - Use renderedData instead. */\n  get renderedRows(): T[] { return this._renderData$.value || []; }\n  /** Returns the starting index of the rendered data */\n  get renderStart(): number { return this._lastRange ? this._lastRange.start : 0; }\n  get renderLength(): number { return this._renderData$.value.length; }\n  get renderedData(): T[] { return this._renderData$.value || []; }\n  /**\n   * The `source` with sorting applied.\n   * Valid only when sorting is performed client-side.\n   *\n   * To get real-time notifications use `onRenderDataChanging`.\n   * The sorted data is updated just before `onRenderDataChanging` fire.\n   */\n  get sortedData(): T[] { return (this._lastAdapterEvent && this._lastAdapterEvent.sorted) || []; };\n  /**\n   * The `source` with filtering applied.\n   * Valid only when filtering is performed client-side.\n   * If sorting is applied as well, the filtered results are also sorted.\n   *\n   * To get real-time notifications use `onRenderDataChanging`.\n   * The filtered data is updated just before `onRenderDataChanging` fire.\n   */\n  get filteredData(): T[] { return (this._lastAdapterEvent && this._lastAdapterEvent.filtered) || []; };\n\n  get filter(): DataSourceFilter { return this._filter$.value; }\n  get sort(): PblNgridDataSourceSortChange { return this._sort$.value; }\n  get paginator(): PblPaginator<any> { return this._paginator; }\n\n  get length(): number { return this.source.length; }\n  get source(): T[] { return this._source || []; }\n\n  /** Represents selected items on the data source. */\n  get selection(): SelectionModel<T> { return this._selection; }\n\n  protected readonly _selection = new SelectionModel<T>(true, []);\n  protected readonly _tableConnectionChange$ = new Subject<boolean>();\n  protected readonly _onRenderDataChanging = new Subject<{ event: PblDataSourceTriggerChangedEvent<TData>, data: T[] }>();\n  protected readonly _renderData$ = new BehaviorSubject<T[]>([]);\n  protected readonly _filter$: BehaviorSubject<DataSourceFilter> = new BehaviorSubject<DataSourceFilter>(undefined);\n  protected readonly _sort$ = new BehaviorSubject<PblNgridDataSourceSortChange & { skipUpdate: boolean }>({ column: null, sort: null, skipUpdate: false });\n  protected _onError$ = new Subject<Error>();\n\n  protected _paginator: PblPaginator<any>;\n\n  private _pagination: PblNgridPaginatorKind | false;\n  private _adapter: PblDataSourceAdapter;\n  private _source: T[];\n  private _disposed: boolean;\n  private _tableConnected: boolean;\n  private _lastRefresh: TData;\n  private _lastRange: ListRange;\n  private _lastAdapterEvent: PblDataSourceAdapterProcessedResult<T, TData>;\n\n  constructor(adapter: PblDataSourceAdapter<T, TData>, options?: PblDataSourceOptions) {\n    super();\n    options = options || {};\n\n    this.adapter = adapter;\n\n    this.onSourceChanging = this._adapter.onSourceChanging;\n    // emit source changed event every time adapter gets new data\n    this.onSourceChanged = this.adapter.onSourceChanged\n    .pipe(\n      observeOn(asapScheduler, 0), // emit on the end of the current turn (micro-task) to ensure `onSourceChanged` emission in `_updateProcessingLogic` run's first.\n      mapTo(undefined)\n    );\n    this.onRenderDataChanging = this._onRenderDataChanging.asObservable();\n    this.onRenderedDataChanged = this._renderData$.pipe(skip(1), mapTo(undefined));\n    this.onError = this._onError$.asObservable();\n    this.tableConnectionChange = this._tableConnectionChange$.asObservable();\n\n    this.keepAlive = options.keepAlive || false;\n    this.skipInitial = options.skipInitial || false;\n    this.sortChange = this._sort$.asObservable();\n  }\n\n  /**\n   * A custom trigger that invokes a manual data source change with the provided data value in the `data` property at tht event.\n   */\n  refresh(data?: TData): void {\n    if (this._tableConnected) {\n      this._adapter.refresh(data);\n    } else {\n      this._lastRefresh = data;\n    }\n  }\n\n  /**\n   * Clear the filter definition for the current data set.\n   */\n  setFilter(): void;\n  /**\n   * Set the filter definition for the current data set using a function predicate.\n   *\n   * > Note that when using a custom predicate function all logic is passed to the predicate and the datasource / grid does not handle the filtering process.\n   * This means that any column specific filter, set in the column definitions is ignored, if you want to take these filters into consideration\n   * use the column instance provided to identify and use these filters (the `filter` property in `PblColumn`).\n   */\n  setFilter(value: DataSourcePredicate, columns?: PblColumn[]): void;\n  /**\n   * Set the filter definition for the current data set using a value to compare with and a list of columns with the values to compare to.\n   *\n   * When a column instance has a specific predicate set (`PblColumn.filter`) then it will be used, otherwise\n   * the `genericColumnPredicate` will be used.\n   */\n  setFilter(value: any, columns: PblColumn[]): void;\n  setFilter(value?: DataSourceFilterToken, columns?: PblColumn[]): void {\n    if (value && typeof value !== 'function' && (!columns || columns.length === 0)) {\n      throw new Error('Invalid filter definitions, columns are mandatory when using a single value input.');\n    }\n    this._filter$.next(createFilter(value, columns || []));\n  }\n\n  /**\n   * Refresh the filters result.\n   *\n   * Note that this should only be used when using a predicate function filter and not the simple value filter.\n   * In general the filter is refreshed every time it is set and each time the data is updated so manually refreshing a value filter\n   * has no impact.\n   *\n   * For custom predicate function filters this might be useful.\n   *\n   */\n  syncFilter(): void {\n    const currentFilter = this._adapter.clearCache('filter');\n    if (currentFilter) {\n      this.setFilter(currentFilter.filter, currentFilter.columns);\n    }\n  }\n\n  /**\n   * Clear the current sort definitions.\n   * @param skipUpdate When true will not update the datasource, use this when the data comes sorted and you want to sync the definitions with the current data set.\n   * default to false.\n   */\n  setSort(skipUpdate?: boolean): void;\n  /**\n   * Set the sorting definition for the current data set.\n   * @param column\n   * @param sort\n   * @param skipUpdate When true will not update the datasource, use this when the data comes sorted and you want to sync the definitions with the current data set.\n   * default to false.\n   */\n  setSort(column: PblColumn, sort: PblNgridSortDefinition, skipUpdate?: boolean): void;\n  setSort(column?: PblColumn | boolean, sort?: PblNgridSortDefinition, skipUpdate = false): void {\n    if (!column || typeof column === 'boolean') {\n      this._sort$.next({ column: null, sort: {}, skipUpdate: !!column });\n    } else {\n      this._sort$.next({ column, sort, skipUpdate });\n    }\n  }\n\n  dispose(): void {\n    if (!this._disposed) {\n      UnRx.kill(this);\n      this._adapter.dispose();\n      this._onRenderDataChanging.complete();\n      this._renderData$.complete();\n      this._filter$.complete();\n      this._sort$.complete();\n      this._onError$.complete();\n      this._disposed = true;\n    }\n  }\n\n  disconnect(cv: CollectionViewer): void {\n    this._lastRefresh = undefined;\n    this._tableConnectionChange$.next(this._tableConnected = false);\n    if (this.keepAlive === false) {\n      this.dispose();\n    }\n  }\n\n  connect(cv: CollectionViewer): Observable<T[]> {\n    if (this._disposed) {\n      throw new Error('PblDataSource is disposed. Use `keepAlive` if you move datasource between tables.');\n    }\n    this._tableConnected = true\n    this._updateProcessingLogic(cv);\n    this._tableConnectionChange$.next(this._tableConnected);\n    return this._renderData$;\n  }\n\n  /**\n   * Move's an item (in the entire source) from one index to the other, pushing the item in the destination one item backwards.\n   *\n   * Note that if the rendered data is a subset of the entire source (i.e virtual scroll & range) the indices are considered\n   * local to the rendered view and are translated to fit the entire source.\n   *\n   * Tp disable this behavior, set the `absolute` parameter to `true`\n   */\n  moveItem(fromIndex: number, toIndex: number, absolute = false): void {\n    if (absolute !== true && this._lastRange) {\n      fromIndex = this._lastRange.start + fromIndex;\n      toIndex = this._lastRange.start + toIndex;\n    }\n\n    if (this.length > 0) {\n      moveItemInArray(this._source, fromIndex, toIndex)\n      const data = this._lastRange\n        ? this._source.slice(this._lastRange.start, this._lastRange.end)\n        : this._source\n      ;\n      this._renderData$.next(data);\n    }\n  }\n\n  private _updateProcessingLogic(cv: CollectionViewer): void {\n    const initialState: Partial<PblDataSourceTriggerCache<TData>> = { filter: this.filter,  sort: this.sort };\n    const paginator = this._paginator;\n    if (paginator) {\n      initialState.pagination = { page: paginator.page, perPage: paginator.perPage };\n    }\n    const stream = this._adapter.updateProcessingLogic(\n      this._filter$,\n      this._sort$,\n      paginator ? paginator.onChange : of(undefined),\n      initialState,\n    );\n\n    UnRx.kill(this, PROCESSING_SUBSCRIPTION_GROUP)\n\n    const trimToRange = (range: ListRange, data: any[]) => data.slice(range.start, range.end) ;\n\n    let skipViewChange: boolean;\n    let lastEmittedSource: T[];\n\n    cv.viewChange\n      .pipe(UnRx(this, PROCESSING_SUBSCRIPTION_GROUP))\n      .subscribe( range => {\n        if (this._lastRange && this._lastRange.start === range.start && this._lastRange.end === range.end) {\n          return;\n        }\n        this._lastRange = range;\n        if (!skipViewChange) {\n          if (range && lastEmittedSource && lastEmittedSource.length) {\n            this._renderData$.next(trimToRange(this._lastRange, lastEmittedSource));\n          }\n        }\n      });\n\n    stream\n      .pipe(\n        UnRx(this, PROCESSING_SUBSCRIPTION_GROUP),\n        tap( result => {\n          lastEmittedSource = result.data;\n          skipViewChange = true;\n          this._onRenderDataChanging.next(this._lastAdapterEvent = result);\n        })\n      )\n      .subscribe(\n        ({data}) => {\n          if (this._lastRange && data && data.length) {\n            data = trimToRange(this._lastRange, data);\n          }\n          this._renderData$.next(data);\n          skipViewChange = false;\n        },\n        error => { this._onError$.next(error) }\n      );\n\n    this._adapter.onSourceChanged\n      .pipe(UnRx(this, PROCESSING_SUBSCRIPTION_GROUP))\n      .subscribe( source => this._source = source || [] );\n\n    if (this._lastRefresh !== undefined) {\n      this._adapter.refresh(this._lastRefresh);\n      this._lastRefresh = undefined;\n    } else if (!this.skipInitial) {\n      // _refresh$ is a Subject, we must emit once so combineLatest will work\n      this.refresh();\n    }\n  }\n}\n\n","import { PblDataSource, DataSourceOf, PblDataSourceOptions } from './data-source';\nimport { PblDataSourceAdapter } from './data-source-adapter';\nimport {\n  PblDataSourceConfigurableTriggers,\n  PblDataSourceTriggerChangedEvent,\n } from './data-source-adapter.types';\n\ninterface AdapterParams<T> {\n  onTrigger?: (event: PblDataSourceTriggerChangedEvent) => (false | DataSourceOf<T>);\n  customTriggers?: false | Partial<Record<keyof PblDataSourceConfigurableTriggers, boolean>>;\n}\n\nexport class PblDataSourceFactory<T, TData = any> {\n  private _adapter: AdapterParams<T> = { };\n  private _dsOptions: PblDataSourceOptions = { };\n  private _onCreated: (dataSource: PblDataSource<T, TData>) => void;\n\n  /**\n   * Set the main trigger handler.\n   * The trigger handler is the core of the datasource, responsible for returning the data collection.\n   *\n   * By default the handler is triggered only when the datasource is required.\n   * This can happened when:\n   *   - The table connected to the datasource.\n   *   - A manual call to `PblDataSource.refresh()` was invoked.\n   *\n   * There are additional triggers (filter/sort/pagination) which occur when their values change, e.g. when\n   * a filter has change or when a page in the paginator was changed.\n   *\n   * By default, these triggers are handled automatically, resulting in a client-side behavior for each of them.\n   * For example, a client side paginator will move to the next page based on an already existing data collection (no need to fetch from the server).\n   *\n   * To handle additional trigger you need to explicitly set them using `setCustomTriggers`.\n   */\n  onTrigger(handler: (event: PblDataSourceTriggerChangedEvent<TData>) => (false | DataSourceOf<T>)): this {\n    this._adapter.onTrigger = handler;\n    return this;\n  }\n\n  /**\n   * A list of triggers that will be handled by the trigger handler.\n   * By default all triggers are handled by the adapter, resulting in a client-side filter/sort/pagiantion that works out of the box.\n   * To implement server side filtering, sorting and/or pagination specify which should be handled by the on trigger handler.\n   *\n   * You can mix and match, e.g. support only paging from the server, or only paging and sorting, and leave filtering for the client side.\n   */\n  setCustomTriggers(...triggers: Array<keyof PblDataSourceConfigurableTriggers>): this {\n    if (triggers.length === 0) {\n      this._adapter.customTriggers = false;\n    } else {\n      const customTriggers = this._adapter.customTriggers = {};\n      for (const t of triggers) {\n        customTriggers[t] = true;\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Skip the first trigger emission.\n   * Use this for late binding, usually with a call to refresh() on the data source.\n   *\n   * Note that only the internal trigger call is skipped, a custom calls to refresh will go through\n   */\n  skipInitialTrigger(): this {\n    this._dsOptions.skipInitial = true;\n    return this;\n  }\n\n  keepAlive(): this {\n    this._dsOptions.keepAlive = true;\n    return this;\n  }\n\n  onCreated(handler: (dataSource: PblDataSource<T, TData>) => void ): this {\n    this._onCreated = handler;\n    return this;\n  }\n\n  create(): PblDataSource<T, TData> {\n    const _adapter = this._adapter;\n    const adapter = new PblDataSourceAdapter<T, TData>(\n      _adapter.onTrigger,\n      _adapter.customTriggers || false,\n    )\n    const ds = new PblDataSource<T, TData>(adapter, this._dsOptions);\n    if (this._onCreated) {\n      this._onCreated(ds);\n    }\n    return ds;\n  }\n}\n\nexport function createDS<T, TData = T[]>(): PblDataSourceFactory<T, TData> {\n  return new PblDataSourceFactory<T, TData>();\n}\n","import { PblColumnDefinition } from '../columns/types';\nimport { PblColumn } from '../columns/column';\nimport { PblMetaColumnStore } from '../columns/column-store';\nimport { StaticColumnWidthLogic } from '../col-width-logic/static-column-width';\n\n/**\n * Given an object (item) and a path, returns the value at the path\n */\nexport function deepPathGet(item: any, col: PblColumnDefinition): any {\n  if ( col.path ) {\n    for ( const p of col.path ) {\n      item = item[ p ];\n      if ( !item ) return;\n    }\n  }\n  return item[ col.prop ];\n}\n\n/**\n * Given an object (item) and a path, returns the value at the path\n */\nexport function deepPathSet(item: any, col: PblColumnDefinition, value: any): void {\n  if ( col.path ) {\n    for ( const p of col.path ) {\n      item = item[ p ];\n      if ( !item ) return;\n    }\n  }\n  item[ col.prop ] = value;\n}\n\n/**\n * Updates the column sizes of the columns provided based on the column definition metadata for each column.\n * The final width represent a static width, it is the value as set in the definition (except column without width, where the calculated global width is set).\n */\nexport function resetColumnWidths(rowWidth: StaticColumnWidthLogic,\n                                  tableColumns: PblColumn[],\n                                  metaColumns: PblMetaColumnStore[],\n                                  options: { tableMarkForCheck?: boolean; metaMarkForCheck?: boolean; } = {}): void {\n  const { pct, px } = rowWidth.defaultColumnWidth;\n  const defaultWidth = `calc(${pct}% - ${px}px)`;\n\n  let mark = !!options.tableMarkForCheck;\n  for (const c of tableColumns) {\n    c.setDefaultWidth(defaultWidth);\n    c.updateWidth(mark);\n  }\n\n  mark = !!options.metaMarkForCheck;\n  for (const m of metaColumns) {\n    for (const c of [m.header, m.footer]) {\n      if (c) {\n        c.updateWidth('');\n        if (mark) {\n          c.columnDef.markForCheck();\n        }\n      }\n    }\n\n    // We don't handle groups because they are handled by `PblNgridComponent.resizeRows()`\n    // which set the width for each.\n  }\n}\n","import { PblBaseColumnDefinition, PblColumnDefinition, PblColumnGroupDefinition } from './types';\n\nconst RE_PARSE_STYLE_LENGTH_UNIT = /((?:\\d*\\.)?\\d+)(%|px)$/;\n\nexport function parseStyleWidth(exp: string): { value: number, type: 'px' | '%'} | undefined {\n  const match = RE_PARSE_STYLE_LENGTH_UNIT.exec(exp);\n  if (match) {\n    return { value: Number(match[1]), type: <any> match[2] };\n  }\n}\n\nexport function initDefinitions<T extends PblBaseColumnDefinition>(def: PblBaseColumnDefinition, target: T): void {\n  const copyKeys: Array<keyof PblBaseColumnDefinition> = ['id', 'label', 'css', 'minWidth', 'width', 'maxWidth', 'type'];\n  copyKeys.forEach( k => k in def && (target[k] = def[k]) );\n  if (def.data) {\n    target.data = Object.assign(target.data || {}, def.data);\n  }\n}\n\nexport function isColumnDefinition(obj: any): obj is PblColumnDefinition {\n  // TODO: Get rid of this duckt-type type matching. Accept solid instances in PblTable.columns instead of interfaces.\n  return !!obj.prop && !obj.hasOwnProperty('span');\n}\n\n\nexport function isColumnGroupDefinition(obj: any): obj is PblColumnGroupDefinition {\n  // TODO: Get rid of this duckt-type type matching. Accept solid instances in PblTable.columns instead of interfaces.\n  return !!obj.prop && obj.hasOwnProperty('span');\n}\n","import { TemplateRef } from '@angular/core';\n\nimport { PblNgridColumnDef } from '../directives';\nimport { PblNgridMetaCellContext } from '../context/types';\nimport { PblMetaColumnDefinition, PblColumnTypeDefinition } from './types';\nimport { parseStyleWidth, initDefinitions } from './utils';\n\nconst PBL_NGRID_META_COLUMN_MARK = Symbol('PblMetaColumn');\nconst CLONE_PROPERTIES: Array<keyof PblMetaColumn> = ['kind', 'rowIndex'];\n\nexport function isPblMetaColumn(def: PblMetaColumnDefinition): def is PblMetaColumn {\n  return def instanceof PblMetaColumn || def[PBL_NGRID_META_COLUMN_MARK] === true;\n}\n\nexport class PblMetaColumn implements PblMetaColumnDefinition {\n  //#region PblCdkVirtualScrollViewportComponentBaseColumnDefinition\n\n   /**\n   * A Unique ID for the column.\n   * The ID must be unique across all columns, regardless of the type.\n   * Columns with identical ID will share result in identical template.\n   *\n   * For example, having a header column and a footer column with the same id will result in the same cell presentation for both.\n   */\n  id: string;\n\n  label?: string;\n\n  /**\n   * The type of the values in this column.\n   * This is an additional level for matching columns to templates, grouping templates for a type.\n   */\n  type?: PblColumnTypeDefinition;\n\n  /**\n   * CSS class that get applied on the header and cell.\n   * You can apply unique header/cell styles using the element name.\n   */\n  css?: string;\n\n  /**\n   * The width in px or % in the following format: ##% or ##px\n   * Examples: '50%', '50px'\n   */\n  get width(): string { return this._width; }\n  set width(value: string) {\n    if (value !== this._width) {\n      this._parsedWidth = parseStyleWidth(this._width = value);\n      const isFixedWidth = this._parsedWidth && this._parsedWidth.type === 'px';\n      Object.defineProperty(this, 'isFixedWidth', { value: isFixedWidth, configurable: true });\n    }\n  }\n  /**\n   * This minimum width in pixels\n   * This is an absolute value, thus a number.\n   */\n  minWidth?: number;\n  /**\n   * This maximum width in pixels\n   * This is an absolute value, thus a number.\n   */\n  maxWidth?: number;\n\n  /**\n   * A place to store things...\n   * This must be an object, values are shadow-copied so persist data between multiple plugins.\n   */\n  data: any = {};\n  //#endregion PblCdkVirtualScrollViewportComponentBaseColumnDefinition\n\n  //#region PblMetaColumnDefinition\n\n  kind: 'header' | 'footer';\n\n  /**\n   * The index (zero based) of the header row this column is attached to, used for multi-header setup.\n   * When not set (undefined) the index is considered the LAST index.\n   *\n   * If you want to setup a multi header table with 2 header rows, set this to 0 for the first header row and for the 2nd header\n   * row do not set a rowIndex.\n   */\n  rowIndex: number;\n//#endregion PblMetaColumnDefinition\n\n  get parsedWidth(): { value: number; type: 'px' | '%' } | undefined { return this._parsedWidth; }\n\n  /**\n   * Used by pbl-ngrid to apply a custom header/footer cell template, or the default when not set.\n   * @internal\n   */\n  template: TemplateRef<PblNgridMetaCellContext<any>>;\n\n  /**\n   * When true indicates that the width is set with type pixels.\n   * @internal\n   */\n  readonly isFixedWidth?: boolean;\n\n  /**\n   * The column def for this column.\n   */\n  get columnDef(): PblNgridColumnDef<PblMetaColumn> { return this._columnDef; }\n\n  private _width?: string;\n  private _parsedWidth: ReturnType<typeof parseStyleWidth>;\n  private _columnDef: PblNgridColumnDef<PblMetaColumn>;\n  private defaultWidth = '';\n\n  constructor(def: PblMetaColumnDefinition) {\n    this[PBL_NGRID_META_COLUMN_MARK] = true;\n    initDefinitions(def, this);\n\n    for (const prop of CLONE_PROPERTIES) {\n      if (prop in def) {\n        this[prop as any] = def[prop]\n      }\n    }\n\n    if (!isPblMetaColumn(def)) {\n      if (typeof def.type === 'string') {\n        this.type = { name: def.type } as any;\n      }\n    }\n  }\n\n  static extendProperty(name: keyof PblMetaColumn): void {\n    if (CLONE_PROPERTIES.indexOf(name) === -1) {\n      CLONE_PROPERTIES.push(name);\n    }\n  }\n\n  attach(columnDef: PblNgridColumnDef<PblMetaColumn>): void {\n    this.detach();\n    this._columnDef = columnDef;\n    this.columnDef.updateWidth(this.width || this.defaultWidth);\n  }\n\n  detach(): void {\n    this._columnDef = undefined;\n  }\n\n  updateWidth(fallbackDefault: string): void {\n    this.defaultWidth = fallbackDefault || '';\n    if (this.columnDef) {\n      this.columnDef.updateWidth(this.width || fallbackDefault);\n    }\n  }\n}\n","import { PblNgridColumnDef } from '../directives';\nimport { PblBaseColumnDefinition, PblColumnGroupDefinition } from './types';\nimport { PblMetaColumn } from './meta-column';\nimport { PblColumn } from './column';\n\nconst PBL_NGRID_COLUMN_GROUP_MARK = Symbol('PblColumnGroup');\nconst CLONE_PROPERTIES: Array<keyof PblColumnGroup> = [];\n\nexport function isPblColumnGroup(def: PblColumnGroupDefinition): def is PblColumnGroup {\n  return def instanceof PblColumnGroup || def[PBL_NGRID_COLUMN_GROUP_MARK] === true;\n}\n\nfunction getId(value: string | { id: string }): string {\n  return typeof value === 'string' ? value : value.id;\n}\n\nexport class PblColumnGroupStore {\n  get all(): PblColumnGroup[] { return this._all; }\n\n  private store = new Map<string, { group: PblColumnGroup; activeColumns: Set<string>; }>();\n  private _all: PblColumnGroup[] = [];\n\n  /**\n   * Attach a column to a group.\n   */\n  attach(group: string | PblColumnGroup, column: string | PblColumn): boolean {\n    const g = this._find(group);\n    if (g) {\n      g.activeColumns.add(getId(column));\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Detach a column from a group.\n   */\n  detach(group: string | PblColumnGroup, column: string | PblColumn): boolean {\n    const g = this._find(group);\n    if (g) {\n      return g.activeColumns.delete(getId(column));\n    }\n    return false;\n  }\n\n  /**\n   * Returns a list of `PblColumnGroup` that does not have columns attached.\n   */\n  findGhosts(): PblColumnGroup[] {\n    return Array.from(this.store.values())\n      .filter( item => item.activeColumns.size === 0 )\n      .map( item => item.group );\n  }\n\n  add(group: PblColumnGroup): void {\n    this.store.set(group.id, { group, activeColumns: new Set<string>() });\n    this.updateAll();\n  }\n\n  remove(group: string | PblColumnGroup): boolean {\n    const g = this.find(group);\n    if (g && this.store.delete(g.id)) {\n      this.updateAll();\n      return true;\n    }\n    return false;\n  }\n\n  find(group: string | PblColumnGroup): PblColumnGroup | undefined {\n    const g = this._find(group);\n    if (g) {\n      return g.group;\n    }\n  }\n\n  clone(): PblColumnGroupStore {\n    const c = new PblColumnGroupStore();\n    c.store = new Map<string, { group: PblColumnGroup; activeColumns: Set<string>; }>(this.store);\n    c.updateAll();\n    return c;\n  }\n\n  private _find(group: string | PblColumnGroup): { group: PblColumnGroup; activeColumns: Set<string>; } | undefined {\n    return this.store.get(getId(group));\n  }\n\n  private updateAll(): void {\n    this._all = Array.from(this.store.values()).map( item => item.group );\n  }\n}\n\nexport class PblColumnGroup extends PblMetaColumn implements PblColumnGroupDefinition {\n\n  //#region PblColumnGroupDefinition\n  /**\n   * The table's column that is the first child column for this group.\n   */\n  prop: string;\n  /**\n   * The total span of the group (excluding the first child - i.e. prop).\n   * The span and prop are used to get the child columns of this group.\n   * The span is not dynamic, once the columns are set they don't change.\n   *\n   * For example, if a we have a span of 2 and the column at the 2nd position is hidden it will still count as\n   * being spanned although the UI will span only 1 column... (because the 2nd is hidden...)\n   */\n  span: number;\n  //#endregion PblColumnGroupDefinition\n\n  /**\n   * Returns the visible state of the column.\n   * The column is visible if AT LEAST ONE child column is visible (i.e. not hidden)\n   */\n  get isVisible(): boolean {\n    return this.columns.some( c => !c.hidden );\n  }\n    /**\n   * The column def for this column.\n   */\n  columnDef: PblNgridColumnDef<PblColumnGroup>;\n\n  /**\n   * When set, this column is a cloned column of an existing column caused by a split.\n   * @internal\n   */\n  slaveOf?: PblColumnGroup;\n\n  /** @internal */\n  readonly columns: PblColumn[];\n\n  constructor(def: PblColumnGroup | PblColumnGroupDefinition, columns: PblColumn[], public readonly placeholder = false) {\n    super(isPblColumnGroup(def)\n      ? def\n      : { id: `group-${def.prop}-span-${def.span}-row-${def.rowIndex}`, kind: 'header' as 'header', ...(def as any) }\n    );\n    this[PBL_NGRID_COLUMN_GROUP_MARK] = true;\n    this.prop = def.prop;\n    this.span = def.span;\n    this.columns = columns;\n    for (const c of columns) {\n      c.markInGroup(this);\n    }\n\n    for (const prop of CLONE_PROPERTIES) {\n      if (prop in def) {\n        this[prop as any] = def[prop]\n      }\n    }\n  }\n\n  static extendProperty(name: keyof PblColumnGroup): void {\n    if (CLONE_PROPERTIES.indexOf(name) === -1) {\n      CLONE_PROPERTIES.push(name);\n    }\n  }\n\n  createSlave(columns: PblColumn[] = []): PblColumnGroup {\n    const slave = new PblColumnGroup(this, columns);\n    slave.id += '-slave' + Date.now();\n    slave.slaveOf = this;\n    slave.template = this.template;\n    return slave;\n  }\n\n  replace(newColumn: PblColumn): boolean {\n    const { id } = newColumn;\n    const idx = this.columns.findIndex( c => c.id === id );\n    if (idx > -1) {\n      this.columns.splice(idx, 1, newColumn);\n      return true;\n    }\n    return false;\n  }\n}\n","import { TemplateRef } from '@angular/core';\n\nimport { DataSourceColumnPredicate, PblNgridSorter } from '../../data-source/types';\nimport { PblNgridColumnDef } from '../directives';\nimport { deepPathGet, deepPathSet } from '../utils';\nimport { PblColumnSizeInfo } from '../types';\nimport { PblNgridMetaCellContext, PblNgridCellContext } from '../context/types';\nimport { PblColumnDefinition, PblColumnTypeDefinition } from './types';\nimport { initDefinitions, parseStyleWidth } from './utils';\nimport { PblColumnGroup, PblColumnGroupStore } from './group-column';\n\nconst PBL_NGRID_COLUMN_MARK = Symbol('PblColumn');\nconst CLONE_PROPERTIES: Array<keyof PblColumn> = ['pIndex', 'transform', 'filter', 'sort', 'alias', 'headerType', 'footerType', 'pin'];\n\nexport function isPblColumn(def: any): def is PblColumn {\n  return def instanceof PblColumn || def[PBL_NGRID_COLUMN_MARK] === true;\n}\n\nexport class PblColumn implements PblColumnDefinition {\n  id: string;\n\n  /**\n   * When set, defines this column as the primary index of the data-set with all values in this column being unique.\n   */\n  pIndex?: boolean;\n\n  label?: string;\n\n  /**\n   * CSS class that get applied on the header and cell.\n   * You can apply unique header/cell styles using the element name.\n   */\n  css?: string;\n\n  /**\n   * The width in px or % in the following format: ##% or ##px\n   * Examples: '50%', '50px'\n   */\n  get width(): string { return this._width; }\n  set width(value: string) {\n    if (value !== this._width) {\n      this._parsedWidth = parseStyleWidth(this._width = value);\n      const isFixedWidth = this._parsedWidth && this._parsedWidth.type === 'px';\n      Object.defineProperty(this, 'isFixedWidth', { value: isFixedWidth, configurable: true });\n    }\n  }\n  /**\n   * This minimum width in pixels\n   * This is an absolute value, thus a number.\n   */\n  minWidth?: number;\n  /**\n   * This maximum width in pixels\n   * This is an absolute value, thus a number.\n   */\n  maxWidth?: number;\n\n  /**\n   * A place to store things...\n   * This must be an object, values are shadow-copied so persist data between multiple plugins.\n   */\n  data: any = {};\n\n  get parsedWidth(): { value: number; type: 'px' | '%' } | undefined { return this._parsedWidth; }\n\n  /**\n   * The property to display (from the row element)\n   * You can use dot notation to display deep paths.\n   */\n  prop: string;\n\n  /**\n   * A path to a nested object, relative to the row element.\n   * The table will display `prop` from the object referenced by `path`.\n   *\n   * You can also use dot notation directly from `prop`.\n   *\n   * Example:\n   * prop: \"street\"\n   * path: [ \"myInstance\", \"user\", \"address\"\n   *\n   * is identical to:\n   * prop: \"myInstance.user.address.street\"\n   *\n   */\n  path?: string[];\n\n  /**\n   * The type of the values in this column.\n   * This is an additional level for matching columns to templates, grouping templates for a type.\n   */\n  type?: PblColumnTypeDefinition;\n  headerType?: PblColumnTypeDefinition;\n  footerType?: PblColumnTypeDefinition;\n\n  sort?: boolean | PblNgridSorter;\n\n  /**\n   * A custom predicate function to filter rows using the current column.\n   *\n   * Valid only when filtering by value.\n   * See `PblDataSource.setFilter` for more information.\n   */\n  filter?: DataSourceColumnPredicate;\n\n  /**\n   * Marks the table as editable. An editable column also requires an edit template to qualify as editable, this flag alone is not enough.\n   *\n   * Note that this flag only effect the CSS class added to the cell.\n   */\n  editable: boolean;\n\n  pin: 'start' | 'end' | undefined;\n\n  // TODO(1.0.0): remove\n  /** @deprecated BREAKING CHANGE 1.0.0 - Use `alias` instead. */\n  get sortAlias(): string | undefined { return this.alias; }\n  set sortAlias(value: string) { this.alias = value; }\n\n  /**\n   * An alias used to identify the column.\n   * Useful when the server provides sort/filter metadata that does not have a 1:1 match with the column names.\n   * e.g. Deep path props, property name convention mismatch, etc...\n   */\n  alias?: string;\n\n  /**\n   * Optional transformer that control the value output from the combination of a column and a row.\n   * The value returned from this transformer will be returned from `PblColumn.getValue`\n   */\n  transform?: (value: any, row?: any, col?: PblColumn) => any;\n\n  /**\n   * The original value of `prop`.\n   * @internal\n   */\n  orgProp: string;\n\n  /**\n   * Used by pbl-ngrid to apply custom cell template, or the default when not set.\n   * @internal\n   */\n  cellTpl: TemplateRef<PblNgridCellContext<any>>;\n    /**\n   * Used by pbl-ngrid to apply custom cell template, or the default when not set.\n   * @internal\n   */\n  editorTpl: TemplateRef<PblNgridCellContext<any>>;\n  /**\n   * Used by pbl-ngrid to apply a custom header cell template, or the default when not set.\n   * @internal\n   */\n  headerCellTpl: TemplateRef<PblNgridMetaCellContext<any>>;\n  /**\n   * Used by pbl-ngrid to apply a custom footer cell template, or the default when not set.\n   * @internal\n   */\n  footerCellTpl: TemplateRef<PblNgridMetaCellContext<any>>;\n\n  /**\n   * Used by the library as a logical flag representing the column hidden state.\n   * This flag does not effect the UI, changing it will not change he hidden state in the UI.\n   * Do not set this value manually.\n   * @internal\n   */\n  hidden: boolean;\n\n  /**\n   * When true indicates that the width is set with type pixels.\n   * @internal\n   */\n  readonly isFixedWidth?: boolean;\n\n  /**\n   * An on-demand size info object, populated by `PblColumnSizeObserver`\n   * @internal\n   */\n  sizeInfo?: PblColumnSizeInfo;\n\n  /** @internal */\n  maxWidthLock: boolean;\n\n  /**\n   * The column def for this column.\n   */\n  get columnDef(): PblNgridColumnDef<PblColumn> { return this._columnDef; }\n\n  get groups(): string[] { return Array.from(this._groups.values()); }\n\n  /** @internal */\n  public readonly groupStore: PblColumnGroupStore;\n\n  private _width?: string;\n  private _parsedWidth: ReturnType<typeof parseStyleWidth>;\n\n  private _columnDef: PblNgridColumnDef<PblColumn>;\n  private defaultWidth = '';\n\n  /**\n   * Groups that this column belongs to.\n   * WARNING: DO NOT ADD/REMOVE GROUPS DIRECTLY, USE markInGroup/markNotInGroup.\n   */\n  private _groups = new Set<string>();\n\n  constructor(def: PblColumn | PblColumnDefinition, groupStore?: PblColumnGroupStore) {\n    this[PBL_NGRID_COLUMN_MARK] = true;\n\n    if (isPblColumn(def)) {\n      initDefinitions(def, this);\n      this.prop = def.prop;\n      this.path = def.path;\n      this.orgProp = def.orgProp;\n      this.groupStore = groupStore || def.groupStore;\n      this._groups = new Set<string>(def._groups);\n      for (const id of Array.from(def._groups.values())) {\n        const g = this.groupStore.find(id);\n        if (g) {\n          this.markInGroup(g);\n          g.replace(this);\n        }\n      }\n    } else {\n      const path = def.path || def.prop.split('.');\n      const prop = def.path ? def.prop : path.pop();\n\n      def = Object.create(def);\n      def.id = def.id || def.prop || def.label;\n      def.label = 'label' in def ? def.label : prop;\n\n      if (typeof def.type === 'string') {\n        def.type = { name: def.type } as any;\n      }\n      if (typeof def.headerType === 'string') {\n        def.headerType = { name: def.headerType } as any;\n      }\n      if (typeof def.footerType === 'string') {\n        def.footerType = { name: def.footerType } as any;\n      }\n\n      initDefinitions(def, this);\n\n      this.groupStore = groupStore || new PblColumnGroupStore();\n      this.prop = prop;\n      this.orgProp = def.prop;\n      if (path.length) {\n        this.path = path;\n      }\n    }\n\n    for (const prop of CLONE_PROPERTIES) {\n      if (prop in def) {\n        this[prop as any] = def[prop]\n      }\n    }\n  }\n\n  static extendProperty(name: keyof PblColumn): void {\n    if (CLONE_PROPERTIES.indexOf(name) === -1) {\n      CLONE_PROPERTIES.push(name);\n    }\n  }\n\n  attach(columnDef: PblNgridColumnDef<PblColumn>): void {\n    this.detach();\n    this._columnDef = columnDef;\n    if (this.defaultWidth) {\n      this.columnDef.updateWidth(this.width || this.defaultWidth);\n    }\n  }\n\n  detach(): void {\n    this._columnDef = undefined;\n  }\n\n  setDefaultWidth(defaultWidth: string): void {\n    this.defaultWidth = defaultWidth;\n  }\n\n  updateWidth(markForCheck: boolean, width?: string): void {\n    if (width) {\n      this.width = width;\n    }\n    const { columnDef } = this;\n    if (columnDef) {\n      columnDef.updateWidth(this.width || this.defaultWidth || '');\n      if (markForCheck) {\n        columnDef.markForCheck();\n      }\n    }\n  }\n\n  /**\n   * Get the value this column points to in the provided row\n   */\n  getValue<T = any>(row: any): T {\n    if (this.transform) {\n      return this.transform(deepPathGet(row, this), row, this);\n    }\n    return deepPathGet(row, this);\n  }\n\n  /**\n   * Set a value in the provided row where this column points to\n   */\n  setValue(row: any, value: any): void {\n    return deepPathSet(row, this, value);\n  }\n\n  /**\n   * Mark's that this column belong to the provided group.\n   * \\> Note that this internal to the column and does not effect the group in any way.\n   */\n  markInGroup(g: PblColumnGroup): void {\n    this.groupStore.attach(g, this);\n    this._groups.add(g.id);\n  }\n\n  /**\n   * Mark's that this column does not belong to the provided group.\n   * \\> Note that this internal to the column and does not effect the group in any way.\n   */\n  markNotInGroup(g: PblColumnGroup): boolean {\n    this.groupStore.detach(g, this);\n    return this._groups.delete(g.id);\n  }\n\n  isInGroup(g: PblColumnGroup): boolean {\n    return this._groups.has(g.id);\n  }\n\n  getGroupOfRow(rowIndex: number): PblColumnGroup | undefined {\n    const groupIds = this.groups;\n    for (const id of groupIds) {\n      const g = this.groupStore.find(id);\n      if (g && g.rowIndex === rowIndex) {\n        return g;\n      }\n    }\n  }\n\n  groupLogic(columnGroups: [PblColumnGroup, PblColumnGroup, PblColumnGroup], groupExists: boolean): PblColumnGroup {\n    const [gPrev, gCurr, gNext] = columnGroups;\n\n    // STATE: This column has same group of previous column, nothing to do.\n    if (gCurr === gPrev) {\n      return gCurr;\n    }\n\n    // STATE: The group exists in one of the columns BUT NOT in the LAST COLUMN (i.e: Its a slave split)\n    if (groupExists) {\n      // If the previous sibling group is a slave and this group is the origin of the slave, convert this group to the slave.\n      if (gPrev && gCurr === gPrev.slaveOf) {\n        return gPrev;\n      }\n      if (gNext && gCurr === gNext.slaveOf) {\n        return gNext;\n      }\n      // Otherwise create the slave.\n      const g = gCurr.createSlave([this]);\n      this.groupStore.add(g);\n\n      // If the current group is a placeholder and either the previous OR next sibling group is a placeholder as well\n      // we want to group them together, although they are not related, because they both have identical headers (empty header).\n      // Note that we still create the salve, we just don't use it.\n      if (gCurr.placeholder) {\n        const prevPH = gPrev && gPrev.placeholder;\n        const nextPH = gNext && gNext.slaveOf && gNext.placeholder;\n        const groupWithPlaceholder = prevPH ? gPrev : nextPH ? gNext : undefined;\n        // const groupWithPlaceholder = prevPH && gPrev;\n        if (groupWithPlaceholder) {\n          return groupWithPlaceholder;\n        }\n      }\n\n      return g;\n    }\n    // STATE: The group IS a slave and it is set AFTER an item that belongs to the group it is slave of.\n    else if (gCurr.slaveOf && gPrev) {\n      if (gCurr.slaveOf === gPrev) {\n        return gCurr.slaveOf;\n      }\n      if (gCurr.slaveOf === gPrev.slaveOf) {\n        return gPrev;\n      }\n    }\n    // STATE: The group IS a slave and it is set BEFORE an item that belongs to the group it is slave of.\n    else if (gCurr.slaveOf && gNext) {\n      if (gCurr.slaveOf === gNext) {\n        return gCurr.slaveOf;\n      }\n    }\n    return gCurr;\n  }\n\n  /**\n   * Calculates if the column width is locked by a maximum by checking if the given width is equal to the max width.\n   * If the result of the calculation (true/false) does not equal the previous lock state it will set the new lock state\n   * and return true.\n   * Otherwise return false.\n   * @internal\n   */\n  checkMaxWidthLock(actualWidth: number): boolean {\n    if (actualWidth === this.maxWidth) {\n      if (!this.maxWidthLock) {\n        this.maxWidthLock = true;\n        return true;\n      }\n    } else if (this.maxWidthLock) {\n      this.maxWidthLock = false;\n      return true;\n    }\n    return false;\n  }\n\n}\n","import {\n  PblBaseColumnDefinition,\n  PblColumnDefinition,\n  PblColumnGroupDefinition,\n  PblMetaColumnDefinition,\n  PblNgridColumnDefinitionSet,\n  PblNgridColumnSet,\n  PblMetaRowDefinitions\n} from './types';\nimport { PblMetaColumn } from './meta-column';\nimport { PblColumn } from './column';\nimport { PblColumnGroup, PblColumnGroupStore } from './group-column';\n\nexport type COLUMN = PblMetaColumn | PblColumn | PblColumnGroup;\n\nexport class PblColumnFactory {\n  private _raw: PblNgridColumnDefinitionSet = { table: { cols: [] }, header: [], footer: [], headerGroup: [] };\n  private _defaults = {\n    table: {} as Partial<PblColumnDefinition>,\n    header: {} as Partial<PblMetaColumnDefinition>,\n    footer: {} as Partial<PblMetaColumnDefinition>,\n  };\n\n  private _currentHeaderRow = 0;\n  private _currentFooterRow = 0;\n\n  get currentHeaderRow(): number { return this._currentHeaderRow; }\n  get currentFooterRow(): number { return this._currentFooterRow; }\n\n  static fromDefinitionSet(defs: PblNgridColumnDefinitionSet): PblColumnFactory {\n    const f = new PblColumnFactory();\n    Object.assign(f._raw, defs);\n    return f;\n  }\n\n  build(): PblNgridColumnSet {\n    const { _defaults, _raw } = this;\n\n    const groupStore = new PblColumnGroupStore();\n\n    const table: PblNgridColumnSet['table'] = {\n      header: _raw.table.header,\n      footer: _raw.table.footer,\n      cols: _raw.table.cols.map( d => new PblColumn({ ..._defaults.table, ...d }, groupStore)),\n    };\n    const header = _raw.header.map( h => ({\n      rowIndex: h.rowIndex,\n      rowClassName: h.rowClassName,\n      type: h.type || 'fixed',\n      cols: h.cols.map( c => new PblMetaColumn( { ..._defaults.header, ...c } )),\n    }));\n    const footer = _raw.footer.map( f => ({\n      rowIndex: f.rowIndex,\n      rowClassName: f.rowClassName,\n      type: f.type || 'fixed',\n      cols: f.cols.map( c => new PblMetaColumn({ ..._defaults.footer, ...c }) )\n    }));\n    const headerGroup = _raw.headerGroup.map( hg => ({\n      rowIndex: hg.rowIndex,\n      rowClassName: hg.rowClassName,\n      type: hg.type || 'fixed',\n      cols: this.buildHeaderGroups(hg.rowIndex, hg.cols, table.cols).map( g => {\n        groupStore.add(g);\n        return g;\n      }),\n    }));\n\n    return {\n      groupStore,\n      table,\n      header,\n      footer,\n      headerGroup,\n    };\n  }\n\n  /**\n   * Set the default column definition for header/footer columns.\n   */\n  default(def: Partial<PblMetaColumnDefinition>, type: 'header' | 'footer'): this;\n  /**\n   * Set the default column definition for table columns.\n   */\n  default(def: Partial<PblColumnDefinition>, type?: 'table'): this;\n  default(def: Partial<PblColumnDefinition> | Partial<PblMetaColumnDefinition>, type: 'table' | 'header' | 'footer' = 'table'): this {\n    this._defaults[type] = def;\n    return this;\n  }\n\n  /**\n   * Add table columns.\n   *\n   * Table columns are mandatory, they are the columns that define the structure of the data source.\n   *\n   * Each column will usually point to property on the row, although you can create columns that does not\n   * exist on the row and handle their rendering with a cell template.\n   *\n   * Each table column is also a header column and a footer column that display.\n   * The header and footer are automatically created, If you wish not to show them set headerRow/footerRow to false in PblTable.\n   *\n   */\n  table(rowOptions: { header?: PblMetaRowDefinitions; footer?: PblMetaRowDefinitions }, ...defs: PblColumnDefinition[]): this;\n  table(...defs: PblColumnDefinition[]): this;\n  table(...defs: Array<{ header?: PblMetaRowDefinitions; footer?: PblMetaRowDefinitions } | PblColumnDefinition>): this {\n    const rowOptions: { header?: PblMetaRowDefinitions; footer?: PblMetaRowDefinitions } = (defs[0] as any).prop ? {} : defs.shift() as any;\n    const { header, footer } = rowOptions;\n    Object.assign(this._raw.table, { header, footer });\n    this._raw.table.cols.push(...defs as PblColumnDefinition[]);\n    return this;\n  }\n\n  /**\n   * Add a new header row with header columns.\n   * Creates an additional header row in position `currentHeaderRow` using the provided header column definitions.\n   * Each definition represent a cell, the cell's does not have to align with the layout of table columns.\n   *\n   * All header row will position BEFORE the table column header row.\n   * Header columns are optional.\n   * Each call to `header()` will create a new row, incrementing the `currentHeaderRow`.\n   *\n   * @remarks\n   * Example:\n   * ```js\n   *   factory.table(1, 2, 3)\n   *     .header(a, b, c).header(d, e, f);\n   * ```\n   *\n   * will result in:\n   *   header1 -\\>  a b c\n   *   header2 -\\>  d e f\n   *   table   -\\>  1 2 3\n   */\n  header(rowOptions: PblMetaRowDefinitions, ...defs: Array<Pick<PblMetaColumnDefinition, 'id'> & Partial<PblMetaColumnDefinition> & PblBaseColumnDefinition>): this;\n  header(...defs: Array<Pick<PblMetaColumnDefinition, 'id'> & Partial<PblMetaColumnDefinition> & PblBaseColumnDefinition>): this;\n  header(...defs: Array<PblMetaRowDefinitions | Pick<PblMetaColumnDefinition, 'id'> & Partial<PblMetaColumnDefinition> & PblBaseColumnDefinition>): this {\n    const rowIndex = this._currentHeaderRow++;\n    const rowOptions = this.processRowOptions(defs);\n    const rowClassName = this.genRowClass(rowOptions, rowIndex);\n\n    const headers = defs.map( (d: Pick<PblMetaColumnDefinition, 'id'> & Partial<PblMetaColumnDefinition> & PblBaseColumnDefinition) => {\n      const def: PblMetaColumnDefinition = {\n        id: d.id,\n        kind: 'header',\n        rowIndex\n      };\n      return Object.assign(def, d);\n    });\n\n    this._raw.header.push({\n      rowIndex,\n      rowClassName,\n      cols: headers,\n      type: (rowOptions && rowOptions.type) || 'fixed',\n    });\n    return this;\n  }\n\n  /**\n   * Add a new footer row with footer columns.\n   * Creates an additional footer row in position `currentFooterRow` using the provided footer column definitions.\n   * Each definition represent a cell, the cell's does not have to align with the layout of table columns.\n   *\n   * All footer row will position AFTER the table column footer row.\n   * Footer columns are optional.\n   * Each call to `footer()` will create a new row, incrementing the `currentFooterRow`.\n   *\n   * @remarks\n   * Example:\n   * ```js\n   *   factory.table(1, 2, 3)\n   *     .footer(a, b, c).footer(d, e, f);\n   * ```\n   *\n   * will result in:\n   *   table   -\\>  1 2 3\n   *   footer1 -\\>  a b c\n   *   footer2 -\\>  d e f\n   */\n  footer(rowOptions: PblMetaRowDefinitions, ...defs: Array<Pick<PblMetaColumnDefinition, 'id'> & Partial<PblMetaColumnDefinition> & PblBaseColumnDefinition>): this;\n  footer(...defs: Array<Pick<PblMetaColumnDefinition, 'id'> & Partial<PblMetaColumnDefinition> & PblBaseColumnDefinition>): this;\n  footer(...defs: Array<PblMetaRowDefinitions | Pick<PblMetaColumnDefinition, 'id'> & Partial<PblMetaColumnDefinition> & PblBaseColumnDefinition>): this {\n    const rowIndex = this._currentFooterRow++;\n    const rowOptions = this.processRowOptions(defs);\n    const rowClassName = this.genRowClass(rowOptions, rowIndex);\n\n    const footers = defs.map( (d: Pick<PblMetaColumnDefinition, 'id'> & Partial<PblMetaColumnDefinition> & PblBaseColumnDefinition) => {\n      const def: PblMetaColumnDefinition = {\n        id: d.id,\n        kind: 'footer',\n        rowIndex\n      };\n      return Object.assign(def, d);\n    });\n\n    this._raw.footer.push({\n      rowIndex,\n      rowClassName,\n      cols: footers,\n      type: (rowOptions && rowOptions.type) || 'fixed',\n    });\n    return this;\n  }\n\n  /**\n   * Add a new header row with header group columns.\n   * A header group column is a columns is a header columns that spans one or more columns.\n   *\n   * Create an additional header row in position `currentHeaderRow` using the provided header column definitions.\n   * Each definition represent a cell, the cell's does not have to align with the layout of table columns.\n   *\n   * All header row will position BEFORE the table column header row.\n   * Header columns are optional.\n   * Each call to `header()` will create a new row, incrementing the `currentHeaderRow`.\n   *\n   * @remarks\n   * Example:\n   * ```js\n   *   factory.table(1, 2, 3)\n   *     .header(a, b, c).header(d, e, f);\n   * ```\n   *\n   * will result in:\n   *   header1 -\\>  a b c\n   *   header2 -\\>  d e f\n   *   table   -\\>  1 2 3\n   */\n  headerGroup(rowOptions: PblMetaRowDefinitions, ...defs: Array<Pick<PblColumnGroupDefinition, 'prop'> & Partial<PblColumnGroupDefinition>>): this;\n  headerGroup(...defs: Array<Pick<PblColumnGroupDefinition, 'prop'> & Partial<PblColumnGroupDefinition>>): this;\n  headerGroup(...defs: Array<PblMetaRowDefinitions | ( Pick<PblColumnGroupDefinition, 'prop'> & Partial<PblColumnGroupDefinition>) >): this {\n    const rowIndex = this._currentHeaderRow++;\n    const rowOptions = this.processRowOptions(defs, 'prop');\n    const rowClassName = this.genRowClass(rowOptions, rowIndex);\n\n    const headerGroups: any = defs.map( d => Object.assign({ rowIndex }, d) );\n\n    this._raw.headerGroup.push({\n      rowIndex,\n      rowClassName,\n      cols: headerGroups,\n      type: (rowOptions && rowOptions.type) || 'fixed',\n    });\n\n    return this;\n  }\n\n  private processRowOptions(defs: any[], mustHaveProperty: string = 'id'): PblMetaRowDefinitions {\n    return defs[0][mustHaveProperty] ? undefined : defs.shift();\n  }\n\n  private genRowClass(rowOptions: { rowClassName?: string }, fallbackRowIndex: number): string {\n    return (rowOptions && rowOptions.rowClassName) || `pbl-ngrid-row-index-${fallbackRowIndex.toString()}`;\n  }\n\n  private buildHeaderGroups(rowIndex: number, headerGroupDefs: PblColumnGroupDefinition[], table: PblColumn[]): PblColumnGroup[] {\n    const headerGroup: PblColumnGroup[] = [];\n\n    // Building of header group rows requires some work.\n    // The user defined groups might not cover all columns, creating gaps between group columns so we need to add placeholder groups to cover these gaps.\n    // Moreover, the user might not specify a `prop`, which we might need to complete.\n    // We do that for each header group row.\n    //\n    // The end goal is to return a list of `PblColumnGroup` that span over the entire columns of the table.\n    //\n    // The logic is as follows:\n    // For each column in the table, find a matching column group - a group pointing at the column by having the same `prop`\n    // If found, check it's span and skip X amount of columns where X is the span.\n    // If a span is not defined then treat it as a greedy group that spans over all columns ahead until the next column that has a matching group column.\n    //\n    // If a column does not have a matching group column, search for group columns without a `prop` specified and when found set their `prop` to the current\n    // column so we will now use them as if it's a user provided group for this column...\n    //\n    // If no group columns exists (or left), we create an ad-hoc group column and we will now use them as if it's a user provided group for this column...\n    //\n    const tableDefs = table.slice();\n    const defs = headerGroupDefs.slice();\n\n    for (let i = 0, len = tableDefs.length; i < len; i++) {\n      const orgProp = tableDefs[i].orgProp;\n      const idx = defs.findIndex( d => d.prop === orgProp);\n      const columnGroupDef: PblColumnGroupDefinition = idx !== -1\n        ? defs.splice(idx, 1)[0]\n        : defs.find( d => !d.prop ) || { prop: orgProp, rowIndex, span: undefined }\n      ;\n\n      const placeholder = idx === -1 && !!columnGroupDef.prop;\n\n      columnGroupDef.prop = orgProp;\n      columnGroupDef.rowIndex = rowIndex;\n\n      let take = columnGroupDef.span;\n      if (! (take >= 0) ) {\n        take = 0;\n        for (let z = i+1; z < len; z++) {\n          if (defs.findIndex( d => d.prop === tableDefs[z].orgProp) === -1) {\n            take++;\n          }\n          else {\n            break;\n          }\n        }\n      }\n      columnGroupDef.span = take;\n      const group = new PblColumnGroup(columnGroupDef, tableDefs.slice(i, i + take + 1), placeholder);\n      headerGroup.push(group);\n      i += take;\n    }\n\n    return headerGroup;\n  }\n}\n\nexport function columnFactory(): PblColumnFactory {\n  return new PblColumnFactory()\n}\n","import { PblColumn } from '../columns';\n\n/**\n * A column width object representing the relative column using a combination of percentage and pixels.\n *\n * The percentage represent the total width of the column\n * The pixels represent the total fixed width, in pixels, that other columns occupy (these are columns with absolute width set).\n *\n * In a DOM element, the `ColumnWidth` object is represented via the `width` style property\n * and the value is set using the `calc()` CSS function: `width: calc({pct}% - {px}px);`.\n *\n * For example, the `ColumnWidth` object  `{ pct: 33, px: 25 }` is translated to `width: calc(33% - 25px);`\n *\n * @internal\n */\nexport interface ColumnWidth {\n  pct: number;\n  px: number;\n}\n\n/**\n * A column width calculator that, based on all of the columns, calculates the default column width\n * and minimum required row width.\n *\n * The default column width is the width for all columns that does not have a width setting defined.\n * In addition, a `minimumRowWidth` is calculated, which represents the minimum width required width of the row, i.e. table.\n *\n * The `StaticColumnWidthLogic` does not take into account real-time DOM measurements (especially box-model metadata), hence \"static\".\n * It performs the calculation based on \"dry\" `PblColumn` metadata input from the user.\n *\n * The `StaticColumnWidthLogic` is less accurate and best used as a measurement baseline followed by a more accurate calculation.\n * This is why it outputs a default column width and not a column specific width.\n */\nexport class StaticColumnWidthLogic {\n  private _agg = {\n    pct: 0,          // total agg fixed %\n    px: 0,           // total agg fixed px\n    minRowWidth: 0,  // total agg of min width\n    pctCount: 0,     // total columns with fixed %\n    pxCount: 0,      // total columns with fixed px\n    count: 0         // total columns without a fixed value\n  }\n\n  get minimumRowWidth(): number { return this._agg.minRowWidth; }\n\n  /**\n   * Returns the calculated default width for a column.\n   * This is the width for columns that does not have a specific width, adjusting them to fit the table.\n   * It's important to run this method AFTER aggregating all columns through `addColumn()`.\n   * The result contains 2 values, pct and px.\n   * pct is the total width in percent that the column should spread taking into account columns with fixed % width.\n   * px is the total width in pixels that the column should shrink taking into account columns with fixed pixel width.\n   *\n   * The algorithm is simple:\n   *  1) Sum all columns with fixed percent width\n   *  2) From the entire row width (100%) deduct the total fixed width (step 1).\n   *     This result represents the % left for all columns without a fixed width (percent and pixel).\n   *  3) Sum all columns with fixed pixel width.\n   *     The result represent the total amount of width in pixel taken by columns with fixed width.\n   *  4) Count all the columns without a fixed width.\n   *\n   *  For 2 & 3 we get values that we need to spread even between all of the columns without fixed width (percent and pixel).\n   *  The exact width is the total percent left (2) minus the total width in pixel taken by columns with fixed with.\n   *  We now need to divide the result from 2 & 3 by the result from 4.\n   *\n   * Both values should be used together on the `width` style property using the `calc` function:\n   * e.g.: `calc(${pct}% - ${px}px)`\n   *\n   * This value is calculated every time it is called, use it once all columns are added.\n   */\n  get defaultColumnWidth(): ColumnWidth {\n    const agg = this._agg;\n    const pct = (100 - agg.pct) / agg.count;\n    const px = agg.px / agg.count;\n    return { pct, px };\n  }\n\n  addColumn(column: PblColumn): void {\n    const agg = this._agg;\n    const width = column.parsedWidth;\n\n    let minWidth = column.minWidth || 0;\n\n    if (width) {\n      switch (width.type) {\n        case '%':\n          agg.pctCount += 1;\n          agg.pct += width.value;\n          break;\n        case 'px':\n          agg.pxCount += 1;\n          agg.px += width.value;\n          minWidth = width.value;\n          break;\n        default:\n          throw new Error(`Invalid width \"${column.width}\" in column ${column.prop}. Valid values are ##% or ##px (50% / 50px)`);\n      }\n    } else if (column.maxWidthLock) {\n      agg.pxCount += 1;\n      agg.px += column.maxWidth;\n    } else {\n      agg.count += 1;\n    }\n    agg.minRowWidth += minWidth;\n  }\n\n}\n","import { isDevMode } from '@angular/core';\nimport { PblNgridColumnDefinitionSet, PblNgridColumnSet } from './types';\nimport { PblMetaColumn } from './meta-column';\nimport { PblColumn } from './column';\nimport { PblColumnSet, PblMetaRowDefinitions, PblMetaColumnDefinition, PblColumnGroupDefinition } from './types';\nimport { PblColumnGroup, PblColumnGroupStore } from './group-column';\nimport { StaticColumnWidthLogic } from '../col-width-logic/static-column-width';\nimport { resetColumnWidths } from '../utils/helpers';\nimport { PblColumnFactory } from './factory';\n\nexport interface PblMetaColumnStore {\n  id: string;\n  header?: PblMetaColumn;\n  footer?: PblMetaColumn;\n  headerGroup?: PblColumnGroup;\n  footerGroup?: PblColumnGroup;\n}\n\nexport interface PblColumnStoreMetaRow {\n  rowDef: PblColumnSet<PblMetaColumnDefinition | PblColumnGroupDefinition>,\n  keys: string[];\n  isGroup?: boolean;\n}\n\nexport class PblColumnStore {\n  metaColumnIds: { header: Array<PblColumnStoreMetaRow>; footer: Array<PblColumnStoreMetaRow>; };\n  metaColumns: PblMetaColumnStore[];\n  columnIds: string[];\n  columns: PblColumn[];\n  allColumns: PblColumn[];\n  headerColumnDef: PblMetaRowDefinitions;\n  footerColumnDef: PblMetaRowDefinitions;\n\n  get primary(): PblColumn | undefined { return this._primary; }\n\n  set hidden(value: string[]) {\n    this._hidden = value;\n    this.setHidden();\n  }\n\n  get groupBy(): PblColumn[] { return this._groupBy; }\n\n  get groupStore(): PblColumnGroupStore { return this._groupStore; }\n\n  private _primary: PblColumn | undefined;\n  private _metaRows: { header: Array<PblColumnStoreMetaRow & { allKeys?: string[] }>; footer: Array<PblColumnStoreMetaRow & { allKeys?: string[] }>; };\n  private _hidden: string[];\n  private _allHidden: string[];\n  private _groupBy: PblColumn[] = [];\n  private byId = new Map<string, PblMetaColumnStore & { data?: PblColumn }>();\n  private _groupStore: PblColumnGroupStore;\n  private lastSet: PblNgridColumnSet;\n\n  constructor() {\n    this.resetIds();\n    this.resetColumns();\n  }\n\n  addGroupBy(...column: PblColumn[]): void {\n    this.groupBy.push(...column);\n    this.setHidden();\n  }\n\n  removeGroupBy(...column: PblColumn[]): void {\n    for (const c of column) {\n      const idx = this.groupBy.findIndex( gbc => gbc.id === c.id );\n      if (idx > -1) {\n        this.groupBy.splice(idx, 1);\n      }\n    }\n    this.setHidden();\n  }\n\n  /**\n   * Move the provided `column` to the position of the `anchor` column.\n   * The new location of the anchor column will be it's original location plus or minus 1, depending on the delta between\n   * the columns. If the origin of the `column` is before the `anchor` then the anchor's new position is minus one, otherwise plus 1.\n   */\n  moveColumn(column: PblColumn, anchor: PblColumn): boolean {\n    const { columns, columnIds, allColumns } = this;\n    let anchorIndex = columns.indexOf(anchor);\n    let columnIndex = columns.indexOf(column);\n    if (anchorIndex > -1 && columnIndex > -1) {\n      moveItemInArray(columnIds, columnIndex, anchorIndex);\n      moveItemInArray(columns, columnIndex, anchorIndex);\n      if (this._allHidden && this._allHidden.length > 0) {\n        anchorIndex = allColumns.indexOf(anchor);\n        columnIndex = allColumns.indexOf(column);\n      }\n      moveItemInArray(allColumns, columnIndex, anchorIndex);\n      return true;\n    }\n  }\n\n  swapColumns(col1: PblColumn, col2: PblColumn): boolean {\n    let col1Index = this.columns.indexOf(col1);\n    let col2Index = this.columns.indexOf(col2);\n    if (col1Index > -1 && col2Index > -1) {\n      const { columns, columnIds, allColumns } = this;\n      columns[col1Index] = col2;\n      columns[col2Index] = col1;\n      columnIds[col1Index] = col2.id;\n      columnIds[col2Index] = col1.id;\n\n      if (this._allHidden && this._allHidden.length > 0) {\n        col1Index = allColumns.indexOf(col1);\n        col2Index = allColumns.indexOf(col2);\n      }\n      allColumns[col1Index] = col2;\n      allColumns[col2Index] = col1;\n      return true;\n    }\n    return false;\n  }\n\n  find(id: string): PblMetaColumnStore & { data?: PblColumn } | undefined {\n    return this.byId.get(id);\n  }\n\n  getAllHeaderGroup(): PblColumnGroup[] {\n    return this._groupStore ? this._groupStore.all : [];\n  }\n\n  getStaticWidth(): StaticColumnWidthLogic {\n    const rowWidth = new StaticColumnWidthLogic();\n    for (const column of this.columns) {\n      rowWidth.addColumn(column);\n    }\n    return rowWidth;\n  }\n\n  invalidate(columnOrDefinitionSet: PblNgridColumnDefinitionSet | PblNgridColumnSet): void {\n    const columnSet: PblNgridColumnSet = this.lastSet = 'groupStore' in columnOrDefinitionSet\n      ? columnOrDefinitionSet\n      : PblColumnFactory.fromDefinitionSet(columnOrDefinitionSet).build()\n    ;\n    const { groupStore, table, header, footer, headerGroup } = columnSet;\n\n    this._groupStore = groupStore.clone();\n\n    const rowWidth = new StaticColumnWidthLogic();\n    this.resetColumns();\n    this.resetIds();\n    const hidden = this._allHidden = (this._hidden || []).concat(this._groupBy.map( c => c.id ));\n\n    this.headerColumnDef = {\n      rowClassName: (table.header && table.header.rowClassName) || '',\n      type: (table.header && table.header.type) || 'fixed',\n    }\n    this.footerColumnDef = {\n      rowClassName: (table.footer && table.footer.rowClassName) || '',\n      type: (table.footer && table.footer.type) || 'fixed',\n    }\n\n    this._primary = undefined;\n\n    for (const def of table.cols) {\n      let column: PblColumn;\n      column = new PblColumn(def, this.groupStore);\n      const columnRecord = this.getColumnRecord(column.id);\n      columnRecord.data = column;\n      this.allColumns.push(column);\n\n      column.hidden = hidden.indexOf(column.id) > -1;\n      if (!column.hidden) {\n        this.columns.push(column);\n        this.columnIds.push(column.id);\n        rowWidth.addColumn(column);\n      }\n\n      if (column.pIndex) {\n        if (this._primary && isDevMode()) {\n          console.warn(`Multiple primary index columns defined: previous: \"${this._primary.id}\", current: \"${column.id}\"`);\n        }\n        this._primary = column;\n      }\n    }\n\n    for (const rowDef of header) {\n      const keys: string[] = [];\n      for (const def of rowDef.cols) {\n        const metaCol = this.getColumnRecord(def.id, this.metaColumns);\n        const column = metaCol.header || (metaCol.header = new PblMetaColumn(def));\n        keys.push(column.id);\n      }\n      this._metaRows.header[rowDef.rowIndex] = { rowDef, keys };\n    }\n\n    for (const rowDef of headerGroup) {\n      this._updateGroup(rowDef);\n    }\n\n    for (const rowDef of footer) {\n      const keys: string[] = [];\n      for (const def of rowDef.cols) {\n        const metaCol = this.getColumnRecord(def.id, this.metaColumns);\n        const column = metaCol.footer || (metaCol.footer = new PblMetaColumn(def));\n        keys.push(column.id);\n      }\n      this._metaRows.footer.push({ rowDef, keys });\n    }\n    resetColumnWidths(rowWidth, this.columns, this.metaColumns);\n  }\n\n  updateGroups(...rowIndex: number[]): void {\n    if (rowIndex.length === 0) {\n      for (const rowDef of this.lastSet.headerGroup) {\n        this._updateGroup(rowDef);\n      }\n    } else {\n      const rows = rowIndex.slice();\n      for (const rowDef of this.lastSet.headerGroup) {\n        const idx = rows.indexOf(rowDef.rowIndex);\n        if (idx > -1) {\n          rows.splice(idx, 1);\n          this._updateGroup(rowDef);\n          if (rows.length === 0) {\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  private _updateGroup(columnSet: PblColumnSet<PblColumnGroup>): void {\n    const keys: string[] = [];\n    const allKeys: string[] = [];\n\n    const groups: PblColumnGroup[] = [];\n\n    for (let tIndex = 0; tIndex < this.columns.length; tIndex++) {\n      const columns = [this.columns[tIndex - 1], this.columns[tIndex], this.columns[tIndex + 1]];\n      const columnGroups = columns.map( c => c ? c.getGroupOfRow(columnSet.rowIndex) : undefined );\n      // true when the group exists in one of the columns BUT NOT in the LAST COLUMN (i.e: Its a slave split)\n      const groupExists = groups.lastIndexOf(columnGroups[1]) !== -1;\n\n      const column = columns[1];\n      const gColumn = column.groupLogic(columnGroups as any, groupExists);\n      if (gColumn !== columnGroups[1]) {\n        column.markNotInGroup(columnGroups[1]);\n        column.markInGroup(gColumn);\n      }\n\n      const metaCol = this.getColumnRecord(gColumn.id, this.metaColumns);\n      if (!metaCol.headerGroup) {\n        metaCol.headerGroup = gColumn;\n      }\n\n      if (groups.lastIndexOf(gColumn) === -1) {\n        allKeys.push(gColumn.id);\n        if (gColumn.isVisible) {\n          keys.push(gColumn.id);\n        }\n      }\n\n      gColumn.replace(column);\n      groups.push(gColumn);\n    }\n\n    for (const ghost of this._groupStore.findGhosts()) {\n      if (ghost.rowIndex === columnSet.rowIndex) {\n        const { id } = ghost;\n        let idx = allKeys.indexOf(id);\n        if (idx !== -1) {\n          allKeys.splice(idx, 1);\n          idx = keys.indexOf(id);\n          if (idx !== -1) {\n            keys.splice(idx, 1);\n          }\n          this.metaColumns.splice(this.metaColumns.findIndex( m => m.id === id), 1);\n        }\n        this._groupStore.remove(ghost);\n      }\n    }\n    this.updateMetaRow('header', columnSet.rowIndex, { rowDef: columnSet, keys, allKeys, isGroup: true })\n  }\n\n\n  private updateMetaRow<P extends keyof PblColumnStore['_metaRows']>(type: P, rowIndex: number, value: PblColumnStore['_metaRows'][P][0]): void {\n    const curr = this._metaRows[type][rowIndex] || {};\n    this._metaRows[type][rowIndex] = Object.assign(curr, value);\n  }\n\n  private getColumnRecord<T extends PblMetaColumnStore & { data?: PblColumn }>(id: string, collection?: T[]): T  {\n    let columnRecord: PblMetaColumnStore & { data?: PblColumn } = this.byId.get(id);\n    if (!columnRecord) {\n      this.byId.set(id, columnRecord = { id });\n      if (collection) {\n        collection.push(columnRecord as T);\n      }\n    }\n    return columnRecord as T;\n  }\n\n  private setHidden(): void {\n    this._allHidden = (this._hidden || []).concat(this._groupBy.map( c => c.id ));\n    this.columnIds = [];\n    this.columns = [];\n    for (const c of this.allColumns) {\n      c.hidden = this._allHidden.indexOf(c.id) > -1;\n      if (!c.hidden) {\n        this.columns.push(c);\n        this.columnIds.push(c.id);\n      }\n    }\n    for (const h of this._metaRows.header) {\n      if (h.isGroup) {\n        h.keys = h.allKeys.filter( key => this.find(key).headerGroup.isVisible );\n      }\n    }\n    resetColumnWidths(this.getStaticWidth(), this.columns, this.metaColumns);\n  }\n\n  private resetColumns(): void {\n    this.allColumns = [];\n    this.columns = [];\n    this.metaColumns = [];\n    this.byId.clear();\n  }\n\n  private resetIds(): void {\n    this.columnIds = [];\n    this._metaRows = this.metaColumnIds = { header: [], footer: [] };\n  }\n}\n\n/**\n * Moves an item one index in an array to another.\n * @param array Array in which to move the item.\n * @param fromIndex Starting index of the item.\n * @param toIndex Index to which the item should be moved.\n */\nexport function moveItemInArray<T = any>(array: T[], fromIndex: number, toIndex: number): void {\n  const from = clamp(fromIndex, array.length - 1);\n  const to = clamp(toIndex, array.length - 1);\n\n  if (from === to) {\n    return;\n  }\n\n  const target = array[from];\n  const delta = to < from ? -1 : 1;\n\n  for (let i = from; i !== to; i += delta) {\n    array[i] = array[i + delta];\n  }\n\n  array[to] = target;\n}\n\n/** Clamps a number between zero and a maximum. */\nfunction clamp(value: number, max: number): number {\n  return Math.max(0, Math.min(max, value));\n}\n","import { PblColumnSizeInfo } from '../types';\nimport { PblColumn } from './column';\n\nexport class ColumnSizeInfo implements PblColumnSizeInfo {\n  get column(): PblColumn { return this._column; }\n  set column(value: PblColumn) { this.attachColumn(value); }\n\n  /**\n   * The height of the column (subpixel resolution)\n   */\n  height: number;\n  /**\n   * The width of the column (subpixel resolution)\n   * Note that this is the not the content width.\n   */\n  width: number;\n\n  /**\n   * The computed style for this cell.\n   */\n  style: CSSStyleDeclaration;\n\n  protected _column: PblColumn;\n\n  constructor(public readonly target: HTMLElement) { }\n\n  attachColumn(column: PblColumn): void {\n    this.detachColumn();\n\n    if (column) {\n      column.sizeInfo = this;\n    }\n\n    this._column = column;\n  }\n\n  detachColumn(): void {\n    if (this._column) {\n      this._column.sizeInfo = undefined;\n      this._column = undefined;\n    }\n  }\n\n  updateSize(): void {\n    if (this.column && !this.column.columnDef.isDragging) {\n      const el = this.target;\n      const rect = el.getBoundingClientRect();\n      this.width = rect.width;\n      this.height = rect.height;\n      this.style = getComputedStyle(el);\n      this.column.columnDef.onResize();\n    }\n  }\n}\n","import { Subject, Observable } from 'rxjs';\nimport {\n  Injectable,\n  Optional,\n  SkipSelf,\n  OnDestroy,\n} from '@angular/core';\n\nimport { UnRx } from '@pebula/utils';\n\nimport {\n  PblNgridCellDefDirective,\n  PblNgridEditorCellDefDirective,\n  PblNgridHeaderCellDefDirective,\n  PblNgridFooterCellDefDirective,\n\n  PblNgridMultiTemplateRegistry,\n  PblNgridMultiComponentRegistry,\n  PblNgridDataHeaderExtensionContext,\n  PblNgridDataHeaderExtensionRef,\n\n  PblNgridNoDataRefDirective,\n  PblNgridPaginatorRefDirective,\n} from '../directives';\n\nexport interface RegistryChangedEvent {\n  op: 'add' | 'remove';\n  type: keyof PblNgridMultiRegistryMap | keyof PblNgridSingleRegistryMap;\n  value: any;\n}\n\n/**\n * A map of valid single-item value that can be registered, and their type.\n */\nexport interface PblNgridSingleRegistryMap {\n  noData?: PblNgridNoDataRefDirective;\n  paginator?: PblNgridPaginatorRefDirective;\n}\n\n/**\n * A map of valid multi-item value that can be registered, and their type (the single type, i.e. T in Array<T>)\n */\nexport interface PblNgridMultiRegistryMap {\n  headerCell?: PblNgridHeaderCellDefDirective<any>;\n  tableCell?: PblNgridCellDefDirective<any>;\n  editorCell?: PblNgridEditorCellDefDirective<any>;\n  footerCell?: PblNgridFooterCellDefDirective<any>;\n  dataHeaderExtensions?:\n    (PblNgridMultiTemplateRegistry<PblNgridDataHeaderExtensionContext, 'dataHeaderExtensions'> & PblNgridDataHeaderExtensionRef)\n    | (PblNgridMultiComponentRegistry<any, 'dataHeaderExtensions'> & PblNgridDataHeaderExtensionRef);\n}\n\n/**\n * A Registry for templates of table parts.\n *\n * The registry is hierarchical, where each instance of a registry has a parent which allows cascading templates.\n * The hierarchy is manged by angular DI.\n *\n * > The root registry does not have a parent.\n *\n * Each instance of a registry (including root) is a hierarchy by itself, composed of 2 internal levels.\n * The first level (L1 below) is used for fixed templates, the second level (L2 below) is used for dynamic templates.\n *\n * - Root Registry\n *   - Child Registry\n *     - ChildOfChild Registry\n *\n * In the example above there are 3 registries: Root, Child and ChildOfChild.\n *\n * When searching for a template in `ChildOfChild` it will search in the following order (top to bottom):\n *   - ChildOfChild\n *   - Child\n *   - Root\n *\n * If a registry does not contain the template the search will move to the next one.\n */\n@Injectable({ providedIn: 'root' })\n@UnRx()\nexport class PblNgridRegistryService implements OnDestroy {\n\n  readonly changes: Observable<RegistryChangedEvent[]>;\n  get parent(): PblNgridRegistryService | undefined { return this._parent; }\n\n  protected root: PblNgridRegistryService & { bufferedData?: RegistryChangedEvent[] };\n\n  protected _multi: { [K in keyof PblNgridMultiRegistryMap]: Array<PblNgridMultiRegistryMap[K]> } = {};\n  protected _multiDefaults: PblNgridMultiRegistryMap = {};\n  protected _singles: PblNgridSingleRegistryMap = {};\n\n  protected readonly changes$: Subject<RegistryChangedEvent[]>;\n\n  constructor(@Optional() @SkipSelf() private _parent?: PblNgridRegistryService) {\n    this.changes$ = new Subject();\n    this.changes = this.changes$.asObservable();\n    if (this._parent) {\n      this._parent.changes.pipe(UnRx(this)).subscribe(this.changes$);\n      this.root = this._parent.root;\n    } else {\n      this.root = this;\n    }\n  }\n\n  getRoot(): PblNgridRegistryService { return this.root; }\n\n  /**\n   * Returns the registered value for the single `kind`.\n   * If not found will try to search the parent.\n   */\n  getSingle<P extends keyof PblNgridSingleRegistryMap>(kind: P): PblNgridSingleRegistryMap[P] | undefined {\n    return this._singles[kind] || (this._parent && this._parent.getSingle(kind));\n  }\n\n  setSingle<P extends keyof PblNgridSingleRegistryMap>(kind: P, value: PblNgridSingleRegistryMap[P] | undefined): void {\n    const previous = this.getSingle(kind);\n    if (value !== previous) {\n      this._singles[kind] = value;\n      this.emitChanges({ op: value ? 'add' : 'remove', type: kind, value });\n    }\n  }\n\n  /**\n   * Returns the registered default value for the multi `kind`.\n   * If not found will try to search the parent.\n   */\n  getMultiDefault<P extends keyof PblNgridMultiRegistryMap>(kind: P): PblNgridMultiRegistryMap[P] | undefined {\n    return this._multiDefaults[kind] || (this._parent && this._parent.getMultiDefault(kind));\n  }\n\n  setMultiDefault<P extends keyof PblNgridMultiRegistryMap>(kind: P, value: PblNgridMultiRegistryMap[P] | undefined): void {\n    const previous = this.getMultiDefault(kind);\n    if (value !== previous) {\n      this._multiDefaults[kind] = value;\n      this.emitChanges({ op: value ? 'add' : 'remove', type: kind, value });\n    }\n  }\n\n  /**\n   * Returns the registered values for the multi `kind`.\n   * If not found WILL NOT search the parent.\n   */\n  getMulti<T extends keyof PblNgridMultiRegistryMap>(kind: T): Array<PblNgridMultiRegistryMap[T]> | undefined {\n    return this._multi[kind] as Array<PblNgridMultiRegistryMap[T]>;\n  }\n\n  addMulti<T extends keyof PblNgridMultiRegistryMap>(kind: T, cellDef: PblNgridMultiRegistryMap[T]): void {\n    const multi = this.getMulti(kind) || (this._multi[kind] = []);\n    multi.push(cellDef);\n    if (cellDef.name === '*') {\n      this.setMultiDefault(kind, cellDef);\n    }\n    this.emitChanges({ op: 'add', type: kind, value: cellDef })\n  }\n\n  removeMulti<T extends keyof PblNgridMultiRegistryMap>(kind: T, cellDef: PblNgridMultiRegistryMap[T]): void {\n    const multi = this.getMulti(kind);\n    if (multi) {\n      const idx = multi.indexOf(cellDef);\n      if (idx > -1) {\n        multi.splice(idx, 1);\n      }\n      this.emitChanges({ op: 'remove', type: kind, value: cellDef })\n    }\n  }\n\n  /**\n   * Iterate over all multi-registry value of the provided `kind` ascending order, starting from the last ancestor (this registry) up to\n   * the root parent.\n   *\n   * Each time a collection for the `kind` is found the handler is invoked and then repeating the process on the parent.\n   * If the `kind` does not exist the handler is not called moving on to the next parent.\n   *\n   * To bail out (stop the process and don't iterate to the next parent), return true from the handler.\n   *\n   * @returns The number of times that handler was invoked, i.e 0 means no matches.\n   */\n  forMulti<T extends keyof PblNgridMultiRegistryMap>(kind: T,\n                                                     handler: ( (values: Array<PblNgridMultiRegistryMap[T]>) => boolean | void)): number {\n    let registry: PblNgridRegistryService = this;\n    let hasSome = 0;\n    while (registry) {\n      const values = registry.getMulti(kind);\n      if (values) {\n        hasSome++;\n        if (handler(values) === true) {\n          return;\n        }\n      }\n      registry = registry.parent;\n    }\n    return hasSome;\n  }\n\n  ngOnDestroy(): void {\n    this.changes$.complete();\n  }\n\n  /**\n   * Delay all notifications sent through `changes` and buffer then until next call to `bufferEnd()`.\n   * When `bufferEnd()` is called it will flush all changes.\n   *\n   * > It's important to note that buffering does not freeze the registry, adding and removing templates will change the\n   * registry and will effect queries. Buffering block the `changes` event stream and nothing more.\n   */\n  bufferStart(): void {\n    if (!this.root.bufferedData) {\n      this.root.bufferedData = [];\n    }\n  }\n\n  bufferEnd(): void {\n    if (this.root.bufferedData) {\n      const data = this.root.bufferedData;\n      this.root.bufferedData = undefined;\n      this.emitChanges(data);\n    }\n  }\n\n  private emitChanges(events: RegistryChangedEvent | RegistryChangedEvent[]): void {\n    const e = Array.isArray(events) ? events : [events];\n    if (this.root.bufferedData) {\n      this.root.bufferedData.push(...e)\n    } else {\n      this.changes$.next(e);\n    }\n  }\n}\n","// tslint:disable:use-input-property-decorator\nimport {\n  Directive,\n  TemplateRef,\n  OnInit,\n  OnDestroy,\n} from '@angular/core';\n\nimport { COLUMN, PblColumnTypeDefinitionDataMap, PblColumn, PblMetaColumn } from '../columns';\nimport { PblNgridCellContext, PblNgridMetaCellContext } from '../context/index';\nimport { PblNgridRegistryService } from '../services/table-registry.service';\n\nexport interface PblNgridCellDefDirectiveBase {\n  name: string;\n  type: keyof PblColumnTypeDefinitionDataMap;\n}\n\nexport abstract class PblNgridBaseCellDef<Z> implements OnInit, OnDestroy, PblNgridCellDefDirectiveBase {\n  name: string;\n  type: keyof PblColumnTypeDefinitionDataMap;\n\n  constructor(public tRef: TemplateRef<Z>,\n              protected registry: PblNgridRegistryService) { }\n\n  ngOnInit(): void {\n    // TODO: listen to property changes (name) and re-register cell\n    if (this instanceof PblNgridHeaderCellDefDirective) {\n      this.registry.addMulti('headerCell', this);\n    } else if (this instanceof PblNgridCellDefDirective) {\n      this.registry.addMulti('tableCell', this);\n    } else if (this instanceof PblNgridEditorCellDefDirective) {\n      this.registry.addMulti('editorCell', this);\n    } else if (this instanceof PblNgridFooterCellDefDirective) {\n      this.registry.addMulti('footerCell', this);\n    }\n  }\n\n  ngOnDestroy(): void {\n    if (this instanceof PblNgridHeaderCellDefDirective) {\n      this.registry.removeMulti('headerCell', this);\n    } else if (this instanceof PblNgridCellDefDirective) {\n      this.registry.removeMulti('tableCell', this);\n    } else if (this instanceof PblNgridEditorCellDefDirective) {\n      this.registry.removeMulti('editorCell', this);\n    } else if (this instanceof PblNgridFooterCellDefDirective) {\n      this.registry.removeMulti('footerCell', this);\n    }\n  }\n}\n\n/**\n * Header Cell definition for the pbl-ngrid.\n * Captures the template of a column's data row header cell as well as header cell-specific properties.\n *\n * `pblNgridHeaderCellDef` does the same thing that `matHeaderCellDef` and `cdkHeaderCellDef` do with one difference,\n * `pblNgridHeaderCellDef` is independent and does not require a column definition parent, instead it accept the ID of\n * the header cell.\n *\n * NOTE: Defining '*' as id will declare the header cell template as default, replacing the table's default header cell template.\n *\n * Make sure you set the proper id of the property you want to override.\n * When the `id` is set explicitly in the table column definition, this is not a problem but when if it's not set\n * the table generates a unique id based on a logic. If `name` is set the name is used, if no name is set\n * the `prop` is used (full with dot notation).\n */\n@Directive({\n  selector: '[pblNgridHeaderCellDef], [pblNgridHeaderCellTypeDef]',\n  inputs: [\n    'name:pblNgridHeaderCellDef',\n    'type:pblNgridHeaderCellTypeDef',\n  ]\n})\nexport class PblNgridHeaderCellDefDirective<T> extends PblNgridBaseCellDef<PblNgridMetaCellContext<T>> {\n  constructor(tRef: TemplateRef<PblNgridMetaCellContext<T>>, registry: PblNgridRegistryService) { super(tRef, registry); }\n}\n\n/**\n * Cell definition for the pbl-ngrid.\n * Captures the template of a column's data row cell as well as cell-specific properties.\n *\n * `pblNgridCellDef` does the same thing that `matCellDef` and `cdkCellDef` do with one difference, `pblNgridCellDef` is\n * independent and does not require a column definition parent, instead it accept the ID of the cell.\n *\n * NOTE: Defining '*' as id will declare the cell template as default, replacing the table's default cell template.\n *\n * Make sure you set the proper id of the property you want to override.\n * When the `id` is set explicitly in the table column definition, this is not a problem but when if it's not set\n * the table generates a unique id based on a logic. If `name` is set the name is used, if no name is set\n * the `prop` is used (full with dot notation).\n */\n@Directive({\n  selector: '[pblNgridCellDef], [pblNgridCellTypeDef]',\n  inputs: [\n    'name:pblNgridCellDef',\n    'type:pblNgridCellTypeDef',\n  ]\n})\nexport class PblNgridCellDefDirective<T, P extends keyof PblColumnTypeDefinitionDataMap = any> extends PblNgridBaseCellDef<PblNgridCellContext<T, P>> {\n  type: P;\n  constructor(tRef: TemplateRef<PblNgridCellContext<any, P>>, registry: PblNgridRegistryService) { super(tRef, registry); }\n}\n\n@Directive({\n  selector: '[pblNgridCellEditorDef], [pblNgridCellEditorTypeDef]',\n  inputs: [\n    'name:pblNgridCellEditorDef',\n    'type:pblNgridCellEditorTypeDef',\n  ]\n})\nexport class PblNgridEditorCellDefDirective<T, P extends keyof PblColumnTypeDefinitionDataMap = any> extends PblNgridBaseCellDef<PblNgridCellContext<T, P>> {\n  type: P;\n  constructor(tRef: TemplateRef<PblNgridCellContext<any, P>>, registry: PblNgridRegistryService) { super(tRef, registry); }\n}\n\n@Directive({\n  selector: '[pblNgridFooterCellDef], [pblNgridFooterCellTypeDef]',\n  inputs: [\n    'name:pblNgridFooterCellDef',\n    'type:pblNgridFooterCellTypeDef',\n  ]\n})\nexport class PblNgridFooterCellDefDirective<T> extends PblNgridBaseCellDef<PblNgridMetaCellContext<T>> {\n  constructor(tRef: TemplateRef<PblNgridMetaCellContext<T>>, registry: PblNgridRegistryService) { super(tRef, registry); }\n}\n\nfunction findCellDefById<T extends PblNgridCellDefDirectiveBase>(cellDefs: Array<T>, colDef: Pick<PblMetaColumn, 'id' | 'type'>, searchParent?: boolean): T {\n  for (const cellDef of cellDefs) {\n    if (cellDef.type) {\n      if (colDef.type && cellDef.type === colDef.type.name) {\n        return cellDef;\n      }\n    } else {\n      const id = cellDef.name;\n      if (id === colDef.id) {\n        return cellDef;\n      }\n    }\n  }\n}\n\nexport function findCellDef<T = any>(registry: PblNgridRegistryService, colDef: PblColumn, kind: 'tableCell' | 'editorCell',  searchParent?: boolean): PblNgridCellDefDirective<T>;\nexport function findCellDef<T = any>(registry: PblNgridRegistryService, colDef: PblMetaColumn | PblColumn, kind: 'headerCell', searchParent?: boolean): PblNgridHeaderCellDefDirective<T>;\nexport function findCellDef<T = any>(registry: PblNgridRegistryService, colDef: PblMetaColumn | PblColumn, kind: 'footerCell', searchParent?: boolean): PblNgridFooterCellDefDirective<T>;\nexport function findCellDef<T = any>(registry: PblNgridRegistryService, colDef: COLUMN, kind: 'headerCell' | 'footerCell' | 'tableCell' | 'editorCell', searchParent?: boolean): PblNgridCellDefDirective<T> | PblNgridHeaderCellDefDirective<T> | PblNgridFooterCellDefDirective <T> {\n  const cellDefs: PblNgridCellDefDirectiveBase[] = registry.getMulti(kind);\n\n  if (cellDefs) {\n    let type: Pick<PblMetaColumn, 'id' | 'type'>;\n    if (colDef instanceof PblColumn) {\n      switch (kind) {\n        case 'headerCell':\n          if (colDef.headerType) {\n            type = { id: colDef.id, type: colDef.headerType };\n          }\n          break;\n        case 'footerCell':\n          if (colDef.footerType) {\n            type = { id: colDef.id, type: colDef.footerType };\n          }\n          break;\n      }\n    }\n    if (!type) {\n      type = colDef;\n    }\n    const match: any = findCellDefById(cellDefs, type);\n    if (match) {\n      return match;\n    }\n  }\n\n  if (searchParent && registry.parent) {\n    return findCellDef(registry.parent, colDef as any, kind as any, searchParent);\n  }\n}\n\n","import { PblNgridExtensionApi } from '../../ext/table-ext-api';\nimport { PblNgridComponent } from '../table.component';\nimport { CellContextState, PblNgridCellContext, PblNgridMetaCellContext, PblNgridRowContext } from './types';\nimport { PblColumn } from '../columns/column';\nimport { PblMetaColumn } from '../columns/meta-column';\nimport { PblRowContext } from './row';\n\nexport class MetaCellContext<T = any, TCol extends PblMetaColumn | PblColumn = PblMetaColumn> implements PblNgridMetaCellContext<T, TCol> {\n  col: TCol;\n  table: PblNgridComponent<any>;\n  get $implicit(): MetaCellContext<T, TCol> { return this; }\n\n  protected constructor() {}\n\n  // workaround, we need a parameter-less constructor since @ngtools/webpack@8.0.4\n  // Non @Injectable classes are now getting addded with hard reference to the ctor params which at the class creation point are undefined\n  // forwardRef() will not help since it's not inject by angular, we instantiate the class..\n  // probably due to https://github.com/angular/angular-cli/commit/639198499973e0f437f059b3c933c72c733d93d8\n  static create<T = any, TCol extends PblMetaColumn | PblColumn = PblMetaColumn>(col: TCol, table: PblNgridComponent<T>): MetaCellContext<T, TCol> {\n    const instance = new MetaCellContext<T, TCol>();\n    instance.col = col;\n    instance.table = table;\n    return instance;\n  }\n\n}\n\nexport class PblCellContext<T = any> implements PblNgridCellContext<T> {\n  get $implicit(): PblCellContext<T> { return this; }\n  get row(): T { return this.rowContext.$implicit; };\n  get value(): any { return this.col.getValue(this.row); }\n  set value(v: any) { this.col.setValue(this.row, v); }\n\n  get rowContext(): PblNgridRowContext<T> { return this._rowContext; }\n  get editing(): boolean { return this._editing; }\n  get focused(): boolean { return this._focused; }\n  get selected(): boolean { return this._selected; }\n\n  readonly table: PblNgridComponent<any>;\n  readonly index: number;\n\n  private _editing = false;\n  private _focused = false;\n  private _selected = false;\n\n  private _rowContext: PblRowContext<T>;\n  public col: PblColumn;\n  private extApi: PblNgridExtensionApi<T>;\n\n  protected constructor() { }\n\n  // workaround, we need a parameter-less constructor since @ngtools/webpack@8.0.4\n  // Non @Injectable classes are now getting addded with hard reference to the ctor params which at the class creation point are undefined\n  // forwardRef() will not help since it's not inject by angular, we instantiate the class..\n  // probably due to https://github.com/angular/angular-cli/commit/639198499973e0f437f059b3c933c72c733d93d8\n  static create<T = any>(rowContext: PblRowContext<T>, col: PblColumn, extApi: PblNgridExtensionApi<T>): PblCellContext<T> {\n    const instance = new PblCellContext<T>();\n\n    instance._rowContext = rowContext;\n    instance.col = col;\n    instance.extApi = extApi;\n\n    Object.defineProperties(instance, {\n      table: { value: extApi.table },\n      index: { value: extApi.table.columnApi.indexOf(col) },\n    });\n\n    return instance;\n  }\n\n  static defaultState<T = any>(): CellContextState<T> {\n    return { editing: false, focused: false, selected: false };\n  }\n\n  clone(): PblCellContext<T> {\n    const ctx = PblCellContext.create<T>(this._rowContext, this.col, this.extApi);\n    ctx.fromState(this.getState(), this._rowContext, true);\n    return ctx;\n  }\n\n  getState(): CellContextState<T> {\n    return {\n      editing: this._editing,\n      focused: this._focused,\n      selected: this._selected,\n    };\n  }\n\n  fromState(state: CellContextState<T>, rowContext: PblRowContext<T>, skipRowUpdate?: boolean): void {\n    const requiresReset = !skipRowUpdate && this._editing === state.editing;\n\n    this._rowContext = rowContext;\n    this._editing = state.editing;\n    this._focused = state.focused;\n    this._selected = state.selected;\n\n    if (requiresReset) {\n      rowContext.updateCell(this);\n    }\n  }\n\n  startEdit(markForCheck?: boolean): void {\n    if (this.col.editorTpl && !this.editing) {\n      this._editing = true;\n      this._rowContext.updateCell(this);\n      if (markForCheck) {\n        this.table._cdkTable.syncRows('data', true, this.rowContext.index);\n      }\n    }\n  }\n\n  stopEdit(markForCheck?: boolean): void {\n    if (this.editing && !this.table.viewport.isScrolling) {\n      this._editing = false;\n      this._rowContext.updateCell(this);\n      if (markForCheck) {\n        this.table._cdkTable.syncRows('data', this.rowContext.index);\n      }\n    }\n  }\n}\n","import { RowContext } from '@angular/cdk/table';\n\nimport { PblColumn } from '../columns/column';\nimport { PblNgridExtensionApi } from '../../ext/table-ext-api';\nimport { PblNgridComponent } from '../table.component';\nimport { CellContextState, RowContextState, PblNgridRowContext } from './types';\nimport { PblCellContext } from './cell';\n\ndeclare module '@angular/cdk/table/typings/row.d' {\n  export interface CdkCellOutletRowContext<T> {\n    pblRowContext: PblNgridRowContext<T>;\n  }\n  export interface CdkCellOutletMultiRowContext<T> {\n    pblRowContext: PblNgridRowContext<T>;\n  }\n}\n\nexport class PblRowContext<T> implements PblNgridRowContext<T> {\n  /** Data for the row that this cell is located within. */\n  $implicit?: T;\n  /** Index of the data object in the provided data array. */\n  index?: number;\n  /** Index location of the rendered row that this cell is located within. */\n  renderIndex?: number;\n  /** Length of the number of total rows. */\n  count?: number;\n  /** True if this cell is contained in the first row. */\n  first?: boolean;\n  /** True if this cell is contained in the last row. */\n  last?: boolean;\n  /** True if this cell is contained in a row with an even-numbered index. */\n  even?: boolean;\n  /** True if this cell is contained in a row with an odd-numbered index. */\n  odd?: boolean;\n\n  gridInstance: PblNgridComponent<T>;\n\n  firstRender: boolean;\n  outOfView: boolean;\n  readonly table: PblNgridComponent<T>;\n\n  /**\n   * Returns the length of cells context stored in this row\n   */\n  get length(): number {\n    return (this.cells && this.cells.length) || 0;\n  }\n\n  get pblRowContext(): PblNgridRowContext<T> { return this; }\n  set pblRowContext(value: PblNgridRowContext<T>) { }\n\n  private cells: PblCellContext<T>[];\n\n  constructor(public identity: any, public dataIndex: number, private extApi: PblNgridExtensionApi<T>) {\n    /*  TODO: material2#14198\n        The row context come from the `cdk` and it can be of 2 types, depending if multiple row templates are used or not.\n        `index` is used for single row template mode and `renderIndex` for multi row template mode.\n\n        There library and/or plugins require access to the rendered index and having 2 locations is a problem...\n        It's a bug trap, adding more complexity and some time access issue because the `CdkTable` instance is not always available.\n\n        This is a workaround for have a single location for the rendered index.\n        I chose to `index` as the single location although `renderIndex` will probably be chosen by the material team.\n        This is because it's less likely to occur as most tables does not have multi row templates (detail row)\n        A refactor will have to be done in the future.\n        There is a pending issue to do so in https://github.com/angular/material2/issues/14198\n        Also related: https://github.com/angular/material2/issues/14199\n    */\n    const applyWorkaround = extApi.cdkTable.multiTemplateDataRows;\n    if (applyWorkaround) {\n      Object.defineProperty(this, 'index', { get: function() { return this.renderIndex; } });\n    }\n\n    this.table = extApi.table;\n\n    const cells = this.cells = [];\n    const { columns } = extApi.table.columnApi;\n    const len = columns.length;\n\n    for (let columnIndex = 0; columnIndex < len; columnIndex++) {\n      const cellContext = PblCellContext.create<T>(this, columns[columnIndex], extApi);\n      cells.push(cellContext);\n    }\n  }\n\n  static defaultState<T = any>(identity: any, dataIndex: number, cellsCount: number): RowContextState<T> {\n    const cells: CellContextState<T>[] = [];\n    for (let i = 0; i < cellsCount; i++) {\n      cells.push(PblCellContext.defaultState());\n    }\n    return { identity, dataIndex, cells, firstRender: true };\n  }\n\n  getState(): RowContextState<T> {\n    return {\n      identity: this.identity,\n      dataIndex: this.dataIndex,\n      firstRender: this.firstRender,\n      cells: this.cells.map( c => c.getState() ),\n    };\n  }\n\n  fromState(state: RowContextState<T>): void {\n    this.identity = state.identity;\n    this.firstRender = state.firstRender;\n    this.dataIndex = state.dataIndex;\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      this.cells[i].fromState(state.cells[i], this);\n    }\n  }\n\n  updateContext(context: RowContext<T>): void {\n    context.dataIndex = this.dataIndex;\n    Object.assign(this, context);\n  }\n\n  /**\n   * Returns the cell context for the column at the specified position.\n   * > The position is relative to ALL columns (NOT RENDERED COLUMNS)\n   */\n  cell(index: number | PblColumn): PblCellContext<T> | undefined {\n    const idx = typeof index === 'number' ? index : this.table.columnApi.indexOf(index);\n    return this.cells[idx];\n  }\n\n  getCells(): PblCellContext<T>[] {\n    return (this.cells && this.cells.slice()) || [];\n  }\n\n  updateCell(cell: PblCellContext<T>): void {\n    this.cells[cell.index] = cell.clone();\n  }\n    /**\n   * Updates the `outOfView` property.\n   */\n  updateOutOfViewState(): void {\n    this.extApi.contextApi.updateOutOfViewState(this);\n  }\n}\n","import { PblNgridExtensionApi } from '../../ext/table-ext-api';\nimport { ColumnApi } from '../column-api';\nimport { RowContextState, PblNgridCellContext, CellReference, GridDataPoint } from './types';\nimport { PblRowContext } from './row';\nimport { PblCellContext } from './cell';\n\n/** IE 11 compatible matches implementation. */\nexport function matches(element: Element, selector: string): boolean {\n  return element.matches ?\n      element.matches(selector) :\n      (element as any)['msMatchesSelector'](selector);\n}\n\n/** IE 11 compatible closest implementation. */\nexport function closest(element: EventTarget|Element|null|undefined, selector: string): Element | null {\n  if (!(element instanceof Node)) { return null; }\n\n  let curr: Node|null = element;\n  while (curr != null && !(curr instanceof Element && matches(curr, selector))) {\n    curr = curr.parentNode;\n  }\n\n  return (curr || null) as Element|null;\n}\n\nexport function findRowRenderedIndex(el: HTMLElement): number {\n  const rows = Array.from(closest(el, 'pbl-cdk-table').querySelectorAll('pbl-ngrid-row'));\n  return rows.indexOf(el);\n}\n\nexport function findCellRenderedIndex(el: HTMLElement): [number, number] {\n  const rowEl = closest(el, 'pbl-ngrid-row') as HTMLElement;\n  const cells = Array.from(rowEl.querySelectorAll('pbl-ngrid-cell'));\n  return [ findRowRenderedIndex(rowEl), cells.indexOf(el) ];\n}\n\n/**\n * Resolves the context from one of the possible types in `CellReference`.\n * If the context is within the view it will return the `PblCellContext instance, otherwise it will\n * return a tuple with the first item being the row context state and the seconds item pointing to the cell index.\n *\n * If no context is found, returns undefined.\n */\nexport function resolveCellReference(cellRef: CellReference,\n                                     context: { viewCache: Map<number, PblRowContext<any>>, cache: Map<any, RowContextState>, columnApi: ColumnApi<any>, extApi: PblNgridExtensionApi }): PblCellContext | [RowContextState, number] | undefined {\n  let rowIdent: any;\n  let colIndex: number;\n\n  if (isGridDataPoint(cellRef)) {\n    rowIdent = cellRef.rowIdent;\n    colIndex = cellRef.colIndex;\n  } else if (isCellContext(cellRef)) {\n    rowIdent = cellRef.rowContext.identity;\n    colIndex = cellRef.index;\n  } else {\n    const [ r, c ] = findCellRenderedIndex(cellRef);\n    const rowContext = context.viewCache.get(r);\n    if (rowContext) {\n      const column = context.columnApi.findColumnAt(c);\n      const columnIndex = context.columnApi.indexOf(column);\n      return rowContext.cell(columnIndex);\n    } else {\n      return;\n    }\n  }\n\n  const rowState = context.cache.get(rowIdent);\n  if (rowState) {\n     const rowContext = context.extApi.table.contextApi.findRowInView(rowState.identity);\n     if (rowContext) {\n       return rowContext.cell(colIndex);\n     } else {\n       const cellState = rowState.cells[colIndex];\n       if (cellState) {\n         return [ rowState, colIndex ];\n       }\n     }\n  }\n}\n\nfunction isGridDataPoint(obj: any): obj is GridDataPoint {\n  return 'rowIdent' in obj && 'colIndex' in obj;\n}\n\nfunction isCellContext(obj: any): obj is PblNgridCellContext {\n  return 'rowContext' in obj && 'index' in obj;\n}\n","import { BehaviorSubject, Subject, Observable, asapScheduler } from 'rxjs';\nimport { debounceTime, buffer, map, filter } from 'rxjs/operators';\n\nimport { ViewContainerRef, EmbeddedViewRef } from '@angular/core';\nimport { RowContext } from '@angular/cdk/table';\n\nimport { removeFromArray } from '@pebula/utils';\nimport { PblNgridExtensionApi } from '../../ext/table-ext-api';\nimport {\n  RowContextState,\n  CellContextState,\n  PblNgridCellContext,\n  PblNgridRowContext,\n  CellReference,\n  GridDataPoint,\n  PblNgridFocusChangedEvent,\n  PblNgridSelectionChangedEvent\n} from './types';\nimport { PblColumn } from '../columns/column';\nimport { ColumnApi } from '../column-api';\nimport { findCellRenderedIndex, findRowRenderedIndex, resolveCellReference } from './utils';\nimport { PblRowContext } from './row';\nimport { PblCellContext } from './cell';\n\nexport class ContextApi<T = any> {\n  private viewCache = new Map<number, PblRowContext<T>>();\n  private cache = new Map<any, RowContextState<T>>();\n  private vcRef: ViewContainerRef;\n  private columnApi: ColumnApi<T>;\n\n  private activeFocused: GridDataPoint;\n  private activeSelected: GridDataPoint[] = [];\n  private focusChanged$ = new BehaviorSubject<PblNgridFocusChangedEvent>({ prev: undefined, curr: undefined });\n  private selectionChanged$ = new Subject<PblNgridSelectionChangedEvent>();\n\n  /**\n   * Notify when the focus has changed.\n   *\n   * > Note that the notification is not immediate, it will occur on the closest micro-task after the change.\n   */\n  readonly focusChanged: Observable<PblNgridFocusChangedEvent> = this.focusChanged$\n    .pipe(\n      buffer<PblNgridFocusChangedEvent>(this.focusChanged$.pipe(debounceTime(0, asapScheduler))),\n      map( events => ({ prev: events[0].prev, curr: events[events.length - 1].curr }) )\n    );\n\n  /**\n   * Notify when the selected cells has changed.\n   */\n  readonly selectionChanged: Observable<PblNgridSelectionChangedEvent> = this.selectionChanged$.asObservable();\n\n  /**\n   * The reference to currently focused cell context.\n   * You can retrieve the actual context or context cell using `findRowInView` and / or `findRowInCache`.\n   *\n   * > Note that when virtual scroll is enabled the currently focused cell does not have to exist in the view.\n   * If this is the case `findRowInView` will return undefined, use `findRowInCache` instead.\n   */\n  get focusedCell(): GridDataPoint | undefined {\n    return this.activeFocused ? {...this.activeFocused } : undefined;\n  }\n\n  /**\n   * The reference to currently selected range of cell's context.\n   * You can retrieve the actual context or context cell using `findRowInView` and / or `findRowInCache`.\n   *\n   * > Note that when virtual scroll is enabled the currently selected cells does not have to exist in the view.\n   * If this is the case `findRowInView` will return undefined, use `findRowInCache` instead.\n   */\n  get selectedCells(): GridDataPoint[] {\n    return this.activeSelected.slice();\n  }\n\n  constructor(private extApi: PblNgridExtensionApi<T>) {\n    this.vcRef = extApi.cdkTable._rowOutlet.viewContainer;\n    this.columnApi = extApi.table.columnApi;\n\n    extApi.events\n      .pipe( filter( e => e.kind === 'onDestroy' ) )\n      .subscribe( e => this.destroy() );\n\n    const updateContext = () => {\n      const viewPortRect = this.getViewRect();\n      const lastView = new Set(Array.from(this.viewCache.values()).map( v => v.identity ));\n      const unmatchedRefs = new Map<T, [number, number]>();\n\n      let keepProcessOutOfView = !!viewPortRect;\n      for (let i = 0, len = this.vcRef.length; i < len; i++) {\n        const viewRef = this.findViewRef(i);\n        const rowContext = this.findRowContext(viewRef, i);\n        this.viewCache.set(i, rowContext);\n        lastView.delete(rowContext.identity);\n\n        // Identity did not change but context did change\n        // This is probably due to trackBy with index reference or that matched data on some property but the actual data reference changed.\n        // We log these and handle them later, they come in pair and we need to switch the context between the values in the pair.\n\n        // The pair is a 2 item tuple - 1st item is new index, 2nd item is the old index.\n        // We build the pairs, each pair is a switch\n        if (viewRef.context.$implicit !== rowContext.$implicit) {\n          let pair = unmatchedRefs.get(rowContext.$implicit) || [-1, -1];\n          pair[1] = i;\n          unmatchedRefs.set(rowContext.$implicit, pair);\n\n          pair = unmatchedRefs.get(viewRef.context.$implicit) || [-1, -1];\n          pair[0] = i;\n          unmatchedRefs.set(viewRef.context.$implicit, pair);\n        }\n\n        if (keepProcessOutOfView) {\n          keepProcessOutOfView = processOutOfView(viewRef, viewPortRect, 'top');\n        }\n      }\n\n      if (unmatchedRefs.size > 0) {\n        // We have pairs but we can't just start switching because when the items move or swap we need\n        // to update their values and so we need to cache one of them.\n        // The operation will effect all items (N) between then origin and destination.\n        // When N === 2 its a swap, when N > 2 its a move.\n        // In both cases the first and last operations share the same object.\n        // Also, we need to make sure that the order of operations does not use the same row as the source more then once.\n        // For example, If I copy row 5 to to row 4 and then 4 to 3 I need to start from 3->4->5, if I do 5->4->3 I will get 5 in all rows.\n        //\n        // We use the source (pair[1]) for sorting, the sort order depends on the direction of the move (up/down).\n        const arr = Array.from(unmatchedRefs.entries()).filter( entry => {\n          const pair = entry[1];\n          if (pair[0] === -1) {\n            return false;\n          } else if (pair[1] === -1) {\n            const to = this.viewCache.get(pair[0]);\n            to.$implicit = entry[0];\n            return false;\n          }\n          return true;\n        }).map( entry => entry[1] );\n\n        unmatchedRefs.clear();\n\n        if (arr.length) {\n          const sortFn = arr[arr.length - 1][0] - arr[arr.length - 1][1] > 0 // check sort direction\n            ? (a,b) => b[1] - a[1]\n            : (a,b) => a[1] - b[1]\n          ;\n          arr.sort(sortFn);\n\n          const lastOp = {\n            data: this.viewCache.get(arr[0][0]).$implicit,\n            state: this.viewCache.get(arr[0][0]).getState(),\n            pair: arr.pop(),\n          };\n\n          for (const pair of arr) {\n            // What we're doing here is switching the context wrapped by `RotContext` while the `RowContext` preserve it's identity.\n            // Each row context has a state, which is valid for it's current context, if we switch context we must switch state as well and also\n            // cache it.\n            const to = this.viewCache.get(pair[0]);\n            const from = this.viewCache.get(pair[1]);\n            const state = from.getState();\n            state.identity = to.identity;\n            this.cache.set(to.identity, state);\n            to.fromState(state);\n            to.$implicit = from.$implicit;\n          }\n\n          const to = this.viewCache.get(lastOp.pair[0]);\n          lastOp.state.identity = to.identity;\n          this.cache.set(to.identity, lastOp.state);\n          to.fromState(lastOp.state);\n          to.$implicit = lastOp.data;\n        }\n      }\n\n      if(viewPortRect) {\n        for (let i = this.vcRef.length -1; i > -1; i--) {\n          if (!processOutOfView(this.findViewRef(i), viewPortRect, 'bottom')) {\n            break;\n          }\n        }\n      }\n\n      lastView.forEach( ident => this.cache.get(ident).firstRender = false );\n    };\n\n    updateContext();\n    extApi.cdkTable.onRenderRows.subscribe(updateContext);\n  }\n\n  /**\n   * Focus the provided cell.\n   * If a cell is not provided will un-focus (blur) the currently focused cell (if there is one).\n   * @param cellRef A Reference to the cell\n   * @param markForCheck Mark the row for change detection\n   */\n  focusCell(cellRef?: CellReference | boolean, markForCheck?: boolean): void {\n    if (!cellRef || cellRef === true) {\n      if (this.activeFocused) {\n        const { rowIdent, colIndex } = this.activeFocused;\n        this.activeFocused = undefined;\n        this.updateState(rowIdent, colIndex, { focused: false });\n        this.emitFocusChanged(this.activeFocused);\n        if (markForCheck) {\n          const rowContext = this.findRowInView(rowIdent);\n          if (rowContext) {\n            this.extApi.table._cdkTable.syncRows('data', rowContext.index);\n          }\n        }\n      }\n    } else {\n      const ref = resolveCellReference(cellRef, this as any);\n      if (ref) {\n        this.focusCell(markForCheck);\n        if (ref instanceof PblCellContext) {\n          if (!ref.focused && !this.extApi.table.viewport.isScrolling) {\n            this.updateState(ref.rowContext.identity, ref.index, { focused: true });\n\n            this.activeFocused = { rowIdent: ref.rowContext.identity, colIndex: ref.index };\n\n            this.selectCells( [ this.activeFocused ], markForCheck, true);\n\n            if (markForCheck) {\n              this.extApi.table._cdkTable.syncRows('data', ref.rowContext.index);\n            }\n          }\n        } else {\n          this.updateState(ref[0].identity, ref[1], { focused: true });\n          this.activeFocused = { rowIdent: ref[0].identity, colIndex: ref[1] };\n        }\n        this.emitFocusChanged(this.activeFocused);\n      }\n    }\n  }\n\n  /**\n   * Select all provided cells.\n   * @param cellRef A Reference to the cell\n   * @param markForCheck Mark the row for change detection\n   * @param clearCurrent Clear the current selection before applying the new selection.\n   * Default to false (add to current).\n   */\n  selectCells(cellRefs: CellReference[], markForCheck?: boolean, clearCurrent?: boolean): void {\n    const toMarkRendered = new Set<number>();\n\n    if (clearCurrent) {\n      this.unselectCells();\n    }\n\n    const added: GridDataPoint[] = [];\n\n    for (const cellRef of cellRefs) {\n      const ref = resolveCellReference(cellRef, this as any);\n      if (ref instanceof PblCellContext) {\n        if (!ref.selected && !this.extApi.table.viewport.isScrolling) {\n          const rowIdent = ref.rowContext.identity\n          const colIndex = ref.index;\n          this.updateState(rowIdent, colIndex, { selected: true });\n\n          const dataPoint = { rowIdent, colIndex };\n          this.activeSelected.push(dataPoint);\n          added.push(dataPoint);\n\n          if (markForCheck) {\n            toMarkRendered.add(ref.rowContext.index);\n          }\n        }\n      } else if (ref) {\n        const [ rowState, colIndex ] = ref;\n        if (!rowState.cells[colIndex].selected) {\n          this.updateState(rowState.identity, colIndex, { selected: true });\n          this.activeSelected.push( { rowIdent: rowState.identity, colIndex } );\n        }\n      }\n    }\n\n    if (toMarkRendered.size > 0) {\n      this.extApi.table._cdkTable.syncRows('data', ...Array.from(toMarkRendered.values()));\n    }\n\n    this.selectionChanged$.next({ added, removed: [] });\n  }\n\n  /**\n   * Unselect all provided cells.\n   * If cells are not provided will un-select all currently selected cells.\n   * @param cellRef A Reference to the cell\n   * @param markForCheck Mark the row for change detection\n   */\n  unselectCells(cellRefs?: CellReference[] | boolean, markForCheck?: boolean): void {\n    const toMarkRendered = new Set<number>();\n    let toUnselect: CellReference[] = this.activeSelected;\n    let removeAll = true;\n\n    if(Array.isArray(cellRefs)) {\n      toUnselect = cellRefs;\n      removeAll = false;\n    } else {\n      markForCheck = !!cellRefs;\n      this.activeSelected = [];\n    }\n\n    const removed: GridDataPoint[] = [];\n\n    for (const cellRef of toUnselect) {\n      const ref = resolveCellReference(cellRef, this as any);\n      if (ref instanceof PblCellContext) {\n        if (ref.selected) {\n          const rowIdent = ref.rowContext.identity\n          const colIndex = ref.index;\n          this.updateState(rowIdent, colIndex, { selected: false });\n          if (!removeAll) {\n            const wasRemoved = removeFromArray(this.activeSelected, item => item.colIndex === colIndex && item.rowIdent === rowIdent);\n            if (wasRemoved) {\n              removed.push({ rowIdent, colIndex })\n            }\n          }\n          if (markForCheck) {\n            toMarkRendered.add(ref.rowContext.index);\n          }\n        }\n      } else if (ref) {\n        const [ rowState, colIndex ] = ref;\n        if (rowState.cells[colIndex].selected) {\n          this.updateState(rowState.identity, colIndex, { selected: false });\n          if (!removeAll) {\n            const wasRemoved = removeFromArray(this.activeSelected, item => item.colIndex === colIndex && item.rowIdent === rowState.identity);\n            if (wasRemoved) {\n              removed.push({ rowIdent: rowState.identity, colIndex })\n            }\n          }\n        }\n      }\n    }\n\n    if (toMarkRendered.size > 0) {\n      this.extApi.table._cdkTable.syncRows('data', ...Array.from(toMarkRendered.values()));\n    }\n\n    this.selectionChanged$.next({ added: [], removed });\n  }\n\n  clear(): void {\n    for (let i = 0, len = this.vcRef.length; i < len; i++) {\n      const viewRef = this.findViewRef(i);\n      viewRef.context.pblRowContext = undefined;\n    }\n    this.viewCache.clear();\n    this.cache.clear();\n  }\n\n  getRow(row: number | HTMLElement): PblNgridRowContext<T> | undefined {\n    const index = typeof row === 'number' ? row : findRowRenderedIndex(row);\n    return this.rowContext(index);\n  }\n\n  getCell(cell: HTMLElement | GridDataPoint): PblNgridCellContext | undefined\n  /**\n   * Return the cell context for the cell at the point specified\n   * @param row\n   * @param col\n   */\n  getCell(row: number, col: number): PblNgridCellContext | undefined;\n  getCell(rowOrCellElement: number | HTMLElement | GridDataPoint, col?: number): PblNgridCellContext | undefined {\n    if (typeof rowOrCellElement === 'number') {\n      const rowContext = this.rowContext(rowOrCellElement);\n      if (rowContext) {\n        return rowContext.cell(col);\n      }\n    } else {\n      const ref = resolveCellReference(rowOrCellElement, this as any);\n      if (ref instanceof PblCellContext) {\n        return ref;\n      }\n    }\n  }\n\n  getDataItem(cell: CellReference): any {\n    const ref = resolveCellReference(cell, this as any);\n    if (ref instanceof PblCellContext) {\n      return ref.col.getValue(ref.rowContext.$implicit);\n    } else if (ref) {\n      const row = this.extApi.table.ds.source[ref[0].dataIndex];\n      const column = this.extApi.table.columnApi.findColumnAt(ref[1]);\n      return column.getValue(row);\n    }\n  }\n\n  createCellContext(renderRowIndex: number, column: PblColumn): PblCellContext<T> {\n    const rowContext = this.rowContext(renderRowIndex);\n    const colIndex = this.columnApi.indexOf(column);\n    return rowContext.cell(colIndex);\n  }\n\n  rowContext(renderRowIndex: number): PblRowContext<T> | undefined {\n    return this.viewCache.get(renderRowIndex);\n  }\n\n  updateOutOfViewState(rowContext: PblRowContext<T>): void {\n    const viewPortRect = this.getViewRect();\n    const viewRef = this.findViewRef(rowContext.index);\n    processOutOfView(viewRef, viewPortRect);\n  }\n\n  updateState(rowIdentity: any, columnIndex: number, cellState: Partial<CellContextState<T>>): void;\n  updateState(rowIdentity: any, rowState: Partial<RowContextState<T>>): void;\n  updateState(rowIdentity: any, rowStateOrCellIndex: Partial<RowContextState<T>> | number, cellState?: Partial<CellContextState<T>>): void {\n    const currentRowState = this.cache.get(rowIdentity);\n    if (currentRowState) {\n      if (typeof rowStateOrCellIndex === 'number') {\n        const currentCellState = currentRowState.cells[rowStateOrCellIndex];\n        if (currentCellState) {\n          Object.assign(currentCellState, cellState);\n        }\n      } else {\n        Object.assign(currentRowState, rowStateOrCellIndex);\n      }\n      const rowContext = this.findRowInView(rowIdentity);\n      if (rowContext) {\n        rowContext.fromState(currentRowState);\n      }\n    }\n  }\n\n  /**\n   * Try to find a specific row, using the row identity, in the current view.\n   * If the row is not in the view (or even not in the cache) it will return undefined, otherwise returns the row's context instance (`PblRowContext`)\n   * @param rowIdentity The row's identity. If a specific identity is used, please provide it otherwise provide the index of the row in the datasource.\n   */\n  findRowInView(rowIdentity: any): PblRowContext<T> | undefined {\n    const rowState = this.cache.get(rowIdentity);\n    if (rowState) {\n      const renderRowIndex = rowState.dataIndex - this.extApi.table.ds.renderStart;\n      const rowContext = this.viewCache.get(renderRowIndex);\n      if (rowContext && rowContext.identity === rowIdentity) {\n        return rowContext;\n      }\n    }\n  }\n\n  /**\n   * Try to find a specific row context, using the row identity, in the context cache.\n   * Note that the cache does not hold the context itself but only the state that can later be used to retrieve a context instance. The context instance\n   * is only used as context for rows in view.\n   * @param rowIdentity The row's identity. If a specific identity is used, please provide it otherwise provide the index of the row in the datasource.\n   */\n  findRowInCache(rowIdentity: any): RowContextState<T> | undefined;\n  /**\n   * Try to find a specific row context, using the row identity, in the context cache.\n   * Note that the cache does not hold the context itself but only the state that can later be used to retrieve a context instance. The context instance\n   * is only used as context for rows in view.\n   * @param rowIdentity The row's identity. If a specific identity is used, please provide it otherwise provide the index of the row in the datasource.\n   * @param offset When set, returns the row at the offset from the row with the provided row identity. Can be any numeric value (e.g 5, -6, 4).\n   * @param create Whether to create a new state if the current state does not exist.\n   */\n  findRowInCache(rowIdentity: any, offset: number, create: boolean): RowContextState<T> | undefined;\n  findRowInCache(rowIdentity: any, offset?: number, create?: boolean): RowContextState<T> | undefined {\n    const rowState = this.cache.get(rowIdentity);\n\n    if (!offset) {\n      return rowState;\n    } else {\n      const dataIndex = rowState.dataIndex + offset;\n      const identity = this.getRowIdentity(dataIndex);\n      if (identity !== null) {\n        let result = this.findRowInCache(identity);\n        if (!result && create && dataIndex < this.extApi.table.ds.length) {\n          result = PblRowContext.defaultState(identity, dataIndex, this.columnApi.columns.length);\n          this.cache.set(identity, result);\n        }\n        return result;\n      }\n    }\n  }\n\n  getRowIdentity(dataIndex: number, context?: RowContext<any>): string | number | null {\n    const { ds } = this.extApi.table;\n    const { primary } = this.extApi.columnStore;\n\n    const row = context ? context.$implicit : ds.source[dataIndex];\n    if (!row) {\n      return null;\n    } else {\n      return primary ? primary.getValue(row) : dataIndex;\n    }\n  }\n\n  private findViewRef(index: number): EmbeddedViewRef<RowContext<T>> {\n    return this.vcRef.get(index) as EmbeddedViewRef<RowContext<T>>;\n  }\n\n  /**\n   * Find/Update/Create the `RowContext` for the provided `EmbeddedViewRef` at the provided render position.\n   *\n   * A `RowContext` object is a wrapper for the internal context of a row in `CdkTable` with the purpose of\n   * extending it for the table features.\n   *\n   * The process has 2 layers of cache:\n   *\n   * - `RowContext` objects are stored in a view cache which is synced with the `CdkTable` row outlet viewRefs.\n   * Each view ref (row) has a matching record in the `RowContext` view cache.\n   *\n   * - `RowContextState` object are stored in a cache which is synced with the items in the data source.\n   * Each item in the datasource has a matching row `RowContextState` item (lazy), which is used to persist context\n   * when `RowContext` goes in/out of the viewport.\n   *\n   * @param viewRef The `EmbeddedViewRef` holding the context that the returned `RowContext` should wrap\n   * @param renderRowIndex The position of the view, relative to other rows.\n   * The position is required for caching the context state when a specific row is thrown out of the viewport (virtual scroll).\n   * Each `RowContext` gets a unique identity using the position relative to the current render range in the data source.\n   */\n  private findRowContext(viewRef: EmbeddedViewRef<RowContext<T>>, renderRowIndex: number): PblRowContext<T> | undefined {\n    const { context } = viewRef;\n    const dataIndex = this.extApi.table.ds.renderStart + renderRowIndex;\n    const identity = this.getRowIdentity(dataIndex, viewRef.context);\n\n    let rowContext = context.pblRowContext as PblRowContext<T>;\n\n    if (!this.cache.has(identity)) {\n      this.cache.set(identity, PblRowContext.defaultState(identity, dataIndex, this.columnApi.columns.length));\n    }\n\n    if (!rowContext) {\n      rowContext = context.pblRowContext = new PblRowContext<T>(identity, dataIndex, this.extApi);\n      rowContext.updateContext(context);\n\n      viewRef.onDestroy(() => {\n        this.viewCache.delete(renderRowIndex);\n        context.pblRowContext = undefined;\n      });\n\n    } else if (rowContext.identity !== identity) {\n      // save old state before applying new state\n      this.cache.set(rowContext.identity, rowContext.getState());\n      rowContext.updateContext(context);\n\n      // We\n      const gap = dataIndex - rowContext.dataIndex;\n      if (gap > 0) {\n        const siblingViewRef = this.findViewRef(renderRowIndex + gap);\n        const siblingRowContext = siblingViewRef && siblingViewRef.context.pblRowContext as PblRowContext<T>;\n        if (siblingRowContext) {\n          this.cache.set(siblingRowContext.identity, siblingRowContext.getState());\n        }\n      }\n    } else {\n      return rowContext;\n    }\n    rowContext.fromState(this.cache.get(identity));\n\n    return rowContext;\n  }\n\n  private getViewRect(): ClientRect | DOMRect {\n    return this.extApi.table.viewport.elementRef.nativeElement.getBoundingClientRect();\n  }\n\n  private emitFocusChanged(curr: PblNgridFocusChangedEvent['curr']): void {\n    this.focusChanged$.next({\n      prev: this.focusChanged$.value.curr,\n      curr,\n    });\n  }\n\n  private destroy(): void {\n    this.focusChanged$.complete();\n    this.selectionChanged$.complete();\n  }\n}\n\nfunction processOutOfView(viewRef: EmbeddedViewRef<RowContext<any>>, viewPortRect: ClientRect | DOMRect, location?: 'top' | 'bottom'): boolean {\n  const el: HTMLElement = viewRef.rootNodes[0];\n  const rowContext = viewRef.context.pblRowContext;\n  const elRect = el.getBoundingClientRect();\n\n  let isInsideOfView: boolean;\n  switch (location){\n    case 'top':\n      isInsideOfView = elRect.bottom >= viewPortRect.top;\n      break;\n    case 'bottom':\n      isInsideOfView = elRect.top <= viewPortRect.bottom;\n      break;\n    default:\n      isInsideOfView = (elRect.bottom >= viewPortRect.top && elRect.top <= viewPortRect.bottom)\n      break;\n  }\n\n  if (isInsideOfView) {\n    if (!rowContext.outOfView) {\n      return false;\n    }\n    rowContext.outOfView = false;\n  } else {\n    rowContext.outOfView = true;\n  }\n  return true;\n}\n","import { PblColumnSizeInfo } from '../types';\n\nexport interface BoxModelSpaceStrategy {\n  cell(col: PblColumnSizeInfo): number;\n  groupCell(col: PblColumnSizeInfo): number;\n  group(cols: PblColumnSizeInfo[]): number;\n}\n\n/**\n * A column width calculator that calculates column width for a specific column or a group of columns.\n * It also provide the minimum required row width for the total columns added up to that point.\n *\n * The `DynamicColumnWidthLogic` takes into account real-time DOM measurements (especially box-model metadata), hence \"dynamic\".\n * It performs the calculation based on `PblColumn` and actual DOM size metadata.\n *\n * The `DynamicColumnWidthLogic` has 3 responsibilities:\n *\n * - It is responsible for enforcing the `maxWidth` boundary constraint for every column it processes by calculating the actual width\n * of a column and calling `PblColumn.checkMaxWidthLock` to verify if max width lock has changed due to the new actual width.\n *\n * - It calculates the absolute width for a group of columns, so `PblCdkVirtualScrollViewportComponentGroupColumn` can have an exact size that wraps it's children.\n *\n * - It calculates the `minimumRowWidth`, which represents the minimum width required width of the row, i.e. table.\n *\n * > Note that an instance of `DynamicColumnWidthLogic` represents a one-time pass for all columns, for every run a new instance is required.\n */\nexport class DynamicColumnWidthLogic {\n  /**\n   * When true, it indicates that one (or more) columns has changed the max width lock state.\n   * @readonly\n   */\n  maxWidthLockChanged: boolean;\n\n  get minimumRowWidth(): number { return this._minimumRowWidth; };\n\n  private readonly cols = new Map<PblColumnSizeInfo, number>();\n  private _minimumRowWidth = 0;\n\n  constructor(private strategy: BoxModelSpaceStrategy) { }\n\n  /**\n   * Returns a breakout of the width of the column, breaking it into the width of the content and the rest of the width\n   */\n  widthBreakout(columnInfo: PblColumnSizeInfo): { content: number, nonContent: number } {\n    const nonContent = this.strategy.cell(columnInfo);\n    return {\n      content: columnInfo.width - nonContent,\n      nonContent,\n    };\n  }\n\n  /**\n   * Add a column to the calculation.\n   *\n   * The operation will update the minimum required width and trigger a `checkMaxWidthLock` on the column.\n   * If the max width lock has changed the `maxWidthLockChanged` is set to true.\n   *\n   * A column that was previously added is ignored.\n   *\n   * Note that once `maxWidthLockChanged` is set to true it will never change.\n   */\n  addColumn(columnInfo: PblColumnSizeInfo): void {\n    if (!this.cols.has(columnInfo)) {\n      const { column } = columnInfo;\n      let minWidth = column.minWidth || 0;\n      if (column.isFixedWidth) {\n        minWidth = Math.max(column.parsedWidth.value, minWidth);\n      }\n      const nonContent = this.strategy.cell(columnInfo);\n      const width = minWidth + nonContent;\n      this.cols.set(columnInfo, width);\n      this._minimumRowWidth += width;\n\n      if (column.maxWidth) {\n        const actualWidth = columnInfo.width - nonContent;\n        if (column.checkMaxWidthLock(actualWidth)) {\n          this.maxWidthLockChanged = true;\n        }\n      }\n    }\n  }\n\n  /**\n   * Run each of the columns through `addColumn` and returns the sum of the width all columns using\n   * the box model space strategy.\n   *\n   * The result represents the absolute width to be used in a `PblColumnGroup`.\n   *\n   * > Note that when a table has multiple column-group rows each column is the child of multiple group column, hence calling `addColumn` with the\n   * same group more then once. However, since `addColumn()` ignores columns it already processed it is safe.\n   */\n  addGroup(columnInfos: PblColumnSizeInfo[]): number {\n    let sum = 0;\n    for (const c of columnInfos) {\n      this.addColumn(c);\n      sum += c.width;\n    }\n   sum -= this.strategy.group(columnInfos);\n   return sum;\n  }\n\n}\n\nexport const DYNAMIC_PADDING_BOX_MODEL_SPACE_STRATEGY: BoxModelSpaceStrategy = {\n  cell(col: PblColumnSizeInfo): number {\n    const style = col.style;\n    return parseInt(style.paddingLeft) + parseInt(style.paddingRight)\n  },\n  groupCell(col: PblColumnSizeInfo): number {\n    return 0;\n  },\n  group(cols: PblColumnSizeInfo[]): number {\n    const len = cols.length;\n    return len > 0 ? parseInt(cols[0].style.paddingLeft) + parseInt(cols[len - 1].style.paddingRight) : 0;\n  }\n};\n","import { PblNgridExtensionApi } from '../ext/table-ext-api';\nimport { PblNgridComponent } from './table.component';\nimport { PblColumn } from './columns/column';\nimport { PblColumnStore } from './columns/column-store';\n\nexport interface AutoSizeToFitOptions {\n  /**\n   * When `px` will force all columns width to be in fixed pixels\n   * When `%` will force all column width to be in %\n   * otherwise (default) the width will be set in the same format it was originally set.\n   * e.g.: If width was `33%` the new width will also be in %, or if width not set the new width will not be set as well.\n   *\n   * Does not apply when columnBehavior is set and returns a value.\n   */\n  forceWidthType?: '%' | 'px';\n\n  /**\n   * When true will keep the `minWidth` column definition (when set), otherwise will clear it.\n   * Does not apply when columnBehavior is set and returns a value.\n   */\n  keepMinWidth?: boolean;\n\n  /**\n   * When true will keep the `maxWidth` column definition (when set), otherwise will clear it.\n   * Does not apply when columnBehavior is set and returns a value.\n   */\n  keepMaxWidth?: boolean\n\n  /**\n   * A function for per-column fine tuning of the process.\n   * The function receives the `PblColumn`, its relative width (in %, 0 to 1) and total width (in pixels) and should return\n   * an object describing how it should auto fit.\n   *\n   * When the function returns undefined the options are taken from the root.\n   */\n  columnBehavior?(column: PblColumn): Pick<AutoSizeToFitOptions, 'forceWidthType' | 'keepMinWidth' | 'keepMaxWidth'> | undefined;\n}\n\nexport class ColumnApi<T> {\n\n  // workaround, we need a parameter-less constructor since @ngtools/webpack@8.0.4\n  // Non @Injectable classes are now getting addded with hard reference to the ctor params which at the class creation point are undefined\n  // forwardRef() will not help since it's not inject by angular, we instantiate the class..\n  // probably due to https://github.com/angular/angular-cli/commit/639198499973e0f437f059b3c933c72c733d93d8\n  static create<T>(table: PblNgridComponent<T>, store: PblColumnStore, extApi: PblNgridExtensionApi): ColumnApi<T> {\n    const instance = new ColumnApi<T>();\n\n    instance.table = table;\n    instance.store = store;\n    instance.extApi = extApi;\n\n    return instance;\n  }\n\n  get groupByColumns(): PblColumn[] { return this.store.groupBy; }\n  get visibleColumnIds(): string[] { return this.store.columnIds; }\n  get visibleColumns(): PblColumn[] { return this.store.columns; }\n  get columns(): PblColumn[] { return this.store.allColumns; }\n\n  private table: PblNgridComponent<T>;\n  private store: PblColumnStore;\n  private extApi: PblNgridExtensionApi;\n\n  private constructor() { }\n\n  /**\n   * Returns the `PblColumn` at the specified index from the list of rendered columns (i.e. not hidden).\n   */\n  findColumnAt(renderColumnIndex: number): PblColumn | undefined {\n    return this.store.columns[renderColumnIndex];\n  }\n\n  /**\n   * Returns the column matching provided `id`.\n   *\n   * The search is performed on all known columns.\n   */\n  findColumn(id: string): PblColumn | undefined {\n    const result = this.store.find(id);\n    if (result) {\n      return result.data;\n    }\n  }\n\n  /**\n  * Returns the render index of column or -1 if not found.\n  *\n  * The render index represents the current location of the column in the group of visible columns.\n  */\n  renderIndexOf(column: string | PblColumn): number {\n    const c = typeof column === 'string' ? this.findColumn(column) : column;\n    return this.store.columns.indexOf(c);\n  }\n\n  /**\n   * Returns the index of a column or -1 if not found.\n   */\n  indexOf(column: string | PblColumn): number {\n    const c = typeof column === 'string' ? this.findColumn(column) : column;\n    return this.store.allColumns.indexOf(c);\n  }\n\n  /**\n   * Update the width of the column with the provided width.\n   *\n   * The width is set in px or % in the following format: ##% or ##px\n   * Examples: '50%', '50px'\n   *\n   * Resizing the column will trigger a table width resizing event, updating column group if necessary.\n   */\n  resizeColumn(column: PblColumn, width: string): void {\n    column.updateWidth(true, width)\n    this.table.resetColumnsWidth();\n    this.table.resizeColumns();\n  }\n\n  /**\n   * Resize the column to best fit it's content.\n   *\n   * - Content: All of the cells rendered for this column (header, data and footer cells).\n   * - Best fit: The width of the cell with the height width measured.\n   *\n   * The best fit found (width) is then used to call `resizeColumn()`.\n   */\n  autoSizeColumn(column: PblColumn): void {\n    const size = this.findColumnAutoSize(column);\n    this.resizeColumn(column, `${size}px`);\n  }\n\n  /**\n   * For each visible column in the table, resize to best fit it's content.\n   *\n   * This method will simply run `autoSizeColumn()` on the visible columns in the table.\n   */\n  autoSizeColumns(): void;\n  /**\n   * For each column in the list of column provided, resize to best fit it's content.\n   *\n   * Make sure you are not resizing an hidden column.\n   * This method will simply run `autoSizeColumn()` on the columns provided.\n   */\n  autoSizeColumns(...columns: PblColumn[]): void; // tslint:disable-line:unified-signatures\n  autoSizeColumns(...columns: PblColumn[]): void {\n    const cols = columns.length > 0 ? columns : this.visibleColumns;\n    for (const column of cols) {\n      const size = this.findColumnAutoSize(column);\n      column.updateWidth(true, `${size}px`)\n    }\n    this.table.resetColumnsWidth();\n    this.table.resizeColumns();\n  }\n\n  /**\n   * For each visible column in the table, resize the width to a proportional width relative to the total width provided.\n   */\n  autoSizeToFit(totalWidth: number, options: AutoSizeToFitOptions = {}): void {\n    const wLogic = this.extApi.dynamicColumnWidthFactory();\n    const { visibleColumns } = this;\n    const columnBehavior: AutoSizeToFitOptions['columnBehavior'] = options.columnBehavior || ( () => options ) as any;\n\n    let overflowTotalWidth = 0;\n    let totalMinWidth = 0;\n\n    const withMinWidth: number[] = [];\n\n    const widthBreakouts = visibleColumns.map( (column, index) => {\n      const widthBreakout = wLogic.widthBreakout(column.sizeInfo);\n      const instructions = columnBehavior(column) || options;\n\n      overflowTotalWidth += widthBreakout.content;\n      totalWidth -= widthBreakout.nonContent;\n\n      if (instructions.keepMinWidth && column.minWidth) {\n        totalMinWidth += column.minWidth;\n        withMinWidth.push(index);\n      }\n\n      return { ...widthBreakout, instructions };\n    });\n\n    const p = totalMinWidth / totalWidth;\n    const level = (overflowTotalWidth * p  - totalMinWidth) / (1 - p);\n    for (const i of withMinWidth) {\n      const addition = level * (visibleColumns[i].minWidth / totalMinWidth)\n      widthBreakouts[i].content += addition;\n      overflowTotalWidth += addition;\n    }\n\n    let sum =[];\n    for (let i = 0; i < visibleColumns.length; i++) {\n      const widthBreakout = widthBreakouts[i];\n      const instructions = widthBreakout.instructions;\n      const column = visibleColumns[i];\n\n      const r = widthBreakout.content / overflowTotalWidth;\n\n      if (!instructions.keepMinWidth) {\n        column.minWidth = undefined;\n      }\n      if (!instructions.keepMaxWidth) {\n         column.maxWidth = undefined;\n         column.checkMaxWidthLock(column.sizeInfo.width); // if its locked, we need to release...\n      }\n\n      // There are 3 scenarios when updating the column\n      // 1) if it's a fixed width or we're force into fixed width\n      // 2) Not fixed width and width is set (%)\n      // 3) Not fixed width an width is not set ( the width depends on the calculated `defaultWidth` done in `this.table.resetColumnsWidth()` )\n      let width: string;\n      const { forceWidthType } = instructions;\n      if (forceWidthType === 'px' || (!forceWidthType && column.isFixedWidth)) { // (1)\n        width = `${totalWidth * r}px`;\n      } else if (forceWidthType === '%' || (!forceWidthType && column.width)) { // (2)\n        width = `${100 * r}%`;\n      } // else (3) -> the update is skipped and it will run through resetColumnsWidth\n\n      if (width) {\n        // We're not updating the width width markForCheck set to true because it will be done right after in `this.table.resetColumnsWidth()`\n        column.updateWidth(false, width);\n      }\n\n    }\n    // we now reset the column widths, this will calculate a new `defaultWidth` and set it in all columns but the relevant ones are column from (3)\n    // It will also mark all columnDef's for check\n    this.table.resetColumnsWidth({ tableMarkForCheck: true });\n    this.table.resizeColumns();\n  }\n\n  /**\n   * Move the provided `column` to the position of the `anchor` column.\n   * The new location of the anchor column will be it's original location plus or minus 1, depending on the delta between\n   * the columns. If the origin of the `column` is before the `anchor` then the anchor's new position is minus one, otherwise plus 1.\n   */\n  moveColumn(column: PblColumn, anchor: PblColumn, skipRedraw?: boolean): boolean;\n    /**\n   * Move the provided `column` to the position of the column at `renderColumnIndex`.\n   * `renderColumnIndex` must be a visible column (i.e. not hidden)\n   */\n  moveColumn(column: PblColumn, renderColumnIndex: number, skipRedraw?: boolean): boolean; // tslint:disable-line:unified-signatures\n  moveColumn(column: PblColumn, anchor: PblColumn | number, skipRedraw?: boolean): boolean {\n    if (anchor instanceof PblColumn) {\n      const result = column === anchor ? false : this.store.moveColumn(column, anchor);\n      if (result && skipRedraw !== true) {\n        this.afterColumnPositionChange();\n      }\n      return result;\n    } else {\n      const a = this.findColumnAt(anchor);\n      return a ? this.moveColumn(column, a) : false;\n    }\n  }\n\n  /**\n   * Swap positions between 2 existing columns.\n   */\n  swapColumns(col1: PblColumn, col2: PblColumn, skipRedraw?: boolean): boolean {\n    const result = this.store.swapColumns(col1, col2);\n    if (result && skipRedraw !== true) {\n      this.afterColumnPositionChange();\n    }\n    return result;\n  }\n\n  addGroupBy(...column: PblColumn[]): void { this.store.addGroupBy(...column); }\n  removeGroupBy(...column: PblColumn[]): void { this.store.removeGroupBy(...column); }\n\n  private findColumnAutoSize(column: PblColumn): number {\n    const { columnDef } = column;\n    const cells = columnDef.queryCellElements();\n    let size = 0;\n    for (const c of cells) {\n      const element = (c.firstElementChild || c) as HTMLElement;\n      if (element.scrollWidth > size) {\n        size = element.scrollWidth + 1;\n        // we add 1 pixel because `element.scrollWidth` does not support subpixel values, the width is converted to an integer removing subpixel values (fractions).\n      }\n    }\n    return size;\n  }\n\n  private afterColumnPositionChange(): void {\n    this.extApi.contextApi.clear();\n    this.store.updateGroups();\n    this.table.resetColumnsWidth();\n    this.table.resizeColumns();\n  }\n}\n","import { animationFrameScheduler, Observable, Subject, asapScheduler } from 'rxjs';\nimport { auditTime, filter, take, debounceTime } from 'rxjs/operators';\n\nimport { Injectable, Inject } from '@angular/core';\n\nimport { PblNgridExtensionApi, EXT_API_TOKEN } from '../../ext/table-ext-api';\nimport { PblMetaRowDefinitions } from '../columns/types';\nimport { PblMetaRowDirective } from './meta-row.directive';\n\nfunction metaRowSectionFactory(): MetaRowSection {\n  return { fixed: [], row: [], sticky: [], all: [] };\n}\n\nexport interface MetaRowSection {\n  fixed: Array<{ index: number, rowDef: PblMetaRowDefinitions; el?: HTMLElement; }>;\n  row: Array<{ index: number, rowDef: PblMetaRowDefinitions; el?: HTMLElement; }>;\n  sticky: Array<{ index: number, rowDef: PblMetaRowDefinitions; el?: HTMLElement; }>;\n  all: PblMetaRowDefinitions[];\n}\n\n@Injectable()\nexport class PblNgridMetaRowService<T = any> {\n  header: MetaRowSection = metaRowSectionFactory();\n  footer: MetaRowSection = metaRowSectionFactory();\n\n  readonly sync: Observable<void>;\n  readonly hzScroll: Observable<number>;\n  private sync$ = new Subject<void>();\n  private hzScroll$ = new Subject<number>();\n\n  constructor(@Inject(EXT_API_TOKEN) public readonly extApi: PblNgridExtensionApi<T>) {\n    this.sync = this.sync$ // TODO: complete\n      .pipe(\n        debounceTime(0, asapScheduler),\n      );\n\n    this.hzScroll = this.hzScroll$.asObservable();\n\n    extApi.onInit(() => {\n      const { table } = extApi;\n      let hzOffset = table.viewport.measureScrollOffset('start');\n      let trackScroll = true;\n      table.viewport.elementScrolled()\n        .pipe(\n          filter( () => trackScroll ),\n          auditTime(0, animationFrameScheduler),\n        )\n        .subscribe(() => {\n          const newOffset = table.viewport.measureScrollOffset('start');\n          if (hzOffset !== newOffset) {\n            this.hzScroll$.next(hzOffset = newOffset);\n          } else if (table.viewport.isScrolling) {\n            trackScroll = false;\n            table.viewport.scrolling\n              .pipe(take(1))\n              .subscribe( () => trackScroll = true );\n          }\n        }, null, () => this.hzScroll$.complete() );\n    });\n  }\n\n  addMetaRow(metaRow: PblMetaRowDirective): void {\n    const { columnStore } = this.extApi;\n    const { header, footer } = columnStore.metaColumnIds;\n\n    const rowDef = metaRow.meta;\n    if (rowDef === columnStore.footerColumnDef) {\n      this.addToSection(this.footer, metaRow, 0);\n    } else if (rowDef === columnStore.headerColumnDef) {\n      this.addToSection(this.header, metaRow, columnStore.metaColumnIds.header.length);\n    } else {\n      let index = header.findIndex( h => h.rowDef === rowDef );\n      if (index > -1) {\n        this.addToSection(this.header, metaRow, index);\n      } else {\n        index = footer.findIndex( h => h.rowDef === rowDef );\n        if (index > -1) {\n          this.addToSection(this.footer, metaRow, index);\n        } else {\n          throw new Error('Invalid operation');\n        }\n      }\n    }\n    this.sync$.next();\n  }\n\n  removeMetaRow(metaRow: PblMetaRowDirective): void {\n    const rowDef = metaRow.meta;\n    let index = this.header.all.indexOf(metaRow.meta);\n    if (index > -1) {\n      this.header.all.splice(index, 1);\n      index = this.header[rowDef.type].findIndex( h => h.rowDef === rowDef );\n      this.header[rowDef.type].splice(index, 1);\n    } else if ( (index = this.footer.all.indexOf(metaRow.meta)) > -1) {\n      this.footer.all.splice(index, 1);\n      index = this.footer[rowDef.type].findIndex( h => h.rowDef === rowDef );\n      this.footer[rowDef.type].splice(index, 1);\n    }\n  }\n\n  private addToSection(section: MetaRowSection, metaRow: PblMetaRowDirective, index: number): void {\n    const rowDef = metaRow.meta;\n    section[rowDef.type].push( { index, rowDef, el: metaRow.elRef.nativeElement } );\n    section.all.push(rowDef);\n  }\n}\n","import { Component, Input, ElementRef } from '@angular/core';\n\nimport { UnRx } from '@pebula/utils';\n\nimport { PblMetaRowDefinitions } from '../columns/types';\nimport { PblNgridMetaRowService } from './meta-row.service';\n\n@Component({\n  selector: 'div[pbl-ngrid-fixed-meta-row-container]',\n  template: `<div class=\"pbl-cdk-table\" [style.width.px]=\"_width\"></div>`,\n  host: { // tslint:disable-line:use-host-property-decorator\n    style: 'flex: 0 0 auto; overflow: hidden;',\n    '[style.width.px]': '_innerWidth',\n  },\n})\n@UnRx()\nexport class PblNgridMetaRowContainerComponent {\n\n  @Input('pbl-ngrid-fixed-meta-row-container') set type(value: 'header' | 'footer') {\n    if (this._type !== value) {\n      this.init(value);\n    }\n  };\n\n  /**\n   * The inner width of the table, the viewport width of a row.\n   * The width of the table minus scroll bar.\n   */\n  _innerWidth: number;\n  _minWidth: number;\n  _width: number;\n\n  private _type: 'header' | 'footer';\n  private defs: Array<{ index: number; rowDef: PblMetaRowDefinitions }>;\n  private element: HTMLElement;\n\n  constructor(public readonly metaRows: PblNgridMetaRowService, elRef: ElementRef<HTMLElement>) {\n    this.element = elRef.nativeElement;\n    metaRows.sync.pipe(UnRx(this)).subscribe( () => this.syncRowDefinitions() );\n    this.metaRows.extApi.events\n      .pipe(UnRx(this))\n      .subscribe( event => {\n        if (event.kind === 'onResizeRow') {\n          this._innerWidth = this.metaRows.extApi.table.viewport.innerWidth;\n          this._minWidth = this.metaRows.extApi.cdkTable.minWidth;\n          this._width = Math.max(this._innerWidth, this._minWidth);\n        }\n      });\n  }\n\n  private init(type: 'header' | 'footer'): void {\n\n    if (type === 'header') {\n      this._type = type;\n    } else {\n      this._type = 'footer';\n    }\n\n    const scrollContainerElement = this.element;\n    scrollContainerElement.scrollLeft = this.metaRows.extApi.table.viewport.measureScrollOffset('start');\n\n    this.metaRows.hzScroll\n      .pipe(UnRx(this))\n      .subscribe( offset => scrollContainerElement.scrollLeft = offset );\n\n    this.metaRows.extApi.cdkTable.onRenderRows\n      .pipe(UnRx(this))\n      .subscribe( () => {\n        this._innerWidth = this.metaRows.extApi.table.viewport.innerWidth;\n        this._width = Math.max(this._innerWidth, this._minWidth);\n      });\n  }\n\n  private syncRowDefinitions(): void {\n    this.defs = [];\n    const isHeader = this._type === 'header';\n    const section = isHeader ? this.metaRows.header : this.metaRows.footer;\n\n    const container = this.element.firstElementChild;\n    for (const def of section.fixed) {\n      this.defs.push(def);\n      container.appendChild(def.el);\n    }\n  }\n}\n","import { Directive, Input, ElementRef, OnDestroy } from '@angular/core';\n\nimport { UnRx } from '@pebula/utils';\n\nimport { PblMetaRowDefinitions } from '../columns/types';\n\nimport { PblColumnStoreMetaRow } from '../columns/column-store';\nimport { PblNgridMetaRowService } from './meta-row.service';\n\n\n@Directive({\n  selector: '[pblMetaRow]',\n})\n@UnRx()\nexport class PblMetaRowDirective implements OnDestroy {\n\n  // tslint:disable-next-line:no-input-rename\n  @Input('pblMetaRow') get meta(): PblMetaRowDefinitions { return this._meta; }\n  set meta(value: PblMetaRowDefinitions) {\n    if (value !== this._meta) {\n      this.update(value);\n    }\n  }\n\n  private _meta: PblMetaRowDefinitions;\n\n  constructor(public readonly metaRows: PblNgridMetaRowService, public elRef: ElementRef<HTMLElement>) {\n\n  }\n\n  ngOnDestroy(): void {\n    this.metaRows.removeMetaRow(this);\n  }\n\n  private update(meta: PblMetaRowDefinitions): void {\n    const oldMeta = this._meta;\n\n    if (oldMeta) {\n      if(oldMeta.rowClassName) {\n        this.elRef.nativeElement.classList.remove(oldMeta.rowClassName);\n      }\n      this.metaRows.removeMetaRow(this);\n    }\n    this._meta = meta;\n    if (meta) {\n      if (meta.rowClassName) {\n        this.elRef.nativeElement.classList.add(meta.rowClassName);\n      }\n      this.metaRows.addMetaRow(this);\n    }\n  }\n}\n","import { isDevMode } from '@angular/core';\nimport { PblColumnStore } from '../table/columns/column-store';\n\nexport function setIdentityProp(store: PblColumnStore, identityProp: string): void {\n  if (store.allColumns.length > 0 && identityProp) {\n    // STATES:\n    //    1: identityProp but also primary\n    //    2: identityProp, no primary, AND not found\n    //    3: identityProp, no primary but found.\n    let state = 1;\n    if (!store.primary) {\n      state = 2;\n      const column = store.find(identityProp);\n      if (column && column.data) {\n        state = 3;\n        store['_primary'] = column.data;\n      }\n    }\n\n    if (isDevMode()) {\n      const genericMsg = `The [identityProp] input is deprecated, please remove it and use \"pIndex\" on the column definition instead.`;\n      switch (state) {\n        case 1:\n          console.warn(\n`${genericMsg}\nFound column \"${store.primary.id}\" defined with the new method (pIndex), ignoring \"${identityProp}\" set in [identityProp]`\n);\n          break;\n        case 2:\n          console.warn(\n`${genericMsg}\nCould not find a column defined with the new method (pIndex).\nTrying to locate the column \"${identityProp}\" defined in [identityProp] FAILED! with no match.\nAN IDENTITY COLUMN WAS NOT SET`\n);\n          break;\n        case 3:\n            console.warn(\n`${genericMsg}\nCould not find a column defined with the new method (pIndex).\nTrying to locate the column \"${identityProp}\" defined in [identityProp] SUCCEEDED!.\nUSING \"${identityProp}\" AS THE IDENTITY COLUMN.`\n);\n          break;\n      }\n    }\n  }\n}\n","import ResizeObserver from 'resize-observer-polyfill';\nimport { asapScheduler, animationFrameScheduler, fromEventPattern } from 'rxjs';\nimport { filter, take, tap, observeOn, switchMap, map, mapTo, startWith, pairwise, debounceTime, skip } from 'rxjs/operators';\nimport {\n  AfterViewInit,\n  Component,\n  ElementRef,\n  Input,\n  Injector,\n  ChangeDetectionStrategy,\n  ViewChild,\n  ViewChildren,\n  QueryList,\n  AfterContentInit,\n  ViewEncapsulation,\n  OnChanges,\n  OnDestroy,\n  SimpleChanges,\n  ChangeDetectorRef,\n  TemplateRef,\n  ViewContainerRef,\n  EmbeddedViewRef,\n  NgZone,\n  isDevMode, forwardRef, IterableDiffers, IterableDiffer, DoCheck, Attribute,\n} from '@angular/core';\n\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport { CdkHeaderRowDef, CdkFooterRowDef, CdkRowDef } from '@angular/cdk/table';\n\nimport { UnRx } from '@pebula/utils';\n\nimport { EXT_API_TOKEN, PblNgridExtensionApi } from '../ext/table-ext-api';\nimport { PblNgridPluginController, PblNgridPluginContext } from '../ext/plugin-control';\nimport { PblNgridPaginatorKind } from '../paginator';\nimport { DataSourcePredicate, DataSourceFilterToken, PblNgridSortDefinition, PblDataSource, DataSourceOf, createDS } from '../data-source/index';\nimport { PblCdkTableComponent } from './pbl-cdk-table/pbl-cdk-table.component';\nimport { resetColumnWidths } from './utils';\nimport { findCellDef } from './directives/cell-def';\nimport { PblColumn, PblColumnStore, PblMetaColumnStore, PblNgridColumnSet, PblNgridColumnDefinitionSet } from './columns';\nimport { PblNgridCellContext, PblNgridMetaCellContext, ContextApi, PblNgridContextApi, PblNgridRowContext } from './context/index';\nimport { PblNgridRegistryService } from './services/table-registry.service';\nimport { PblNgridConfigService } from './services/config';\nimport { DynamicColumnWidthLogic, DYNAMIC_PADDING_BOX_MODEL_SPACE_STRATEGY } from './col-width-logic/dynamic-column-width';\nimport { ColumnApi, AutoSizeToFitOptions } from './column-api';\nimport { PblCdkVirtualScrollViewportComponent } from './features/virtual-scroll/virtual-scroll-viewport.component';\nimport { PblNgridMetaRowService } from './meta-rows/index';\n\nimport { bindToDataSource } from './bind-to-datasource';\nimport './bind-to-datasource'; // LEAVE THIS, WE NEED IT SO THE AUGMENTATION IN THE FILE WILL LOAD.\n\nimport { setIdentityProp } from './table.deprecate-at-1.0.0';\n\nexport function internalApiFactory(table: { _extApi: PblNgridExtensionApi; }) { return table._extApi; }\nexport function pluginControllerFactory(table: { _plugin: PblNgridPluginContext; }) { return table._plugin.controller; }\nexport function metaRowServiceFactory(table: { _extApi: PblNgridExtensionApi; }) { return table._extApi.metaRowService; }\n\n@Component({\n  selector: 'pbl-ngrid',\n  templateUrl: './table.component.html',\n  styleUrls: [ './table.component.scss' ],\n  providers: [\n    PblNgridRegistryService,\n    {\n      provide: PblNgridPluginController,\n      useFactory: pluginControllerFactory,\n      deps: [forwardRef(() => PblNgridComponent)],\n    },\n    {\n      provide: EXT_API_TOKEN,\n      useFactory: internalApiFactory,\n      deps: [forwardRef(() => PblNgridComponent)],\n    },\n    {\n      provide: PblNgridMetaRowService,\n      useFactory: metaRowServiceFactory,\n      deps: [forwardRef(() => PblNgridComponent)],\n    }\n  ],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n})\n@UnRx()\nexport class PblNgridComponent<T = any> implements AfterContentInit, AfterViewInit, DoCheck, OnChanges, OnDestroy {\n\n  /**\n   * Show/Hide the header row.\n   * Default: true\n   */\n  @Input() get showHeader(): boolean { return this._showHeader; };\n  set showHeader(value: boolean) {\n    this._showHeader = coerceBooleanProperty(value);\n  }\n  _showHeader: boolean;\n\n  /**\n   * Show/Hide the footer row.\n   * Default: false\n   */\n  @Input() get showFooter(): boolean { return this._showFooter; };\n  set showFooter(value: boolean) {\n    this._showFooter = coerceBooleanProperty(value);\n  }\n  _showFooter: boolean;\n\n  /**\n   * When true, the filler is disabled.\n   */\n  @Input() get noFiller(): boolean { return this._noFiller; };\n  set noFiller(value: boolean) {\n    this._noFiller = coerceBooleanProperty(value);\n  }\n  _noFiller: boolean;\n\n  /**\n   * Set's the behavior of the table when tabbing.\n   * The default behavior is none (rows and cells are not focusable)\n   *\n   * Note that the focus mode has an effect on other functions, for example a detail row will toggle (open/close) using\n   * ENTER / SPACE only when focusMode is set to `row`.\n   */\n  @Input() focusMode: 'row' | 'cell' | 'none' | '' | false | undefined;\n\n  /// TODO(shlomiassaf): Remove in 1.0.0\n  /**\n   * @deprecated Use `pIndex` in the column definition. (Removed in 1.0.0)\n   */\n  @Input() get identityProp(): string { return this.__identityProp; }\n  set identityProp(value: string) { this.__identityProp = value; setIdentityProp(this._store, value); }\n  private __identityProp: string;\n\n  /**\n   * The table's source of data\n   *\n   * @remarks\n   * The table's source of data, which can be provided in 2 ways:\n   *\n   * - DataSourceOf<T>\n   * - PblDataSource<T>\n   *\n   * The table only works with `PblDataSource<T>`, `DataSourceOf<T>` is a shortcut for providing\n   * the data array directly.\n   *\n   * `DataSourceOf<T>` can be:\n   *\n   * - Simple data array (each object represents one table row)\n   * - Promise for a data array\n   * - Stream that emits a data array each time the array changes\n   *\n   * When a `DataSourceOf<T>` is provided it is converted into an instance of `PblDataSource<T>`.\n   *\n   * To access the `PblDataSource<T>` instance use the `ds` property (readonly).\n   *\n   * It is highly recommended to use `PblDataSource<T>` directly, the datasource factory makes it easy.\n   * For example, when an array is provided the factory is used to convert it to a datasource:\n   *\n   * ```typescript\n   * const collection: T[] = [];\n   * const pblDataSource = createDS<T>().onTrigger( () => collection ).create();\n   * ```\n   *\n   * > This is a write-only (setter) property that triggers the `setDataSource` method.\n   */\n  @Input() set dataSource(value: PblDataSource<T> | DataSourceOf<T>) {\n    if (value instanceof PblDataSource) {\n      this.setDataSource(value);\n    } else {\n      this.setDataSource(createDS<T>().onTrigger( () => value || [] ).create());\n    }\n  }\n\n  get ds(): PblDataSource<T> { return this._dataSource; };\n\n  @Input() get usePagination(): PblNgridPaginatorKind | false { return this._pagination; }\n  set usePagination(value: PblNgridPaginatorKind | false) {\n    if ((value as any) === '') {\n      value = 'pageNumber';\n    }\n    if ( value !== this._pagination ) {\n      this._pagination = value;\n      this.setupPaginator();\n    }\n  }\n\n  @Input() get noCachePaginator(): boolean { return this._noCachePaginator; }\n  set noCachePaginator(value: boolean) {\n    value = coerceBooleanProperty(value);\n    if (this._noCachePaginator !== value) {\n      this._noCachePaginator = value;\n      if (this.ds && this.ds.paginator) {\n        this.ds.paginator.noCacheMode = value;\n      }\n    }\n  }\n\n  /**\n   * The column definitions for this table.\n   */\n  @Input() columns: PblNgridColumnSet | PblNgridColumnDefinitionSet;\n\n  @Input() set hideColumns(value: string[]) {\n    this._hideColumns = value;\n    this._hideColumnsDirty = true;\n  }\n\n  /**\n   * A fallback height for \"the inner scroll container\".\n   * The fallback is used only when it LOWER than the rendered height, so no empty gaps are created when setting the fallback.\n   *\n   * The \"inner scroll container\" is the area in which all data rows are rendered and all meta (header/footer) rows that are of type \"row\" or \"sticky\".\n   * The \"inner scroll container\" is defined to consume all the height left after all external objects are rendered.\n   * External objects can be fixed meta rows (header/footer), pagination row, action row etc...\n   *\n   * If the table does not have a height (% or px) the \"inner scroll container\" will always have no height (0).\n   * If the table has a height, the \"inner scroll container\" will get the height left, which can also be 0 if there are a lot of external objects.\n   *\n   * To solve the no-height problem we use the fallbackMinHeight property.\n   *\n   * When virtual scroll is disabled and fallbackMinHeight is not set the table will set the \"inner scroll container\" height to show all rows.\n   *\n   * Note that when using a fixed (px) height for the table, if the height of all external objects + the height of the \"inner scroll container\" is greater then\n   * the table's height a vertical scroll bar will show.\n   * If the \"inner scroll container\"s height will be lower then it's rendered content height and additional vertical scroll bar will appear, which is, usually, not good.\n   *\n   * To avoid this, don't use fallbackMinHeight together with a fixed height for the table. Instead use fallbackMinHeight together with a min height for the table.\n   */\n  @Input() get fallbackMinHeight(): number { return this._fallbackMinHeight; }\n  set fallbackMinHeight(value: number) {\n    value = coerceNumberProperty(value);\n    if (this._fallbackMinHeight !== value) {\n      this._fallbackMinHeight = value;\n    }\n  }\n\n  @Input() rowClassUpdate: undefined | ( (context: PblNgridRowContext<T>) => ( string | string[] | Set<string> | { [klass: string]: any } ));\n  @Input() rowClassUpdateFreq: 'item' | 'ngDoCheck' | 'none' = 'item';\n\n  rowFocus: 0 | '' = '';\n  cellFocus: 0 | '' = '';\n\n  private _fallbackMinHeight = 0;\n  private _dataSource: PblDataSource<T>;\n\n  @ViewChild('beforeTable', { read: ViewContainerRef, static: true }) _vcRefBeforeTable: ViewContainerRef;\n  @ViewChild('beforeContent', { read: ViewContainerRef, static: true }) _vcRefBeforeContent: ViewContainerRef;\n  @ViewChild('afterContent', { read: ViewContainerRef, static: true }) _vcRefAfterContent: ViewContainerRef;\n  @ViewChild('fbTableCell', { read: TemplateRef, static: true }) _fbTableCell: TemplateRef<PblNgridCellContext<T>>;\n  @ViewChild('fbHeaderCell', { read: TemplateRef, static: true }) _fbHeaderCell: TemplateRef<PblNgridMetaCellContext<T>>;\n  @ViewChild('fbFooterCell', { read: TemplateRef, static: true }) _fbFooterCell: TemplateRef<PblNgridMetaCellContext<T>>;\n  @ViewChild(CdkRowDef, { static: true }) _tableRowDef: CdkRowDef<T>;\n  @ViewChildren(CdkHeaderRowDef) _headerRowDefs: QueryList<CdkHeaderRowDef>;\n  @ViewChildren(CdkFooterRowDef) _footerRowDefs: QueryList<CdkFooterRowDef>;\n\n  get metaColumnIds(): PblColumnStore['metaColumnIds'] { return this._store.metaColumnIds; }\n  get metaColumns(): PblColumnStore['metaColumns'] { return this._store.metaColumns; }\n  get columnRowDef() { return { header: this._store.headerColumnDef, footer: this._store.footerColumnDef }; }\n  /**\n   * True when the component is initialized (after AfterViewInit)\n   */\n  readonly isInit: boolean;\n  readonly columnApi: ColumnApi<T>;\n  get contextApi(): PblNgridContextApi<T> { return this._extApi.contextApi; }\n\n  get viewport(): PblCdkVirtualScrollViewportComponent | undefined { return this._viewport; }\n\n  _cdkTable: PblCdkTableComponent<T>;\n  private _store: PblColumnStore = new PblColumnStore();\n  private _hideColumnsDirty: boolean;\n  private _hideColumns: string[];\n  private _colHideDiffer: IterableDiffer<string>;\n  private _noDateEmbeddedVRef: EmbeddedViewRef<any>;\n  private _paginatorEmbeddedVRef: EmbeddedViewRef<any>;\n  private _pagination: PblNgridPaginatorKind | false;\n  private _noCachePaginator = false;\n  private _minimumRowWidth: string;\n  private _viewport?: PblCdkVirtualScrollViewportComponent;\n  private _plugin: PblNgridPluginContext;\n  private _extApi: PblNgridExtensionApi<T>;\n\n  constructor(injector: Injector, vcRef: ViewContainerRef,\n              private elRef: ElementRef<HTMLElement>,\n              private differs: IterableDiffers,\n              private ngZone: NgZone,\n              private cdr: ChangeDetectorRef,\n              private config: PblNgridConfigService,\n              public registry: PblNgridRegistryService,\n              @Attribute('id') public readonly id: string) {\n    const tableConfig = config.get('table');\n    this.showHeader = tableConfig.showHeader;\n    this.showFooter = tableConfig.showFooter;\n    this.noFiller = tableConfig.noFiller;\n\n    this.initExtApi();\n    this.columnApi = ColumnApi.create<T>(this, this._store, this._extApi);\n    this.initPlugins(injector, elRef, vcRef);\n  }\n\n  ngDoCheck(): void {\n    if (this._hideColumnsDirty) {\n      this._hideColumnsDirty = false;\n      const value = this._hideColumns;\n      if (!this._colHideDiffer && value) {\n        try {\n          this._colHideDiffer = this.differs.find(value).create();\n        } catch (e) {\n          throw new Error(`Cannot find a differ supporting object '${value}. hideColumns only supports binding to Iterables such as Arrays.`);\n        }\n      }\n    }\n    if (this._colHideDiffer) {\n      const hideColumns = this._hideColumns || [];\n      const changes = this._colHideDiffer.diff(hideColumns);\n      if (changes) {\n        this._store.hidden = hideColumns;\n        this._minimumRowWidth = '';\n\n        // TODO(shlomiassaf) [perf, 4]: Right now we attach all columns, we can improve it by attaching only those \"added\" (we know them from \"changes\")\n        this.attachCustomCellTemplates();\n        this.attachCustomHeaderCellTemplates();\n        this._cdkTable.syncRows('header');\n      }\n      if (!this._hideColumns) {\n        this._colHideDiffer = undefined;\n      }\n    }\n  }\n\n  ngAfterContentInit(): void {\n    // no need to unsubscribe, the reg service is per table instance and it will destroy when this table destroy.\n    // Also, at this point initial changes from templates provided in the content are already inside so they will not trigger\n    // the order here is very important, because component top of this table will fire life cycle hooks AFTER this component\n    // so if we have a top level component registering a template on top it will not show unless we listen.\n    this.registry.changes.subscribe( changes => {\n      let tableCell = false;\n      let headerFooterCell = false;\n      for (const c of changes) {\n        switch (c.type) {\n          case 'tableCell':\n            tableCell = true;\n            break;\n          case 'headerCell':\n          case 'footerCell':\n            headerFooterCell = true;\n            break;\n          case 'noData':\n            this.setupNoData();\n            break;\n          case 'paginator':\n            this.setupPaginator();\n            break;\n        }\n      }\n      if (tableCell) {\n        this.attachCustomCellTemplates();\n      }\n      if (headerFooterCell) {\n        this.attachCustomHeaderCellTemplates();\n      }\n    });\n  }\n\n  ngAfterViewInit(): void {\n    this.invalidateColumns();\n\n    Object.defineProperty(this, 'isInit', { value: true });\n    this._plugin.emitEvent({ kind: 'onInit' });\n\n    this.setupPaginator();\n\n    // Adding a div before the footer row view reference, this div will be used to fill up the space between header & footer rows\n    const div = document.createElement('div');\n    div.classList.add('pbl-ngrid-empty-spacer')\n    this._cdkTable._element.insertBefore(div, this._cdkTable._footerRowOutlet.elementRef.nativeElement);\n    this.listenToResize();\n\n    // The following code will catch context focused events, find the HTML element of the cell and focus it.\n    this.contextApi.focusChanged\n      .subscribe( event => {\n        if (event.curr) {\n          const rowContext = this.contextApi.findRowInView(event.curr.rowIdent);\n          if (rowContext) {\n            const view = this._cdkTable._rowOutlet.viewContainer.get(rowContext.index) as EmbeddedViewRef<any>;\n            if (view) {\n              const cellViewIndex = this.columnApi.renderIndexOf(this.columnApi.columns[event.curr.colIndex])\n              const cellElement = view.rootNodes[0].querySelectorAll('pbl-ngrid-cell')[cellViewIndex];\n              if (cellElement) {\n                cellElement.focus();\n              }\n            }\n          }\n        }\n      });\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    let processColumns = false;\n\n    if (changes.focusMode) {\n      this.rowFocus = this.focusMode === 'row' ? 0 : '';\n      this.cellFocus = this.focusMode === 'cell' ? 0 : '';\n    }\n\n    if ( changes.columns && this.isInit ) {\n      processColumns = true;\n    }\n\n    if ( processColumns === true ) {\n      this.invalidateColumns();\n    }\n  }\n\n  ngOnDestroy(): void {\n    const destroy = () => {\n      this._plugin.destroy();\n      if (this._viewport) {\n        this._cdkTable.detachViewPort();\n      }\n    };\n\n    let p: Promise<void>;\n    this._plugin.emitEvent({ kind: 'onDestroy', wait: (_p: Promise<void>) => p = _p });\n    if (p) {\n      p.then(destroy).catch(destroy);\n    } else {\n      destroy();\n    }\n  }\n\n  trackBy(index: number, item: T): any {\n    return index;\n  }\n\n  /**\n   * Clear the current sort definitions.\n   * This method is a proxy to `PblDataSource.setSort`, For more information see `PblDataSource.setSort`\n   *\n   * @param skipUpdate When true will not update the datasource, use this when the data comes sorted and you want to sync the definitions with the current data set.\n   * default to false.\n   */\n  setSort(skipUpdate?: boolean): void;\n  /**\n   * Set the sorting definition for the current data set.\n   *\n   * This method is a proxy to `PblDataSource.setSort` with the added sugar of providing column by string that match the `id` or `sortAlias` properties.\n   * For more information see `PblDataSource.setSort`\n   *\n   * @param columnOrSortAlias A column instance or a string matching `PblColumn.sortAlias` or `PblColumn.id`.\n   * @param skipUpdate When true will not update the datasource, use this when the data comes sorted and you want to sync the definitions with the current data set.\n   * default to false.\n   */\n  setSort(columnOrSortAlias: PblColumn | string, sort: PblNgridSortDefinition, skipUpdate?: boolean): void;\n  setSort(columnOrSortAlias?: PblColumn | string | boolean, sort?: PblNgridSortDefinition, skipUpdate = false): void {\n    if (!columnOrSortAlias || typeof columnOrSortAlias === 'boolean') {\n      this.ds.setSort(!!columnOrSortAlias);\n      return;\n    }\n\n    let column: PblColumn;\n    if (typeof columnOrSortAlias === 'string') {\n      column = this._store.columns.find( c => c.alias ? c.alias === columnOrSortAlias : (c.sort && c.id === columnOrSortAlias) );\n      if (!column && isDevMode()) {\n        console.warn(`Could not find column with alias \"${columnOrSortAlias}\".`);\n        return;\n      }\n    } else {\n      column = columnOrSortAlias;\n    }\n    this.ds.setSort(column, sort, skipUpdate);\n  }\n\n  /**\n   * Clear the filter definition for the current data set.\n   *\n   * This method is a proxy to `PblDataSource.setFilter`, For more information see `PblDataSource.setFilter`.\n   */\n  setFilter(): void;\n  /**\n   * Set the filter definition for the current data set using a function predicate.\n   *\n  * This method is a proxy to `PblDataSource.setFilter` with the added sugar of providing column by string that match the `id` property.\n   * For more information see `PblDataSource.setFilter`\n   */\n  setFilter(value: DataSourcePredicate, columns?: PblColumn[] | string[]): void;\n  /**\n   * Set the filter definition for the current data set using a value to compare with and a list of columns with the values to compare to.\n   *\n   * This method is a proxy to `PblDataSource.setFilter` with the added sugar of providing column by string that match the `id` property.\n   * For more information see `PblDataSource.setFilter`\n   */\n  setFilter(value: any, columns: PblColumn[] | string[]): void;\n  setFilter(value?: DataSourceFilterToken, columns?: PblColumn[] | string[]): void {\n    if (arguments.length > 0) {\n      let columnInstances: PblColumn[];\n      if (Array.isArray(columns) && typeof columns[0] === 'string') {\n        columnInstances = [];\n        for (const colId of columns) {\n          const column = this._store.columns.find( c => c.alias ? c.alias === colId : (c.id === colId) );\n          if (!column && isDevMode()) {\n            console.warn(`Could not find column with alias ${colId} \"${colId}\".`);\n            return;\n          }\n          columnInstances.push(column);\n        }\n      } else {\n        columnInstances = columns as any;\n      }\n      this.ds.setFilter(value, columnInstances);\n    } else {\n      this.ds.setFilter();\n    }\n  }\n\n  setDataSource(value: PblDataSource<T>): void {\n    if (this._dataSource !== value) {\n      // KILL ALL subscriptions for the previous datasource.\n      if (this._dataSource) {\n        UnRx.kill(this, this._dataSource);\n      }\n\n      const prev = this._dataSource;\n      this._dataSource = value;\n      this._cdkTable.dataSource = value as any;\n\n      this.setupPaginator();\n      this.setupNoData(false);\n\n      // clear the context, new datasource\n      this._extApi.contextApi.clear();\n\n      this._plugin.emitEvent({\n        kind: 'onDataSource',\n        prev,\n        curr: value\n      });\n\n      if ( value ) {\n        if (isDevMode()) {\n          value.onError.pipe(UnRx(this, value)).subscribe(console.error.bind(console));\n        }\n\n        // We register to this event because it fires before the entire data-changing process starts.\n        // This is required because `onRenderDataChanging` is fired async, just before the data is emitted.\n        // Its not enough to clear the context when `setDataSource` is called, we also need to handle `refresh` calls which will not\n        // trigger this method.\n        value.onSourceChanging.pipe(UnRx(this, value)).subscribe( () => this._extApi.contextApi.clear() );\n\n        // Run CD, scheduled as a micro-task, after each rendering\n        value.onRenderDataChanging\n          .pipe(\n            filter( ({event}) => !event.isInitial && (event.pagination.changed || event.sort.changed || event.filter.changed)),\n            // Context between the operations are not supported at the moment\n            // Event for client side operations...\n            // TODO: can we remove this? we clear the context with `onSourceChanging`\n            tap( () => !this._store.primary && this._extApi.contextApi.clear() ),\n            switchMap( () => value.onRenderedDataChanged.pipe(take(1), mapTo(this.ds.renderLength)) ),\n            observeOn(asapScheduler),\n            UnRx(this, value)\n          )\n          .subscribe( previousRenderLength => {\n            // If the number of rendered items has changed the table will update the data and run CD on it.\n            // so we only update the rows.\n            const { cdkTable } = this._extApi;\n            if (previousRenderLength === this.ds.renderLength) {\n              cdkTable.syncRows(true);\n            } else {\n              cdkTable.syncRows('header', true);\n              cdkTable.syncRows('footer', true);\n            }\n          });\n\n        // Handling no data overlay\n        // Handling fallback minimum height.\n        value.onRenderedDataChanged\n          .pipe(\n            map( () => this.ds.renderLength ),\n            startWith(null),\n            pairwise(),\n            tap( ([prev, curr]) => {\n              const noDataShowing = !!this._noDateEmbeddedVRef;\n              if ( (curr > 0 && noDataShowing) || (curr === 0 && !noDataShowing) ) {\n                this.setupNoData();\n              }\n            }),\n            observeOn(animationFrameScheduler), // ww want to give the browser time to remove/add rows\n            UnRx(this, value)\n          )\n          .subscribe(() => {\n            const el = this.viewport.elementRef.nativeElement;\n            if (this.ds.renderLength > 0 && this._fallbackMinHeight > 0) {\n              const h = Math.min(this._fallbackMinHeight, this.viewport.measureRenderedContentSize());\n              el.style.minHeight = h + 'px';\n            } else {\n              el.style.minHeight = this.viewport.enabled ? null : this.viewport.measureRenderedContentSize() + 'px';\n              // TODO: When viewport is disabled, we can skip the call to measureRenderedContentSize() and let the browser\n              // do the job by setting `contain: unset` in `pbl-cdk-virtual-scroll-viewport`\n\n              // el.style.minHeight = null;\n              // el.style.contain = this.viewport.enabled ? null : 'unset';\n\n              // UPDATE: This will not work because it will cause the width to be incorrect when used with vScrollNone\n              // TODO: Check why?\n            }\n          });\n      }\n    }\n  }\n\n  /**\n   * Invalidates the header, including a full rebuild of column headers\n   */\n  invalidateColumns(): void {\n    this._plugin.emitEvent({ kind: 'beforeInvalidateHeaders' });\n\n    const rebuildRows = this._store.allColumns.length > 0;\n    this._extApi.contextApi.clear();\n    this._store.invalidate(this.columns);\n\n    setIdentityProp(this._store, this.__identityProp); /// TODO(shlomiassaf): Remove in 1.0.0\n\n    this.attachCustomCellTemplates();\n    this.attachCustomHeaderCellTemplates();\n    this._cdkTable.clearHeaderRowDefs();\n    this._cdkTable.clearFooterRowDefs();\n    // this.cdr.markForCheck();\n    this.cdr.detectChanges();\n\n    // after invalidating the headers we now have optional header/headerGroups/footer rows added\n    // we need to update the template with this data which will create new rows (header/footer)\n    this.resetHeaderRowDefs();\n    this.resetFooterRowDefs();\n    this.cdr.markForCheck();\n\n    /*  Now we will force clearing all data rows and creating them back again if this is not the first time we invalidate the columns...\n\n        Why? first, some background:\n\n        Invalidating the store will result in new `PblColumn` instances (cloned or completely new) held inside a new array (all arrays in the store are re-created on invalidate)\n        New array and new instances will also result in new directive instances of `PblNgridColumnDef` for every column.\n\n        Each data row has data cells with the `PblNgridCellDirective` directive (`pbl-ngrid-cell`).\n        `PblNgridCellDirective` has a reference to `PblNgridColumnDef` through dependency injection, i.e. it will not update through change detection!\n\n        Now, the problem:\n        The `CdkTable` will cache rows and their cells, reusing them for performance.\n        This means that the `PblNgridColumnDef` instance inside each cell will not change.\n        So, creating new columns and columnDefs will result in stale cells with reference to dead instances of `PblColumn` and `PblNgridColumnDef`.\n\n        One solution is to refactor `PblNgridCellDirective` to get the `PblNgridColumnDef` through data binding.\n        While this will work it will put more work on each cell while doing CD and will require complex logic to handle each change because `PblNgridCellDirective`\n        also create a context which has reference to a column thus a new context is required.\n        Keeping track for all references will be difficult and bugs are likely to occur, which are hard to track.\n\n        The simplest solution is to force the table to render all data rows from scratch which will destroy the cache and all cell's with it, creating new one's with proper reference.\n\n        The simple solution is currently preferred because:\n\n        - It is easier to implement.\n        - It is easier to assess the impact.\n        - It effects a single operation (changing to resetting columns) that rarely happen\n\n        The only issue is with the `CdkTable` encapsulating the method `_forceRenderDataRows()` which is what we need.\n        The workaround is to assign `multiTemplateDataRows` with the same value it already has, which will cause `_forceRenderDataRows` to fire.\n        `multiTemplateDataRows` is a getter that triggers `_forceRenderDataRows` without checking the value changed, perfect fit.\n        There is a risk with `multiTemplateDataRows` being changed...\n     */\n    if (rebuildRows) {\n      this._cdkTable.multiTemplateDataRows = this._cdkTable.multiTemplateDataRows;\n    }\n    this._plugin.emitEvent({ kind: 'onInvalidateHeaders' });\n  }\n\n  /**\n   * Updates the column sizes for all columns in the table based on the column definition metadata for each column.\n   * The final width represent a static width, it is the value as set in the definition (except column without width, where the calculated global width is set).\n   */\n  resetColumnsWidth(options?: { tableMarkForCheck?: boolean; metaMarkForCheck?: boolean; }): void {\n    resetColumnWidths(this._store.getStaticWidth(), this._store.columns, this._store.metaColumns, options);\n  }\n\n  /**\n   * Update the size of all group columns in the table based on the size of their visible children (not hidden).\n   * @param dynamicWidthLogic - Optional logic container, if not set a new one is created.\n   */\n  syncColumnGroupsSize(dynamicWidthLogic?: DynamicColumnWidthLogic): void {\n    if (!dynamicWidthLogic) {\n      dynamicWidthLogic = this._extApi.dynamicColumnWidthFactory();\n    }\n\n    // From all meta columns (header/footer/headerGroup) we filter only `headerGroup` columns.\n    // For each we calculate it's width from all of the columns that the headerGroup \"groups\".\n    // We use the same strategy and the same RowWidthDynamicAggregator instance which will prevent duplicate calculations.\n    // Note that we might have multiple header groups, i.e. same columns on multiple groups with different row index.\n    for (const g of this._store.getAllHeaderGroup()) {\n      // We go over all columns because g.columns does not represent the current owned columns of the group\n      // it is static, representing the initial state.\n      // Only columns hold their group owners.\n      // TODO: find way to improve iteration\n      const colSizeInfos = this._store.columns.filter( c => !c.hidden && c.isInGroup(g)).map( c => c.sizeInfo );\n      if (colSizeInfos.length > 0) {\n        const groupWidth = dynamicWidthLogic.addGroup(colSizeInfos);\n        g.minWidth = groupWidth;\n        g.updateWidth(`${groupWidth}px`);\n      } else {\n        g.minWidth = undefined;\n        g.updateWidth(`0px`);\n      }\n      if (g.columnDef) {\n        g.columnDef.markForCheck();\n      }\n    }\n  }\n\n  resizeColumns(columns?: PblColumn[]): void {\n    if (!columns) {\n      columns = this._store.columns;\n    }\n\n    // protect from per-mature resize.\n    // Will happen on additional header/header-group rows AND ALSO when vScrollNone is set\n    // This will cause size not to populate because it takes time to render the rows, since it's not virtual and happens immediately.\n    // TODO: find a better protection.\n    if (!columns[0].sizeInfo) {\n      return;\n    }\n\n    // stores and calculates width for columns added to it. Aggregate's the total width of all added columns.\n    const rowWidth = this._extApi.dynamicColumnWidthFactory();\n    this.syncColumnGroupsSize(rowWidth);\n\n    // if this is a table without groups\n    if (rowWidth.minimumRowWidth === 0) {\n      rowWidth.addGroup(columns.map( c => c.sizeInfo ));\n    }\n\n    // if the max lock state has changed we need to update re-calculate the static width's again.\n    if (rowWidth.maxWidthLockChanged) {\n      resetColumnWidths(this._store.getStaticWidth(), this._store.columns, this._store.metaColumns, { tableMarkForCheck: true });\n      this.resizeColumns(columns);\n      return;\n    }\n\n    if (!this._minimumRowWidth ) {\n      // We calculate the total minimum width of the table\n      // We do it once, to set the minimum width based on the initial setup.\n      // Note that we don't apply strategy here, we want the entire length of the table!\n      this._cdkTable.minWidth = rowWidth.minimumRowWidth;\n    }\n\n    this.ngZone.run( () => {\n      this._cdkTable.syncRows('header');\n      this._plugin.emitEvent({ kind: 'onResizeRow' });\n    });\n  }\n\n  /**\n   * Create an embedded view before or after the user projected content.\n   */\n  createView<C>(location: 'beforeTable' | 'beforeContent' | 'afterContent', templateRef: TemplateRef<C>, context?: C, index?: number): EmbeddedViewRef<C> {\n    const vcRef = this.getInternalVcRef(location);\n    const view = vcRef.createEmbeddedView(templateRef, context, index);\n    view.detectChanges();\n    return view;\n  }\n\n  /**\n   * Remove an already created embedded view.\n   * @param view - The view to remove\n   * @param location - The location, if not set defaults to `before`\n   * @returns true when a view was removed, false when not. (did not exist in the view container for the provided location)\n   */\n  removeView(view: EmbeddedViewRef<any>, location: 'beforeTable' | 'beforeContent' | 'afterContent'): boolean {\n    const vcRef = this.getInternalVcRef(location);\n    const idx = vcRef.indexOf(view);\n    if (idx === -1) {\n      return false;\n    } else {\n      vcRef.remove(idx);\n      return true;\n    }\n  }\n\n  /**\n   * Resize all visible columns to fit content of the table.\n   * @param forceFixedWidth - When true will resize all columns with absolute pixel values, otherwise will keep the same format as originally set (% or none)\n   */\n  autoSizeColumnToFit(options?: AutoSizeToFitOptions): void {\n    const { innerWidth, outerWidth } = this.viewport;\n\n    // calculate auto-size on the width without scroll bar and take box model gaps into account\n    // TODO: if no scroll bar exists the calc will not include it, next if more rows are added a scroll bar will appear...\n    this.columnApi.autoSizeToFit(outerWidth - (outerWidth - innerWidth), options);\n  }\n\n  findInitialRowHeight(): number {\n    let rowElement: HTMLElement;\n    if (this._cdkTable._rowOutlet.viewContainer.length) {\n      const viewRef = this._cdkTable._rowOutlet.viewContainer.get(0) as EmbeddedViewRef<any>;\n      rowElement = viewRef.rootNodes[0];\n      const height = getComputedStyle(rowElement).height;\n      return parseInt(height, 10);\n    } else if (this._vcRefBeforeContent) {\n      rowElement = this._vcRefBeforeContent.length > 0\n        ? (this._vcRefBeforeContent.get(this._vcRefBeforeContent.length - 1) as EmbeddedViewRef<any>).rootNodes[0]\n        : this._vcRefBeforeContent.element.nativeElement\n      ;\n      rowElement = rowElement.nextElementSibling as HTMLElement;\n      rowElement.style.display = '';\n      const height = getComputedStyle(rowElement).height;\n      rowElement.style.display = 'none';\n      return parseInt(height, 10);\n    }\n  }\n\n  addClass(...cls: string[]): void {\n    for (const c of cls) {\n      this.elRef.nativeElement.classList.add(c);\n    }\n  }\n\n  removeClass(...cls: string[]): void {\n    for (const c of cls) {\n      this.elRef.nativeElement.classList.remove(c);\n    }\n  }\n\n  private initPlugins(injector: Injector, elRef: ElementRef<any>, vcRef: ViewContainerRef): void {\n    // Create an injector for the extensions/plugins\n    // This injector allow plugins (that choose so) to provide a factory function for runtime use.\n    // I.E: as if they we're created by angular via template...\n    // This allows seamless plugin-to-plugin dependencies without requiring specific template syntax.\n    // And also allows auto plugin binding (app wide) without the need for template syntax.\n    const pluginInjector = Injector.create({\n      providers: [\n        { provide: ViewContainerRef, useValue: vcRef },\n        { provide: ElementRef, useValue: elRef },\n        { provide: ChangeDetectorRef, useValue: this.cdr },\n      ],\n      parent: injector,\n    });\n    this._plugin = PblNgridPluginContext.create(this, pluginInjector, this._extApi);\n    bindToDataSource(this._plugin);\n  }\n\n  private listenToResize(): void {\n    let resizeObserver: ResizeObserver;\n    const ro$ = fromEventPattern<[ResizeObserverEntry[], ResizeObserver]>(\n      handler => {\n        if (!resizeObserver) {\n          resizeObserver = new ResizeObserver(handler);\n          resizeObserver.observe(this.elRef.nativeElement);\n        }\n      },\n      handler => {\n        if (resizeObserver) {\n          resizeObserver.unobserve(this.elRef.nativeElement);\n          resizeObserver.disconnect();\n          resizeObserver = undefined;\n        }\n      }\n    );\n\n    // Skip the first emission\n    // Debounce all resizes until the next complete animation frame without a resize\n    // finally maps to the entries collection\n    // SKIP:  We should skip the first emission (`skip(1)`) before we debounce, since its called upon calling \"observe\" on the resizeObserver.\n    //        The problem is that some tables might require this because they do change size.\n    //        An example is a table in a mat-tab that is hidden, the table will hit the resize one when we focus the tab\n    //        which will require a resize handling because it's initial size is 0\n    //        To workaround this, we only skip elements not yet added to the DOM, which means they will not trigger a resize event.\n    let skipValue = document.contains(this.elRef.nativeElement) ? 1 : 0;\n\n    ro$\n      .pipe(\n        skip(skipValue),\n        debounceTime(0, animationFrameScheduler),\n        UnRx(this),\n      )\n      .subscribe( (args: [ResizeObserverEntry[], ResizeObserver]) => {\n        if (skipValue === 0) {\n          skipValue = 1;\n          const columns = this._store.columns;\n          columns.forEach( c => c.sizeInfo.updateSize() );\n        }\n        this.onResize(args[0]);\n      });\n  }\n\n  private onResize(entries: ResizeObserverEntry[]): void {\n    if (this._viewport) {\n      this._viewport.checkViewportSize();\n    }\n    this.resetColumnsWidth();\n    this.resizeColumns();\n  }\n\n  private initExtApi(): void {\n    let onInit: Array<() => void> = [];\n    const extApi = {\n      table: this,\n      element: this.elRef.nativeElement,\n      get cdkTable() { return extApi.table._cdkTable; },\n      get events() { return extApi.table._plugin.events },\n      get contextApi() {\n        Object.defineProperty(this, 'contextApi', { value: new ContextApi<T>(extApi) });\n        return extApi.contextApi;\n      },\n      get metaRowService() {\n        Object.defineProperty(this, 'metaRowService', { value: new PblNgridMetaRowService<T>(extApi) });\n        return extApi.metaRowService;\n      },\n      onInit: (fn: () => void) => {\n        if (extApi.table.isInit) {\n          fn();\n        } else {\n          if (onInit.length === 0) {\n            let u = extApi.events.subscribe( e => {\n              if (e.kind === 'onInit') {\n                for (const onInitFn of onInit) {\n                  onInitFn();\n                }\n                u.unsubscribe();\n                onInit = u = undefined;\n              }\n            });\n          }\n          onInit.push(fn);\n        }\n      },\n      columnStore: this._store,\n      setViewport: (viewport) => this._viewport = viewport,\n      dynamicColumnWidthFactory: (): DynamicColumnWidthLogic => {\n        return new DynamicColumnWidthLogic(DYNAMIC_PADDING_BOX_MODEL_SPACE_STRATEGY);\n      }\n    };\n    this._extApi = extApi;\n  }\n\n  private setupNoData(force?: boolean): void {\n    if (this._noDateEmbeddedVRef) {\n      this.removeView(this._noDateEmbeddedVRef, 'beforeContent');\n      this._noDateEmbeddedVRef = undefined;\n    }\n    if (force === false) {\n      return;\n    }\n\n    const noData = this._dataSource && this._dataSource.renderLength === 0;\n    if (noData) {\n      this.addClass('pbl-ngrid-empty');\n    } else {\n      this.removeClass('pbl-ngrid-empty');\n    }\n\n    if (noData || force === true) {\n      const noDataTemplate = this.registry.getSingle('noData');\n      if (noDataTemplate) {\n        this._noDateEmbeddedVRef = this.createView('beforeContent', noDataTemplate.tRef, { $implicit: this }, 0);\n      }\n    }\n  }\n\n  private getInternalVcRef(location: 'beforeTable' | 'beforeContent' | 'afterContent'): ViewContainerRef {\n    return location === 'beforeTable'\n      ? this._vcRefBeforeTable\n      : location === 'beforeContent' ? this._vcRefBeforeContent : this._vcRefAfterContent\n    ;\n  }\n\n  private setupPaginator(): void {\n    const paginationKillKey = 'pblPaginationKillKey';\n    const usePagination = this.ds && this.usePagination;\n\n    if (usePagination) {\n      this.ds.pagination = this._pagination;\n      if (this.ds.paginator) {\n        this.ds.paginator.noCacheMode = this._noCachePaginator;\n      }\n    }\n\n    if (this.isInit) {\n      UnRx.kill(this, paginationKillKey);\n      if (this._paginatorEmbeddedVRef) {\n        this.removeView(this._paginatorEmbeddedVRef, 'beforeContent');\n        this._paginatorEmbeddedVRef = undefined;\n      }\n      if (usePagination) {\n        const paginatorTemplate = this.registry.getSingle('paginator');\n        if (paginatorTemplate) {\n          this._paginatorEmbeddedVRef = this.createView('beforeContent', paginatorTemplate.tRef, { $implicit: this });\n        }\n      }\n    }\n  }\n\n  private attachCustomCellTemplates(): void {\n    for (const col of this._store.columns) {\n      const cell = findCellDef(this.registry, col, 'tableCell', true);\n      if ( cell ) {\n        col.cellTpl = cell.tRef;\n      } else {\n        const defaultCellTemplate = this.registry.getMultiDefault('tableCell');\n        col.cellTpl = defaultCellTemplate ? defaultCellTemplate.tRef : this._fbTableCell;\n      }\n\n      const editorCell = findCellDef(this.registry, col, 'editorCell', true);\n      if ( editorCell ) {\n        col.editorTpl = editorCell.tRef;\n      } else {\n        const defaultCellTemplate = this.registry.getMultiDefault('editorCell');\n        col.editorTpl = defaultCellTemplate ? defaultCellTemplate.tRef : undefined;\n      }\n    }\n  }\n\n  private attachCustomHeaderCellTemplates(): void {\n    const columns: Array<PblColumn | PblMetaColumnStore> = [].concat(this._store.columns, this._store.metaColumns);\n    const defaultHeaderCellTemplate = this.registry.getMultiDefault('headerCell') || { tRef: this._fbHeaderCell };\n    const defaultFooterCellTemplate = this.registry.getMultiDefault('footerCell') || { tRef: this._fbFooterCell };\n    for (const col of columns) {\n      if (col instanceof PblColumn) {\n        const headerCellDef = findCellDef<T>(this.registry, col, 'headerCell', true) || defaultHeaderCellTemplate;\n        const footerCellDef = findCellDef<T>(this.registry, col, 'footerCell', true) || defaultFooterCellTemplate;\n        col.headerCellTpl = headerCellDef.tRef;\n        col.footerCellTpl = footerCellDef.tRef;\n      } else {\n        if (col.header) {\n          const headerCellDef = findCellDef(this.registry, col.header, 'headerCell', true) || defaultHeaderCellTemplate;\n          col.header.template = headerCellDef.tRef;\n        }\n        if (col.headerGroup) {\n          const headerCellDef = findCellDef(this.registry, col.headerGroup, 'headerCell', true) || defaultHeaderCellTemplate;\n          col.headerGroup.template = headerCellDef.tRef;\n        }\n        if (col.footer) {\n          const footerCellDef = findCellDef(this.registry, col.footer, 'footerCell', true) || defaultFooterCellTemplate;\n          col.footer.template = footerCellDef.tRef;\n        }\n      }\n    }\n  }\n\n  private resetHeaderRowDefs(): void {\n    if (this._headerRowDefs) {\n      // The table header (main, with column names) is always the last row def (index 0)\n      // Because we want it to show last (after custom headers, group headers...) we first need to pull it and then push.\n\n      this._cdkTable.clearHeaderRowDefs();\n      const arr = this._headerRowDefs.toArray();\n      arr.push(arr.shift());\n\n      for (const rowDef of arr) {\n        this._cdkTable.addHeaderRowDef(rowDef);\n      }\n    }\n  }\n\n  private resetFooterRowDefs(): void {\n    if (this._footerRowDefs) {\n      this._cdkTable.clearFooterRowDefs();\n      for (const rowDef of this._footerRowDefs.toArray()) {\n        this._cdkTable.addFooterRowDef(rowDef);\n      }\n    }\n  }\n}\n","import { PblNgridPluginContext } from '../ext/plugin-control';\nimport { PblNgridComponent } from './table.component';\n\ndeclare module '../data-source/data-source' {\n  interface PblDataSource<T = any, TData = any> {\n    hostGrid: PblNgridComponent<T>\n  }\n}\n\nexport function bindToDataSource(plugin: PblNgridPluginContext): void {\n  plugin.events.subscribe( event => {\n    if (event.kind === 'onDataSource') {\n      const { curr, prev } = event;\n      if (prev && prev.hostGrid === plugin.table) {\n        prev.hostGrid = undefined;\n      }\n      if (curr) {\n        curr.hostGrid = plugin.table;\n      }\n    } else if (event.kind === 'onDestroy') {\n      const ds = plugin.table.ds;\n      if (ds.hostGrid === plugin.table) {\n        ds.hostGrid = undefined;\n      }\n    }\n  });\n}\n","\n// https://github.com/angular/angular/blob/0bf810022a80ba1cbcff8aa471063a6f1352abbe/packages/common/src/directives/styling_differ.ts\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Used to diff and convert ngStyle/ngClass instructions into [style] and [class] bindings.\n *\n * ngStyle and ngClass both accept various forms of input and behave differently than that\n * of how [style] and [class] behave in Angular.\n *\n * The differences are:\n *  - ngStyle and ngClass both **watch** their binding values for changes each time CD runs\n *    while [style] and [class] bindings do not (they check for identity changes)\n *  - ngStyle allows for unit-based keys (e.g. `{'max-width.px':value}`) and [style] does not\n *  - ngClass supports arrays of class values and [class] only accepts map and string values\n *  - ngClass allows for multiple className keys (space-separated) within an array or map\n *     (as the * key) while [class] only accepts a simple key/value map object\n *\n * Having Angular understand and adapt to all the different forms of behavior is complicated\n * and unnecessary. Instead, ngClass and ngStyle should have their input values be converted\n * into something that the core-level [style] and [class] bindings understand.\n *\n * This [StylingDiffer] class handles this conversion by creating a new input value each time\n * the inner representation of the binding value have changed.\n *\n * ## Why do we care about ngStyle/ngClass?\n * The styling algorithm code (documented inside of `render3/interfaces/styling.ts`) needs to\n * respect and understand the styling values emitted through ngStyle and ngClass (when they\n * are present and used in a template).\n *\n * Instead of having these directives manage styling on their own, they should be included\n * into the Angular styling algorithm that exists for [style] and [class] bindings.\n *\n * Here's why:\n *\n * - If ngStyle/ngClass is used in combination with [style]/[class] bindings then the\n *   styles and classes would fall out of sync and be applied and updated at\n *   inconsistent times\n * - Both ngClass/ngStyle do not respect [class.name] and [style.prop] bindings\n *   (they will write over them given the right combination of events)\n *\n *   ```\n *   <!-- if `w1` is updated then it will always override `w2`\n *        if `w2` is updated then it will always override `w1`\n *        if both are updated at the same time then `w1` wins -->\n *   <div [ngStyle]=\"{width:w1}\" [style.width]=\"w2\">...</div>\n *\n *   <!-- if `w1` is updated then it will always lose to `w2`\n *        if `w2` is updated then it will always override `w1`\n *        if both are updated at the same time then `w2` wins -->\n *   <div [style]=\"{width:w1}\" [style.width]=\"w2\">...</div>\n *   ```\n * - ngClass/ngStyle were written as a directives and made use of maps, closures and other\n *   expensive data structures which were evaluated each time CD runs\n */\nexport class StylingDiffer<T> {\n  public readonly value: T|null = null;\n\n  private _lastSetValue: {[key: string]: any}|string|string[]|null = null;\n  private _lastSetValueType: StylingDifferValueTypes = StylingDifferValueTypes.Null;\n  private _lastSetValueIdentityChange = false;\n\n  constructor(private _name: string, private _options: StylingDifferOptions) {}\n\n  /**\n   * Sets (updates) the styling value within the differ.\n   *\n   * Only when `hasValueChanged` is called then this new value will be evaluted\n   * and checked against the previous value.\n   *\n   * @param value the new styling value provided from the ngClass/ngStyle binding\n   */\n  setValue(value: {[key: string]: any}|string[]|string|null) {\n    if (Array.isArray(value)) {\n      this._lastSetValueType = StylingDifferValueTypes.Array;\n    } else if (value instanceof Set) {\n      this._lastSetValueType = StylingDifferValueTypes.Set;\n    } else if (value && typeof value === 'string') {\n      if (!(this._options & StylingDifferOptions.AllowStringValue)) {\n        throw new Error(this._name + ' string values are not allowed');\n      }\n      this._lastSetValueType = StylingDifferValueTypes.String;\n    } else {\n      this._lastSetValueType = value ? StylingDifferValueTypes.Map : StylingDifferValueTypes.Null;\n    }\n\n    this._lastSetValueIdentityChange = true;\n    this._lastSetValue = value || null;\n  }\n\n  /**\n   * Determines whether or not the value has changed.\n   *\n   * This function can be called right after `setValue()` is called, but it can also be\n   * called incase the existing value (if it's a collection) changes internally. If the\n   * value is indeed a collection it will do the necessary diffing work and produce a\n   * new object value as assign that to `value`.\n   *\n   * @returns whether or not the value has changed in some way.\n   */\n  hasValueChanged(): boolean {\n    let valueHasChanged = this._lastSetValueIdentityChange;\n    if (!valueHasChanged && !(this._lastSetValueType & StylingDifferValueTypes.Collection))\n      return false;\n\n    let finalValue: {[key: string]: any}|string|null = null;\n    const trimValues = (this._options & StylingDifferOptions.TrimProperties) ? true : false;\n    const parseOutUnits = (this._options & StylingDifferOptions.AllowUnits) ? true : false;\n    const allowSubKeys = (this._options & StylingDifferOptions.AllowSubKeys) ? true : false;\n\n    switch (this._lastSetValueType) {\n      // case 1: [input]=\"string\"\n      case StylingDifferValueTypes.String:\n        const tokens = (this._lastSetValue as string).split(/\\s+/g);\n        if (this._options & StylingDifferOptions.ForceAsMap) {\n          finalValue = {};\n          tokens.forEach((token, i) => (finalValue as{[key: string]: any})[token] = true);\n        } else {\n          finalValue = tokens.reduce((str, token, i) => str + (i ? ' ' : '') + token);\n        }\n        break;\n\n      // case 2: [input]=\"{key:value}\"\n      case StylingDifferValueTypes.Map:\n        const map: {[key: string]: any} = this._lastSetValue as{[key: string]: any};\n        const keys = Object.keys(map);\n        if (!valueHasChanged) {\n          if (this.value) {\n            // we know that the classExp value exists and that it is\n            // a map (otherwise an identity change would have occurred)\n            valueHasChanged = mapHasChanged(keys, this.value as{[key: string]: any}, map);\n          } else {\n            valueHasChanged = true;\n          }\n        }\n\n        if (valueHasChanged) {\n          finalValue =\n              bulidMapFromValues(this._name, trimValues, parseOutUnits, allowSubKeys, map, keys);\n        }\n        break;\n\n      // case 3a: [input]=\"[str1, str2, ...]\"\n      // case 3b: [input]=\"Set\"\n      case StylingDifferValueTypes.Array:\n      case StylingDifferValueTypes.Set:\n        const values = Array.from(this._lastSetValue as string[] | Set<string>);\n        if (!valueHasChanged) {\n          const keys = Object.keys(this.value !);\n          valueHasChanged = !arrayEqualsArray(keys, values);\n        }\n        if (valueHasChanged) {\n          finalValue =\n              bulidMapFromValues(this._name, trimValues, parseOutUnits, allowSubKeys, values);\n        }\n        break;\n\n      // case 4: [input]=\"null|undefined\"\n      default:\n        finalValue = null;\n        break;\n    }\n\n    if (valueHasChanged) {\n      (this as any).value = finalValue !;\n    }\n\n    return valueHasChanged;\n  }\n}\n\n/**\n * Various options that are consumed by the [StylingDiffer] class.\n */\nexport const enum StylingDifferOptions {\n  None = 0b00000,\n  TrimProperties = 0b00001,\n  AllowSubKeys = 0b00010,\n  AllowStringValue = 0b00100,\n  AllowUnits = 0b01000,\n  ForceAsMap = 0b10000,\n}\n\n/**\n * The different types of inputs that the [StylingDiffer] can deal with\n */\nconst enum StylingDifferValueTypes {\n  Null = 0b0000,\n  String = 0b0001,\n  Map = 0b0010,\n  Array = 0b0100,\n  Set = 0b1000,\n  Collection = 0b1110,\n}\n\n\n/**\n * builds and returns a map based on the values input value\n *\n * If the `keys` param is provided then the `values` param is treated as a\n * string map. Otherwise `values` is treated as a string array.\n */\nfunction bulidMapFromValues(\n    errorPrefix: string, trim: boolean, parseOutUnits: boolean, allowSubKeys: boolean,\n    values: {[key: string]: any} | string[], keys?: string[]) {\n  const map: {[key: string]: any} = {};\n  if (keys) {\n    // case 1: map\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i];\n      key = trim ? key.trim() : key;\n      const value = (values as{[key: string]: any})[key];\n      setMapValues(map, key, value, parseOutUnits, allowSubKeys);\n    }\n  } else {\n    // case 2: array\n    for (let i = 0; i < values.length; i++) {\n      let value = (values as string[])[i];\n      assertValidValue(errorPrefix, value);\n      value = trim ? value.trim() : value;\n      setMapValues(map, value, true, false, allowSubKeys);\n    }\n  }\n\n  return map;\n}\n\nfunction assertValidValue(errorPrefix: string, value: any) {\n  if (typeof value !== 'string') {\n    throw new Error(\n        `${errorPrefix} can only toggle CSS classes expressed as strings, got ${value}`);\n  }\n}\n\nfunction setMapValues(\n    map: {[key: string]: any}, key: string, value: any, parseOutUnits: boolean,\n    allowSubKeys: boolean) {\n  if (allowSubKeys && key.indexOf(' ') > 0) {\n    const innerKeys = key.split(/\\s+/g);\n    for (let j = 0; j < innerKeys.length; j++) {\n      setIndividualMapValue(map, innerKeys[j], value, parseOutUnits);\n    }\n  } else {\n    setIndividualMapValue(map, key, value, parseOutUnits);\n  }\n}\n\nfunction setIndividualMapValue(\n    map: {[key: string]: any}, key: string, value: any, parseOutUnits: boolean) {\n  if (parseOutUnits) {\n    const values = normalizeStyleKeyAndValue(key, value);\n    value = values.value;\n    key = values.key;\n  }\n  map[key] = value;\n}\n\nfunction normalizeStyleKeyAndValue(key: string, value: string | null) {\n  const index = key.indexOf('.');\n  if (index > 0) {\n    const unit = key.substr(index + 1);  // ignore the . ([width.px]=\"'40'\" => \"40px\")\n    key = key.substring(0, index);\n    if (value != null) {  // we should not convert null values to string\n      value += unit;\n    }\n  }\n  return {key, value};\n}\n\nfunction mapHasChanged(keys: string[], a: {[key: string]: any}, b: {[key: string]: any}) {\n  const oldKeys = Object.keys(a);\n  const newKeys = keys;\n\n  // the keys are different which means the map changed\n  if (!arrayEqualsArray(oldKeys, newKeys)) {\n    return true;\n  }\n\n  for (let i = 0; i < newKeys.length; i++) {\n    const key = newKeys[i];\n    if (a[key] !== b[key]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction arrayEqualsArray(a: any[] | null, b: any[] | null) {\n  if (a && b) {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (b.indexOf(a[i]) === -1) return false;\n    }\n    return true;\n  }\n  return false;\n}\n","import { ChangeDetectionStrategy, Component, ElementRef, EmbeddedViewRef, Inject, Input, ViewEncapsulation, SimpleChanges, OnChanges, Optional, DoCheck } from '@angular/core';\nimport { CdkRow, CDK_ROW_TEMPLATE, RowContext } from '@angular/cdk/table';\nimport { PblNgridPluginController } from '../../ext/plugin-control';\nimport { EXT_API_TOKEN, PblNgridExtensionApi } from '../../ext/table-ext-api';\nimport { PblRowContext } from '../context/index';\nimport { PblNgridComponent } from '../table.component';\nimport { StylingDiffer, StylingDifferOptions } from './cell-style-class/styling_differ';\n\nexport const PBL_NGRID_ROW_TEMPLATE  = `<ng-content select=\".pbl-ngrid-row-prefix\"></ng-content>${CDK_ROW_TEMPLATE}<ng-content select=\".pbl-ngrid-row-suffix\"></ng-content>`;\n\n@Component({\n  selector: 'pbl-ngrid-row[row]',\n  template: PBL_NGRID_ROW_TEMPLATE,\n  host: { // tslint:disable-line:use-host-property-decorator\n    'class': 'pbl-ngrid-row',\n    'role': 'row',\n  },\n  providers: [\n    { provide: CdkRow, useExisting: PblNgridRowComponent }\n  ],\n  exportAs: 'pblNgridRow',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n})\nexport class PblNgridRowComponent<T = any> extends CdkRow implements OnChanges, DoCheck {\n\n  @Input() set row(value: T) { value && this.updateRow(); }\n\n  /**\n   * Optional grid instance, required only if the row is declared outside the scope of the grid.\n   */\n  @Input() grid: PblNgridComponent<T>;\n\n  rowRenderIndex: number;\n  context: PblRowContext<T>;\n\n  private _classDiffer: StylingDiffer<{ [klass: string]: boolean }>;\n  private _lastClass: Set<string>;\n\n  constructor(@Optional() @Inject(EXT_API_TOKEN) protected extApi: PblNgridExtensionApi<T>, protected el: ElementRef<HTMLElement>) {\n    super();\n    if (extApi) {\n      this.grid = extApi.table;\n    }\n  }\n\n  updateRow(): void {\n    if (this.extApi) {\n      if (! (this.rowRenderIndex >= 0) ) {\n        this.getRend();\n      }\n      this.context = this.extApi.contextApi.rowContext(this.rowRenderIndex);\n      this.el.nativeElement.setAttribute('row-id', this.context.dataIndex as any);\n      this.el.nativeElement.setAttribute('row-key', this.context.identity);\n\n      if (this.grid.rowClassUpdate && this.grid.rowClassUpdateFreq === 'item') {\n        this.updateHostClass();\n      }\n    }\n  }\n\n  ngDoCheck(): void {\n    if (this.grid.rowClassUpdate && this.grid.rowClassUpdateFreq === 'ngDoCheck') {\n      this.updateHostClass();\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (!this.extApi) {\n      if (!this.grid) {\n        throw new Error('\"pbl-ngrid-row\" is used outside the scope of a grid, you must provide a grid instance.');\n      }\n      const controller = PblNgridPluginController.find(this.grid);\n      this.extApi = controller.extApi;\n      this.updateRow();\n    }\n  }\n\n  getRend(): void {\n    const vcRef = this.extApi.cdkTable._rowOutlet.viewContainer;\n    const len = vcRef.length - 1;\n    for (let i = len; i > -1; i--) {\n      const viewRef = vcRef.get(i) as EmbeddedViewRef<RowContext<T>>;\n      if (viewRef.rootNodes[0] === this.el.nativeElement) {\n        this.rowRenderIndex = i;\n        break;\n      }\n    }\n  }\n\n  protected updateHostClass(): void {\n    if (this.context) {\n      const el = this.el.nativeElement;\n\n      // if there is an updater, work with it\n      // otherwise, clear previous classes that got applied (assumed a live binding change of the updater function)\n      // users should be aware to tear down the updater only when they want to stop this feature, if the goal is just to toggle on/off\n      // it's better to set the frequency to `none` and return nothing from the function (replace it) so the differ is not nuked.\n      if (this.grid.rowClassUpdate) {\n        if (!this._classDiffer) {\n          this._classDiffer = new StylingDiffer<{ [klass: string]: boolean }>(\n            'NgClass',\n            StylingDifferOptions.TrimProperties | StylingDifferOptions.AllowSubKeys | StylingDifferOptions.AllowStringValue | StylingDifferOptions.ForceAsMap,\n          );\n          this._lastClass = new Set<string>();\n        }\n\n        const newValue = this.grid.rowClassUpdate(this.context);\n        this._classDiffer.setValue(newValue);\n\n        if (this._classDiffer.hasValueChanged()) {\n          const lastClass = this._lastClass;\n          this._lastClass = new Set<string>();\n\n          const value = this._classDiffer.value || {};\n\n          for (const key of Object.keys(value)) {\n            if (value[key]) {\n              el.classList.add(key);\n              this._lastClass.add(key);\n            } else {\n              el.classList.remove(key);\n            }\n            lastClass.delete(key);\n          }\n          if (lastClass.size > 0) {\n            for (const key of lastClass.values()) {\n              el.classList.remove(key);\n            }\n          }\n        }\n      } else if (this._classDiffer) {\n        const value = this._classDiffer.value || {};\n        this._classDiffer = this._lastClass = undefined;\n\n        for (const key of Object.keys(value)) {\n          el.classList.remove(key);\n        }\n      }\n    }\n  }\n}\n","// tslint:disable:use-host-property-decorator\n\nimport { Directive, TemplateRef, OnInit, OnDestroy, ComponentFactory, ComponentRef, Injector, Input } from '@angular/core';\n\nimport { PblColumn } from '../columns/column';\nimport { PblNgridComponent } from '../table.component';\nimport { MetaCellContext, PblNgridMetaCellContext } from '../context/index';\nimport { PblNgridHeaderCellComponent } from './cell';\nimport { PblNgridSingleRegistryMap, PblNgridMultiRegistryMap, PblNgridRegistryService } from '../services/table-registry.service';\n\nexport abstract class PblNgridSingleTemplateRegistry<T, TKind extends keyof PblNgridSingleRegistryMap> implements OnInit, OnDestroy {\n  abstract readonly kind: TKind;\n\n  constructor(public tRef: TemplateRef<T>, protected registry: PblNgridRegistryService) { }\n\n  ngOnInit(): void {\n    this.registry.setSingle(this.kind, this as any);\n  }\n\n  ngOnDestroy(): void {\n    this.registry.setSingle(this.kind,  undefined);\n  }\n}\n\nexport abstract class PblNgridMultiTemplateRegistry<T, TKind extends keyof PblNgridMultiRegistryMap> implements OnInit, OnDestroy {\n  abstract readonly name: string;\n  abstract readonly kind: TKind;\n\n  constructor(public tRef: TemplateRef<T>, protected registry: PblNgridRegistryService) { }\n\n  ngOnInit(): void {\n    this.registry.addMulti(this.kind, this as any);\n  }\n\n  ngOnDestroy(): void {\n    this.registry.removeMulti(this.kind, this as any);\n  }\n}\n\nexport abstract class PblNgridMultiComponentRegistry<T, TKind extends keyof PblNgridMultiRegistryMap> {\n  abstract readonly name: string;\n  abstract readonly kind: TKind;\n\n  /**\n   * When set to true the component will be created with projected content.\n   * Setting to true does not ensure projection, the projection is determined by the context creating the component.\n   *\n   * For example, In the context of `dataHeaderExtensions` the projection will be the content of the cell, other implementations\n   * might not include a projection.\n   */\n  readonly projectContent?: boolean;\n\n  abstract getFactory(context: PblNgridMetaCellContext<any, PblColumn>): ComponentFactory<T>;\n  onCreated?(context: PblNgridMetaCellContext<any, PblColumn>, cmpRef: ComponentRef<T>): void;\n}\n\nexport class PblNgridDataHeaderExtensionContext<T = any> extends MetaCellContext<T, PblColumn> {\n  readonly injector: Injector\n\n  protected constructor() { super(); }\n\n  // workaround, we need a parameter-less constructor since @ngtools/webpack@8.0.4\n  // Non @Injectable classes are now getting addded with hard reference to the ctor params which at the class creation point are undefined\n  // forwardRef() will not help since it's not inject by angular, we instantiate the class..\n  // probably due to https://github.com/angular/angular-cli/commit/639198499973e0f437f059b3c933c72c733d93d8\n  static createDateHeaderCtx<T = any>(headerCell: PblNgridHeaderCellComponent<PblColumn>, injector: Injector): PblNgridDataHeaderExtensionContext<T> {\n    const instance = new PblNgridDataHeaderExtensionContext<T>();\n\n    instance.col = headerCell.columnDef.column;\n    instance.table = headerCell.table;\n    Object.defineProperty(instance, 'injector', { value: injector });\n    return instance;\n  }\n}\n\nexport interface PblNgridDataHeaderExtensionRef<T = any> {\n  shouldRender?(context: PblNgridDataHeaderExtensionContext<T>): boolean;\n}\n\n\n/**\n * A generic, multi-purpose template reference for data header extensions.\n * The template's context is `PblNgridDataHeaderExtensionContext`:\n *\n * ```ts\n * interface PblNgridDataHeaderExtensionContext {\n *   col: PblMetaColumn;\n *   table: PblNgridComponent<any>;\n *   injector: Injector;\n * }\n * ```\n *\n * By default it will render if registered but it is possible to provide a predicate to conditionally load it.\n *\n * ```html\n * <div *pblNgridHeaderExtensionRef=\"let ctx\"></div>\n * ````\n *\n * Or with a `shouldRender` predicate:\n *\n * ```html\n * <div *pblNgridHeaderExtensionRef=\"shouldRender; let ctx\"></div>\n * ```\n *\n * And in the component the template is defined on:\n *\n * ```ts\n * class MyComponent {\n *\n *   shouldRender = (context: PblNgridDataHeaderExtensionContext) => {\n *     // Some code returning true or false\n *   }\n * }\n * ```\n *\n * Note that the `shouldRender` predicate is run once when the header initialize.\n */\n@Directive({ selector: '[pblNgridHeaderExtensionRef]' })\nexport class PblNgridHeaderExtensionRefDirective extends PblNgridMultiTemplateRegistry<PblNgridDataHeaderExtensionContext, 'dataHeaderExtensions'> implements PblNgridDataHeaderExtensionRef {\n  private static _id = 0;\n\n  readonly name: string = 'genericHeaderExtension-' + PblNgridHeaderExtensionRefDirective._id++;\n  readonly kind: 'dataHeaderExtensions' = 'dataHeaderExtensions';\n\n  @Input('pblNgridHeaderExtensionRef') shouldRender?: (context: PblNgridDataHeaderExtensionContext) => boolean;\n\n  constructor(tRef: TemplateRef<PblNgridDataHeaderExtensionContext>, registry: PblNgridRegistryService) { super(tRef, registry); }\n}\n\n/**\n * Marks the element as the display element for pagination\n */\n@Directive({ selector: '[pblNgridPaginatorRef]' })\nexport class PblNgridPaginatorRefDirective extends PblNgridSingleTemplateRegistry<{ $implicit: PblNgridComponent<any> }, 'paginator'> {\n  readonly kind: 'paginator' = 'paginator';\n  constructor(tRef: TemplateRef<{ $implicit: PblNgridComponent<any> }>, registry: PblNgridRegistryService) { super(tRef, registry); }\n}\n\n/**\n * Marks the element as the display element when table has no data.\n *\n * @example\n * ```html\n *   <pbl-ngrid>\n *     <div *pblNgridNoDataRef style=\"height: 100%; display: flex; align-items: center; justify-content: center\">\n *       <span>No Data</span>\n *     </div>\n *   </pbl-ngrid>\n * ```\n */\n@Directive({ selector: '[pblNgridNoDataRef]' })\nexport class PblNgridNoDataRefDirective extends PblNgridSingleTemplateRegistry<{ $implicit: PblNgridComponent<any> }, 'noData'> {\n  readonly kind: 'noData' = 'noData';\n  constructor(tRef: TemplateRef<{ $implicit: PblNgridComponent<any> }>, registry: PblNgridRegistryService) { super(tRef, registry); }\n}\n","// tslint:disable:use-host-property-decorator\nimport { Directive, TemplateRef, AfterViewInit } from '@angular/core';\n\nimport { PblNgridComponent } from '../table.component';\n\n/**\n * A directive that marks the template as a projected section inside the table.\n * The location of the project content is set by the position input.\n *\n * Note that this directive can only be set as the content inside the table.\n */\n@Directive({\n  selector: '[pblNgridOuterSection]',\n  inputs: [ 'position:pblNgridOuterSection' ] // tslint:disable-line:use-input-property-decorator\n})\nexport class PblNgridOuterSectionDirective implements AfterViewInit {\n\n  position: 'top' | 'bottom'; // tslint:disable-line:no-input-rename\n\n  constructor(private table: PblNgridComponent<any>, private tRef: TemplateRef<{ $implicit: PblNgridComponent<any> }>) { }\n\n  ngAfterViewInit(): void {\n    this.table.createView(this.position === 'bottom' ? 'beforeContent' : 'beforeTable', this.tRef);\n  }\n}\n","/**\n * This file contains constants shared between modules (files) that if not extract will cause a circular dependency\n */\n\nimport { CdkColumnDef } from '@angular/cdk/table';\nimport { PblColumnTypeDefinition } from './columns/types';\n\nconst COLUMN_NAME_CSS_PREFIX = 'pbl-ngrid-column';\nexport const COLUMN_EDITABLE_CELL_CLASS = 'pbl-ngrid-editable-cell';\n\n/**\n * Returns a css class unique to the column\n */\nexport function uniqueColumnCss(columnDef: CdkColumnDef): string {\n  return `${COLUMN_NAME_CSS_PREFIX}-${columnDef.cssClassFriendlyName}`;\n}\n\n/**\n * Returns a css class unique to the type of the column (columns might share types)\n */\nexport function uniqueColumnTypeCss(type: PblColumnTypeDefinition): string {\n  return `${COLUMN_NAME_CSS_PREFIX}-type-${type.name}`;\n}\n\n","// tslint:disable:use-host-property-decorator\n// tslint:disable:directive-class-suffix\n\nimport {\n  Directive,\n  Input,\n  Inject,\n  KeyValueDiffers, KeyValueDiffer,\n  OnDestroy,\n  DoCheck,\n} from '@angular/core';\nimport { CdkColumnDef } from '@angular/cdk/table';\n\nimport { COLUMN } from '../columns';\nimport { isPblColumn } from '../columns/column';\nimport { PblNgridComponent } from '../table.component';\nimport { EXT_API_TOKEN, PblNgridExtensionApi } from '../../ext/table-ext-api';\nimport { parseStyleWidth } from '../columns/utils';\nimport { uniqueColumnCss } from '../circular-dep-bridge';\n\n/* TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO\n\n  PblNgridColumnDef use's the default object KeyValueDiffer provides with angular.\n  This differ will perform the diff on the entire object which IS NOT REQUIRED!\n  We need to create a custom differ that does the diff on selected properties only.\n*/\n\n/**\n * Column definition for the mat-table.\n * Defines a set of cells available for a table column.\n */\n@Directive({\n  selector: '[pblNgridColumnDef]',\n  providers: [\n    { provide: CdkColumnDef, useExisting: PblNgridColumnDef },\n    { provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: PblNgridColumnDef }\n  ],\n})\nexport class PblNgridColumnDef<T extends COLUMN = COLUMN> extends CdkColumnDef implements DoCheck, OnDestroy {\n  @Input('pblNgridColumnDef') get column(): T { return this._column; };\n  set column(value: T) { this.attach(value); }\n\n  get isDirty(): boolean {\n    if (this._markedForCheck && !this._isDirty) {\n      this._markedForCheck = false;\n      this._isDirty = !!this._colDiffer.diff(this._column);\n    }\n    return this._isDirty;\n  }\n\n  /**\n   * The complete width definition for the column.\n   * There are 3 width definitions: MIN-WIDTH, WIDTH and MAX-WIDTH.\n   *\n   * The tuple represents them in that order, i.e: [ MIN-WIDTH, WIDTH, MAX-WIDTH ]\n   */\n  get widths(): [string, string, string] { return this._widths; }\n\n  /**\n   * The last net width of the column.\n   * The net width is the absolute width of the column, without padding, border etc...\n   */\n  get netWidth(): number { return this._netWidth; }\n\n  isDragging = false;\n\n  table: PblNgridComponent<any>;\n\n  protected _colDiffer: KeyValueDiffer<any, any>;\n\n  private _column: T;\n  private _isDirty = false;\n  private _markedForCheck = false;\n\n  /**\n   * The complete width definition for the column.\n   * There are 3 width definitions: MIN-WIDTH, WIDTH and MAX-WIDTH.\n   *\n   * The tuple represents them in that order, i.e: [ MIN-WIDTH, WIDTH, MAX-WIDTH ]\n   */\n  private _widths: [string, string, string];\n\n  /**\n   * The last net width of the column.\n   * The net width is the absolute width of the column, without padding, border etc...\n   */\n  private _netWidth: number;\n\n  constructor(protected readonly _differs: KeyValueDiffers, @Inject(EXT_API_TOKEN) protected extApi: PblNgridExtensionApi<any> ) {\n    super();\n    this.table = extApi.table;\n  }\n\n  /**\n   * Marks this column for a lazy change detection check.\n   * Lazy means it will run the check only when the diff is requested (i.e. querying the `hasChanged` property).\n   * This allow aggregation of changes between CD cycles, i.e. calling `markForCheck()` multiple times within the same CD cycle does not hit performance.\n   *\n   * Once marked for check, `pblNgridColumnDef` handles it's dirty (`isDirty`) state automatically, when `isDirty` is true it will remain true until the\n   * CD cycle ends, i.e. until `ngDoCheck()` hits. This means that only children of `pblNgridColumnDef` can relay on `isDirty`, all children will run their\n   * `ngDoCheck()` before `ngDoCheck()` of `pblNgridColumnDef`.\n   *\n   * This is a how we notify all cell directives about changes in a column. It is done through angular CD logic and does not require manual\n   * CD kicks and special channels between pblNgridColumnDef and it's children.\n   */\n  markForCheck(): void {\n    if (!this._colDiffer) {\n      this._colDiffer = this._differs.find({}).create();\n      this._colDiffer.diff({});\n    }\n    this._markedForCheck = true;\n  }\n\n  /**\n   * Update the width definitions for this column. [minWidth, width, maxWidth]\n   * If an element is provided it will also apply the widths to the element.\n   * @param width The new width\n   * @param element Optional, an element to apply the width to, if not set will only update the width definitions.\n   */\n  updateWidth(width: string, element?: HTMLElement): void {\n    const { isFixedWidth } = this._column;\n\n    /*  Setting the minimum width is based on the input.\n        If the original width is pixel fixed we will take the maximum between it and the min width.\n        If not, we will the take minWidth.\n        If none of the above worked we will try to see if the current width is set with %, if so it will be our min width.\n    */\n    const minWidthPx = isFixedWidth\n      ? Math.max(this._column.parsedWidth.value, this._column.minWidth || 0)\n      : this._column.minWidth\n    ;\n\n    let minWidth = minWidthPx && `${minWidthPx}px`;\n    if (!minWidth) {\n      const parsed = parseStyleWidth(width);\n      if (parsed && parsed.type === '%') {\n        minWidth = width;\n      }\n    }\n\n    const maxWidth = isFixedWidth\n      ? Math.min(this._column.parsedWidth.value, this._column.maxWidth || this._column.parsedWidth.value)\n      : this._column.maxWidth\n    ;\n\n    this._widths = [minWidth || '',  width, maxWidth ? `${maxWidth}px` : width];\n    if (element) {\n      this.applyWidth(element);\n    }\n  }\n\n  /**\n   * Apply the current width definitions (minWidth, width, maxWidth) onto the element.\n   */\n  applyWidth(element: HTMLElement): void {\n    setWidth(element, this.widths);\n  }\n\n  /**\n   * Query for cell elements related to this column definition.\n   *\n   * This query is not cached - cache in implementation.\n   */\n  queryCellElements(...filter: Array<'table' | 'header' | 'headerGroup' | 'footer' | 'footerGroup'>): HTMLElement[] {\n    const cssId = `.${uniqueColumnCss(this)}`;\n\n    const query: string[] = [];\n\n    if (filter.length === 0) {\n      query.push(cssId);\n    } else {\n      for (const f of filter) {\n        switch (f) {\n          case 'table':\n           query.push(`.pbl-ngrid-cell${cssId}`);\n           break;\n          case 'header':\n           query.push(`.pbl-ngrid-header-cell${cssId}:not(.pbl-header-group-cell)`);\n           break;\n          case 'headerGroup':\n           query.push(`.pbl-header-group-cell${cssId}`);\n           break;\n          case 'footer':\n           query.push(`.pbl-ngrid-footer-cell${cssId}:not(.pbl-footer-group-cell)`);\n           break;\n          case 'footerGroup':\n           query.push(`.pbl-footer-group-cell${cssId}`);\n           break;\n        }\n      }\n    }\n    // we query from the master table container and not CDKTable because of fixed meta rows\n    return query.length === 0 ? [] : Array.from(this.extApi.element.querySelectorAll(query.join(', '))) as any;\n  }\n\n  /** @internal */\n  ngDoCheck(): void {\n    if (this._isDirty) {\n      this._isDirty = false;\n    }\n  }\n\n  /** @internal */\n  ngOnDestroy(): void { this.detach(); }\n\n  onResize(): void {\n    if (isPblColumn(this.column)) {\n      const prevNetWidth = this._netWidth;\n      this._netWidth = this.extApi.dynamicColumnWidthFactory().widthBreakout(this.column.sizeInfo).content;\n\n      if (prevNetWidth && prevNetWidth !== this._netWidth) {\n        const width = `${this._netWidth}px`;\n        this._widths = [\n          this.widths[0] || width,  // min\n          width,                    // width\n          width,                    // max\n        ];\n      }\n    }\n  }\n\n  updatePin(pin?: 'start' | 'end'): void {\n    this.sticky = this.stickyEnd = false;\n    switch(pin) {\n      case 'start':\n        this.sticky = true;\n        break;\n      case 'end':\n        this.stickyEnd = true;\n        break;\n    }\n    if (this.table.isInit) {\n      this.table._cdkTable.updateStickyColumnStyles();\n    }\n  }\n\n  private attach(column: T): void {\n    if (this._column !== column) {\n      this.detach();\n      if (column) {\n        this._column = column;\n        (column as any).attach(this);\n        this.name = column.id.replace(/ /g, '_');\n\n        if (isPblColumn(column)) {\n          this.updatePin(column.pin);\n        }\n      }\n\n      if (this._colDiffer) {\n        this.markForCheck();\n      }\n    }\n  }\n\n  private detach(): void {\n    if (this._column) {\n      this._column.detach();\n      this._column = undefined;\n    }\n  }\n}\n\n/**\n * Set the widths of an HTMLElement\n * @param el The element to set widths to\n * @param widths The widths, a tuple of 3 strings [ MIN-WIDTH, WIDTH, MAX-WIDTH ]\n */\nfunction setWidth(el: HTMLElement, widths: [string, string, string]) {\n  el.style.minWidth = widths[0];\n  el.style.width = widths[1];\n  el.style.maxWidth = widths[2];\n\n  // TODO(shlomiassaf)[perf, 4]: Instead of using a tuple for width, use a CSSStyleDeclaration object and just assign the props\n  // This will avoid the additional check for %\n  // We will need to implement it in all places that `_widths` is updated in `PblNgridColumnDef`\n  // Another TODO is to cache the previous `boxSizing` in any case the column definition changes.\n\n  // When the column does not have an explicit `minWidth` set and when the `width` is set explicitly to a % value\n  // the logic in `PblNgridColumnDef.updateWidth` will set `minWidth` to the same value in `width`\n  // This will cause an overflow unless we apply the border-box model\n  if (widths[0] && widths[0].endsWith('%')) {\n    el.style.boxSizing = 'border-box';\n  }\n}\n","// tslint:disable:use-host-property-decorator\n// tslint:disable:directive-selector\nimport { first } from 'rxjs/operators';\nimport {\n  OnInit,\n  AfterViewInit,\n  Component,\n  Directive,\n  ElementRef,\n  DoCheck,\n  ChangeDetectionStrategy,\n  ViewEncapsulation,\n  ViewContainerRef,\n  ViewChild,\n  NgZone,\n  EmbeddedViewRef,\n  Input,\n} from '@angular/core';\nimport { CdkHeaderCell, CdkCell, CdkFooterCell } from '@angular/cdk/table';\n\nimport { PblNgridComponent } from '../table.component';\nimport { uniqueColumnCss, uniqueColumnTypeCss, COLUMN_EDITABLE_CELL_CLASS } from '../circular-dep-bridge';\nimport { COLUMN, PblMetaColumn, PblColumn, PblColumnGroup } from '../columns';\nimport { MetaCellContext, PblNgridMetaCellContext, PblRowContext, PblCellContext } from '../context/index';\nimport { PblNgridMultiRegistryMap } from '../services/table-registry.service';\nimport { PblNgridColumnDef } from './column-def';\nimport { PblNgridDataHeaderExtensionContext, PblNgridMultiComponentRegistry, PblNgridMultiTemplateRegistry } from './registry.directives';\n\nconst HEADER_GROUP_CSS = `pbl-header-group-cell`;\nconst HEADER_GROUP_PLACE_HOLDER_CSS = `pbl-header-group-cell-placeholder`;\n\nfunction initCellElement(el: HTMLElement, column: COLUMN): void {\n  el.classList.add(uniqueColumnCss(column.columnDef));\n  if (column.type) {\n    el.classList.add(uniqueColumnTypeCss(column.type));\n  }\n  if (column.css) {\n    const css = column.css.split(' ');\n    for (const c of css) {\n      el.classList.add(c);\n    }\n  }\n}\n\nfunction initDataCellElement(el: HTMLElement, column: PblColumn): void {\n  if (column.editable && column.editorTpl) {\n    el.classList.add(COLUMN_EDITABLE_CELL_CLASS);\n  }\n}\n\nconst lastDataHeaderExtensions = new Map<PblNgridComponent<any>, PblNgridMultiRegistryMap['dataHeaderExtensions'][]>();\n\n/**\n * Header cell component.\n * The header cell component will render the header cell template and add the proper classes and role.\n *\n * It is also responsible for creating and managing the any `dataHeaderExtensions` registered in the registry.\n * These extensions add features to the cells either as a template instance or as a component instance.\n * Examples: Sorting behavior, drag&drop/resize handlers, menus etc...\n */\n@Component({\n  selector: 'pbl-ngrid-header-cell',\n  host: {\n    class: 'pbl-ngrid-header-cell',\n    role: 'columnheader',\n  },\n  exportAs: 'ngridHeaderCell',\n  template: `<ng-container #vcRef></ng-container>`,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n})\nexport class PblNgridHeaderCellComponent<T extends COLUMN = COLUMN> extends CdkHeaderCell implements DoCheck, OnInit, AfterViewInit {\n  @ViewChild('vcRef', { read: ViewContainerRef, static: true }) vcRef: ViewContainerRef;\n\n  private el: HTMLElement;\n\n  cellCtx: PblNgridDataHeaderExtensionContext | MetaCellContext;\n\n  constructor(public readonly columnDef: PblNgridColumnDef<T>,\n              public readonly table: PblNgridComponent<any>,\n              public readonly elementRef: ElementRef,\n              private zone: NgZone) {\n    super(columnDef, elementRef);\n    const column = columnDef.column;\n    const el = this.el = elementRef.nativeElement;\n\n    if (column instanceof PblColumnGroup) {\n      el.classList.add(HEADER_GROUP_CSS);\n      if (column.placeholder) {\n        el.classList.add(HEADER_GROUP_PLACE_HOLDER_CSS);\n      }\n    }\n  }\n\n  ngOnInit(): void {\n    const col: COLUMN = this.columnDef.column;\n    if (col instanceof PblColumn) {\n      this.cellCtx = PblNgridDataHeaderExtensionContext.createDateHeaderCtx(this as PblNgridHeaderCellComponent<PblColumn>, this.vcRef.injector);\n    } else {\n      this.cellCtx = MetaCellContext.create(col, this.table);\n    }\n  }\n\n  ngAfterViewInit(): void {\n    const col: COLUMN = this.columnDef.column;\n    const { vcRef } = this;\n    let view: EmbeddedViewRef<PblNgridMetaCellContext<any, PblMetaColumn | PblColumn>>;\n\n    if (col instanceof PblColumn) {\n      const context = this.cellCtx as PblNgridDataHeaderExtensionContext;\n      view = vcRef.createEmbeddedView(col.headerCellTpl, context);\n      this.zone.onStable\n        .pipe(first())\n        .subscribe( () => {\n          this.runHeaderExtensions(context, view as EmbeddedViewRef<PblNgridMetaCellContext<any, PblColumn>>);\n          const v = vcRef.get(0);\n          // at this point the view might get destroyed, its possible...\n          if (!v.destroyed) {\n            v.detectChanges();\n          }\n        });\n    } else {\n      view = vcRef.createEmbeddedView(col.template, this.cellCtx);\n    }\n\n    view.detectChanges();\n    this.columnDef.applyWidth(this.el);\n    initCellElement(this.el, col);\n  }\n\n  // TODO: smart diff handling... handle all diffs, not just width, and change only when required.\n  ngDoCheck(): void {\n    if (this.columnDef.isDirty) {\n      this.columnDef.applyWidth(this.el);\n    }\n  }\n\n  protected runHeaderExtensions(context: PblNgridDataHeaderExtensionContext, view: EmbeddedViewRef<PblNgridMetaCellContext<any, PblColumn>>): void {\n    // we collect the first header extension for each unique name only once per table instance\n    let extensions = lastDataHeaderExtensions.get(this.table);\n    if (!extensions) {\n      const dataHeaderExtensions = new Map<string, any>();\n\n      this.table.registry.forMulti('dataHeaderExtensions', values => {\n        for (const value of values) {\n          if (!dataHeaderExtensions.has(value.name)) {\n            dataHeaderExtensions.set(value.name, value);\n          }\n        }\n      });\n\n      extensions = Array.from(dataHeaderExtensions.values());\n      lastDataHeaderExtensions.set(this.table, extensions);\n      // destroy it on the next turn, we know all cells will render on the same turn.\n      this.zone.onStable.pipe(first()).subscribe( () => lastDataHeaderExtensions.delete(this.table) );\n    }\n\n    let { rootNodes } = view;\n\n    for (const ext of extensions) {\n      if (!ext.shouldRender || ext.shouldRender(context)) {\n        if (ext instanceof PblNgridMultiTemplateRegistry) {\n          const extView = this.vcRef.createEmbeddedView(ext.tRef, context);\n          extView.markForCheck();\n        } else if (ext instanceof PblNgridMultiComponentRegistry) {\n          rootNodes = this.createComponent(ext, context, rootNodes);\n        }\n      }\n    }\n  }\n\n  protected createComponent(ext: PblNgridMultiComponentRegistry<any, \"dataHeaderExtensions\">, context: PblNgridDataHeaderExtensionContext, rootNodes: any[]): any[] {\n    const factory = ext.getFactory(context);\n    const projectedContent: any[][] = [];\n\n    if (ext.projectContent) {\n      projectedContent.push(rootNodes);\n    }\n\n    const cmpRef = this.vcRef.createComponent(factory, 0, null, projectedContent);\n\n    if (ext.projectContent) {\n      rootNodes = [ cmpRef.location.nativeElement ];\n    }\n\n    if (ext.onCreated) {\n      ext.onCreated(context, cmpRef);\n    }\n\n    return rootNodes;\n  }\n}\n\n/** Cell template container that adds the right classes and role. */\n@Directive({\n  selector: 'pbl-ngrid-cell',\n  host: {\n    'class': 'pbl-ngrid-cell',\n    'role': 'gridcell',\n  },\n  exportAs: 'pblNgridCell',\n})\nexport class PblNgridCellDirective extends CdkCell implements DoCheck {\n\n  @Input() set rowCtx(value: PblRowContext<any>) {\n    if (value !== this._rowCtx) {\n      this._rowCtx = value;\n      this.ngDoCheck();\n    }\n  }\n\n  private _rowCtx: PblRowContext<any>;\n  cellCtx: PblCellContext | undefined;\n\n  /**\n   * The position of the column def among all columns regardless of visibility.\n   */\n  private colIndex: number;\n  private el: HTMLElement;\n  private focused = false;\n  private selected = false;\n\n  constructor(private colDef: PblNgridColumnDef, elementRef: ElementRef) {\n    super(colDef, elementRef);\n    this.colIndex = this.colDef.table.columnApi.indexOf(colDef.column as PblColumn);\n    this.el = elementRef.nativeElement;\n    colDef.applyWidth(this.el);\n    initCellElement(this.el, colDef.column);\n    initDataCellElement(this.el, colDef.column as PblColumn);\n  }\n\n  // TODO: smart diff handling... handle all diffs, not just width, and change only when required.\n  ngDoCheck(): void {\n    if (this.colDef.isDirty) {\n      this.colDef.applyWidth(this.el);\n    }\n\n    if (this._rowCtx) {\n      const cellContext = this.cellCtx = this._rowCtx.cell(this.colIndex);\n\n      if (cellContext.focused !== this.focused) {\n\n        if (this.focused = cellContext.focused) {\n          this.el.classList.add('pbl-ngrid-cell-focused');\n        } else {\n          this.el.classList.remove('pbl-ngrid-cell-focused');\n        }\n      }\n      if (this.cellCtx.selected !== this.selected) {\n        if (this.selected = cellContext.selected) {\n          this.el.classList.add('pbl-ngrid-cell-selected');\n        } else {\n          this.el.classList.remove('pbl-ngrid-cell-selected');\n        }\n      }\n    }\n  }\n}\n\n@Directive({\n  selector: 'pbl-ngrid-footer-cell',\n  host: {\n    'class': 'pbl-ngrid-footer-cell',\n    'role': 'gridcell',\n  },\n  exportAs: 'ngridFooterCell',\n })\nexport class PblNgridFooterCellDirective extends CdkFooterCell implements DoCheck, OnInit {\n  private el: HTMLElement;\n  cellCtx: MetaCellContext;\n\n  constructor(private columnDef: PblNgridColumnDef<PblMetaColumn | PblColumnGroup>, public table: PblNgridComponent, elementRef: ElementRef) {\n    super(columnDef, elementRef);\n    this.el = elementRef.nativeElement;\n    const column = columnDef.column;\n    columnDef.applyWidth(this.el);\n    initCellElement(this.el, column);\n  }\n\n  // TODO: smart diff handling... handle all diffs, not just width, and change only when required.\n  ngDoCheck(): void {\n    if (this.columnDef.isDirty) {\n      this.columnDef.applyWidth(this.el);\n    }\n  }\n\n  ngOnInit(): void {\n    this.cellCtx = MetaCellContext.create(this.columnDef.column, this.table);\n  }\n}\n","import { Directive, Input, ElementRef } from '@angular/core';\nimport { StylingDiffer, StylingDifferOptions } from './styling_differ';\n\n/*\n    We're using `StylingDiffer`, which is an exact copy of the style differ used for `ngStyle` and `ngClass`.\n    The class is not exposed so we use a hard-copy.\n    `StylingDiffer` is used only when IVY is enabled but here we've adopted it to be used in both modes. (pre IVY and IVY)\n*/\n\n\n/**\n * Bind to the class / style attributes of the container of a cell template.\n * For class bindings use [ngridCellClass] and for style bindings use [ngridCellStyle].\n *\n * This is like [ngClass] or [ngStyle] but not for the host of the directive but to it's parent.\n *\n * - [ngridCellClass] accepts the same type of values that [ngClass] does.\n * - [ngridCellStyle] accepts the same type of values that [ngStyle] does.\n *\n * ## Example\n *\n * We want to create a new cell type called \"balance\" that represents the balance of a bank account.\n * We also want to have different background color, green if the account balance if positive and red if it's negative.\n *\n * ```html\n * <div *pblNgridCellTypeDef=\"'balance'; value as value\"\n *      [ngClass]=\"value < 0 ? 'balance-negative' : 'balance-positive'\">{{ value  }}\n * </div>\n * ```\n *\n * The example above will work but the background will not fill the entire cell, only the `div` it is applied on.\n * This is because the container of the `div` has internal styling that apply padding (among other styles) to the cell.\n *\n * The container is controlled internally by ngrid, but you can access it's style / class attributes using this directive.\n *\n * ```html\n * <div *pblNgridCellTypeDef=\"'balance'; value as value\"\n *      [ngridCellClass]=\"value < 0 ? 'balance-negative' : 'balance-positive'\">{{ value  }}\n * </div>\n * ```\n *\n * > Because style / class is applied on the parent and the parent can have multiple children it is possible to apply this directive\n * on multiple children, do not do this as it will have unexpected results.\n */\n@Directive({ selector: '[ngridCellStyle], [ngridCellClass]' })\nexport class PblNgridCellStyling {\n\n  @Input('ngridCellStyle') set style(value: { [key: string]: string }) {\n    if (!this._styleDiffer) {\n      this._styleDiffer = new StylingDiffer<{ [key: string]: any } | null>('NgStyle', StylingDifferOptions.AllowUnits);\n    }\n    this._styleDiffer.setValue(value);\n  }\n\n  @Input('ngridCellClass') set klass(value: string | string[] | Set<string> | { [klass: string]: any }) {\n    if (!this._classDiffer) {\n      this._classDiffer = new StylingDiffer<{ [klass: string]: boolean }>(\n        'NgClass',\n        StylingDifferOptions.TrimProperties | StylingDifferOptions.AllowSubKeys | StylingDifferOptions.AllowStringValue | StylingDifferOptions.ForceAsMap,\n      );\n    }\n    this._classDiffer.setValue(value);\n  }\n\n  private _styleDiffer: StylingDiffer<{ [key: string]: any } | null>;\n  private _classDiffer: StylingDiffer<{ [klass: string]: boolean }>;\n  private _parent: HTMLElement;\n  private _lastStyle = new Set<string>();\n  private _lastClass = new Set<string>();\n\n  constructor(private elRef: ElementRef<HTMLElement>) { }\n\n  ngAfterViewInit(): void {\n    this._parent = this.elRef.nativeElement.parentElement;\n    this.updateParent();\n  }\n\n  ngDoCheck(): void { this,this.updateParent(); }\n\n  private updateParent(): void {\n    if (this._parent) {\n      if (this._styleDiffer && this._styleDiffer.hasValueChanged()) {\n        const lastStyle = this._lastStyle;\n        this._lastStyle = new Set<string>();\n        for (const key of Object.keys(this._styleDiffer.value)) {\n          this._parent.style[key] = this._styleDiffer.value[key];\n          lastStyle.delete(key);\n          this._lastStyle.add(key);\n        }\n        if (lastStyle.size > 0) {\n          for (const key of lastStyle.values()) {\n            this._parent.style[key] = null;\n          }\n        }\n      }\n\n      if (this._classDiffer && this._classDiffer.hasValueChanged()) {\n        const lastClass = this._lastClass;\n        this._lastClass = new Set<string>();\n        for (const key of Object.keys(this._classDiffer.value)) {\n          if (this._classDiffer.value[key]) {\n            this._parent.classList.add(key);\n            this._lastClass.add(key);\n          } else {\n            this._parent.classList.remove(key);\n          }\n          lastClass.delete(key);\n        }\n        if (lastClass.size > 0) {\n          for (const key of lastClass.values()) {\n            this._parent.classList.remove(key);\n          }\n        }\n      }\n    }\n  }\n}\n","import { take } from 'rxjs/operators';\n\nimport { Directive, AfterViewInit, ElementRef, Input, NgZone, OnDestroy } from '@angular/core';\nimport { PblNgridCellContext } from '../context/index';\n\n@Directive({ selector: '[pblCellEditAutoFocus]' })\nexport class PblNgridCellEditAutoFocusDirective implements AfterViewInit, OnDestroy {\n\n  // tslint:disable-next-line:no-input-rename\n  @Input('pblCellEditAutoFocus') context: PblNgridCellContext<any>;\n\n  private _destroyed: boolean;\n\n  constructor(private elRef: ElementRef<HTMLElement>, private ngZone: NgZone) { }\n\n  ngAfterViewInit(): void {\n    const doFocus = () => {\n      const context = this.context;\n      context.rowContext.updateOutOfViewState();\n      if (context.editing && !context.rowContext.outOfView) {\n        this.elRef.nativeElement.focus();\n      }\n    };\n\n    this.ngZone.runOutsideAngular(() => {\n      Promise.resolve().then(() => {\n        if (!this._destroyed) {\n          const { viewport } = this.context.table;\n          if (viewport && viewport.isScrolling) {\n            viewport.scrolling.pipe(take(1)).subscribe(doFocus);\n          } else {\n            doFocus();\n          }\n        }\n      });\n    });\n  }\n\n  ngOnDestroy(): void {\n    this._destroyed = true;\n  }\n}\n","import { EmbeddedViewRef, ViewContainerRef } from '@angular/core';\nimport { ListRange } from '@angular/cdk/collections';\n\nexport type StickyDirectionVt = 'top' | 'bottom';\nexport type StickyDirectionHz = 'left' | 'right';\n\n/**\n * Returns the split range from an aggregated range.\n * An aggregated range describes the range of header, data and footer rows currently in view.\n * This function will split the range into core section, each having it's own range.\n *\n * Note that an aggregated range can span over a single section, all sections or just 2 sections.\n * If a section is not part of the aggregated range it's range is invalid, i.e: ListRange.start >= ListRange.end.\n *\n * @param range The aggregated range\n * @param headerLen The total length of header rows in the table\n * @param dataLen The total length of data rows in the table\n * @returns A tuple containing the ranges [header, data, footer].\n */\nexport function splitRange(range: ListRange, headerLen: number, dataLen: number): [ListRange, ListRange, ListRange] {\n  return [\n    { start: range.start, end: headerLen },\n    { start: Math.max(0, range.start - headerLen), end: Math.max(0, range.end - headerLen) },\n    { start: 0, end: Math.max(0, range.end - (dataLen + headerLen)) },\n  ];\n}\n\n/**\n * Update sticky positioning values to the rows to match virtual scroll content offset.\n * This function should run after `CdkTable` updated the sticky rows.\n *\n * ## Why\n * `CdkTable` applies sticky positioning to rows by setting top/bottom value to `0px`.\n * Virtual scroll use's a container with an offset to simulate the scrolling.\n *\n * The 2 does not work together, the virtual scroll offset will throw the sticky row out of bound, thus the top/bottom value must be compensated\n * based on the offset.\n */\nexport function updateStickyRows(offset: number, rows: HTMLElement[], stickyState: boolean[], type: StickyDirectionVt): void {\n  const coeff = type === 'top' ? -1 : 1;\n  let agg = 0;\n\n  if (coeff === 1) {\n    rows = rows.slice().reverse();\n  }\n  for (const i in rows) {\n    if (stickyState[i]) {\n      const row = rows[i];\n      row.style[type] = `${coeff * (offset + (coeff * agg))}px`;\n      agg += row.getBoundingClientRect().height; // TODO: cache this and update cache actively (size change)\n      row.style.display = null;\n    }\n  }\n}\n\n/**\n * Measures the combined size (width for horizontal orientation, height for vertical) of all items\n * in the specified view within the specified range.\n * Throws an error if the range includes items that are not currently rendered.\n *\n * > This is function is identical to `CdkVirtualForOf.measureRangeSize` with minor adjustments\n */\nexport function measureRangeSize(viewContainer: ViewContainerRef,\n                                 range: ListRange,\n                                 renderedRange: ListRange,\n                                 orientation: 'horizontal' | 'vertical',\n                                 stickyState: boolean[] = []): number {\n  if (range.start >= range.end) {\n    return 0;\n  }\n\n  if (range.start < renderedRange.start || range.end > renderedRange.end) {\n    throw Error(`Error: attempted to measure an item that isn't rendered.`);\n  }\n\n  // The index into the list of rendered views for the first item in the range.\n  const renderedStartIndex = range.start - renderedRange.start;\n  // The length of the range we're measuring.\n  const rangeLen = range.end - range.start;\n\n  // Loop over all root nodes for all items in the range and sum up their size.\n  let totalSize = 0;\n  let i = rangeLen;\n  while (i--) {\n    const index = i + renderedStartIndex;\n    if (!stickyState[index]) {\n      const view = viewContainer.get(index) as EmbeddedViewRef<any> | null;\n      let j = view ? view.rootNodes.length : 0;\n      while (j--) {\n        totalSize += getSize(orientation, view.rootNodes[j]);\n      }\n    }\n  }\n\n  return totalSize;\n}\n\n/** Helper to extract size from a DOM Node. */\nfunction getSize(orientation: 'horizontal' | 'vertical', node: Node): number {\n  const el = node as Element;\n  if (!el.getBoundingClientRect) {\n    return 0;\n  }\n  const rect = el.getBoundingClientRect();\n  return orientation == 'horizontal' ? rect.width : rect.height;\n}\n","\nimport { ViewContainerRef } from '@angular/core';\nimport { PblCdkVirtualScrollViewportComponent } from './virtual-scroll-viewport.component';\nimport { updateStickyRows } from './utils';\n\n/**\n * A class that manages the life cycle of sticky meta rows (header & footer) while scrolling.\n * Sticky meta rows are moved to containers outside of the table so they do not depend on the `position: sticky` property.\n *\n * For `position: sticky` to work, a reference position is required (`top` for header, `bottom` for footer) which must reflect the current\n * offset measured by the virtual scroll viewport (this position compensate the offset of virtual scroll so the position is leveled, i.e. like top 0)\n *\n * When the user scroll's:\n * - The offset changes by the browser\n * - The virtual scroll will detect the new offset and update the wrapper with the new offset.\n *\n * There is a time gap between the operations above which causes rows to flicker in and out of view, this is why we move them to a fixed location.\n */\nexport class MetaRowStickyScroll {\n\n  private runningHeader = false;\n  private runningFooter = false;\n  private canMoveHeader = true;\n  private canMoveFooter = true;\n  private movedFooterRows: Array<[HTMLElement, HTMLElement, number]> = [];\n  private movedHeaderRows: Array<[HTMLElement, HTMLElement, number]> = [];\n\n  constructor(private viewport: PblCdkVirtualScrollViewportComponent,\n              private viewPortEl: HTMLElement,\n              private metaRows: Record<'header' | 'footer', { rows: HTMLElement[]; sticky: boolean[]; rendered: boolean[] }>) { }\n\n  canMove(): boolean {\n    return this.canMoveHeader || this.canMoveFooter;\n  }\n\n  isRunning(): boolean {\n    return this.runningHeader || this.runningFooter;\n  }\n\n  move(offset: number, viewPortElRect: ClientRect | DOMRect): boolean {\n    this.moveHeader(offset, viewPortElRect);\n    this.moveFooter(offset, viewPortElRect);\n    return this.isRunning() && !this.canMoveHeader && !this.canMoveFooter;\n  }\n\n\n  restore(renderedContentOffset: number): void {\n    const { header, footer } = this.metaRows;\n    if (this.restoreHeader()) {\n      updateStickyRows(renderedContentOffset, header.rows, header.sticky, 'top');\n    }\n    if (this.restoreFooter()) {\n      updateStickyRows(renderedContentOffset, footer.rows, footer.sticky, 'bottom');\n    }\n  }\n\n  private moveHeader(offset: number, viewPortElRect: ClientRect | DOMRect): void {\n    if (!this.runningHeader || this.canMoveHeader) {\n      this.runningHeader = true;\n      this.canMoveHeader = false;\n\n      const stickyAndRendered: number[] = [];\n      const headerRows = this.metaRows.header;\n      let mostTopRect: ClientRect | DOMRect;\n      for (let i = 0, len = headerRows.rows.length; i < len; i++) {\n        const rowEl = headerRows.rows[i];\n        if (headerRows.sticky[i]) {\n          const elRect = rowEl.getBoundingClientRect();\n          if (headerRows.rendered[i]) {\n            const calc = elRect.top - viewPortElRect.top - offset;\n\n            // if after the scroll the element is still in view, return\n            if (calc >= 0 || -calc < viewPortElRect.height) {\n              this.canMoveHeader = true;\n              return;\n            }\n          }\n          if (!mostTopRect) {\n            mostTopRect = elRect;\n          }\n          stickyAndRendered.push(i);\n        }\n      }\n\n      if (stickyAndRendered.length) {\n        this.viewport.stickyRowHeaderContainer.style.top = mostTopRect.top + 'px';\n        this.cloneAndMoveRow(this.viewport.stickyRowHeaderContainer,  headerRows.rows, stickyAndRendered, this.movedHeaderRows);\n      }\n    }\n  }\n\n  private moveFooter(offset: number, viewPortElRect: ClientRect | DOMRect): void {\n    if (!this.runningFooter || this.canMoveFooter) {\n      this.runningFooter = true;\n      this.canMoveFooter = false;\n\n      const stickyAndRendered: number[] = [];\n      const footerRows = this.metaRows.footer;\n      let mostTopRect: ClientRect | DOMRect;\n      for (let i = 0, len = footerRows.rows.length; i < len; i++) {\n        const rowEl = footerRows.rows[i];\n        if (footerRows.sticky[i]) {\n          const elRect = rowEl.getBoundingClientRect();\n          if (footerRows.rendered[i]) {\n            const calc = elRect.bottom - viewPortElRect.bottom + offset;\n\n            // if after the scroll the element is still in view, return\n            if (calc >= 0 && calc < viewPortElRect.height) {\n              this.canMoveFooter = true;\n              return;\n            }\n          }\n          mostTopRect = elRect;\n          stickyAndRendered.push(i);\n        }\n      }\n\n      if (stickyAndRendered.length) {\n        this.viewport.stickyRowFooterContainer.style.bottom = `calc(100% - ${mostTopRect.bottom}px)`\n        this.cloneAndMoveRow(this.viewport.stickyRowFooterContainer, footerRows.rows, stickyAndRendered, this.movedFooterRows);\n      }\n    }\n  }\n\n  private restoreHeader(): boolean {\n    if (this.runningHeader) {\n      const movedHeaderRows = this.movedHeaderRows;\n      this.movedHeaderRows = [];\n      this.restoreRows(movedHeaderRows, this.metaRows.header.rows);\n      this.runningHeader = false;\n      this.canMoveHeader = true;\n      return true;\n    }\n    return false;\n  }\n\n  private restoreFooter(): boolean {\n    if (this.runningFooter) {\n      const movedFooterRows = this.movedFooterRows;\n      this.movedFooterRows = [];\n      this.restoreRows(movedFooterRows, this.metaRows.footer.rows);\n      this.runningFooter = false;\n      this.canMoveFooter = true;\n      return true;\n    }\n    return false;\n  }\n\n  private cloneAndMoveRow(stickyRowContainer: HTMLElement,\n                          rows: HTMLElement[],\n                          stickyAndRendered: number[],\n                          restoreRef: Array<[HTMLElement, HTMLElement, number]>): void {\n    const innerRowContainer = stickyRowContainer.firstElementChild as HTMLElement;\n    stickyRowContainer.style.width = this.viewport.innerWidth + 'px';\n    innerRowContainer.style.transform = `translateX(-${this.viewPortEl.scrollLeft}px)`;\n    for (const i of stickyAndRendered) {\n      const rowEl = rows[i];\n      const clone = rowEl.cloneNode() as HTMLElement;\n      clone.style.width = '0';\n      rowEl.style.top = rowEl.style.bottom = rowEl.style.position = '';\n      rowEl.parentElement.insertBefore(clone, rowEl);\n      innerRowContainer.appendChild(rowEl);\n      restoreRef.push([rowEl, clone, i]);\n      // Assign the clone to be the sticky row element, this will ensure that stick row updates\n      // will set the `top` on an actual element in the viewport, thus updating with each layout reflow.\n      // if not set, when we return the original row it's `top` value will be true but will not show because it will not trigger a reflow.\n      rows[i] = clone;\n    }\n  }\n\n  private restoreRows(restoreRef: Array<[HTMLElement, HTMLElement, number]>, rows: HTMLElement[]): void {\n    for (const [rowEl, clone, index] of restoreRef) {\n      rowEl.style.position = clone.style.position;\n      rowEl.style.zIndex = clone.style.zIndex;\n      rowEl.style.top = clone.style.top;\n      rowEl.style.bottom = clone.style.bottom;\n\n      clone.parentElement.insertBefore(rowEl, clone);\n      clone.parentElement.removeChild(clone);\n      rows[index] = rowEl;\n    }\n  }\n}\n","import { Observable, Subject, fromEvent, race, timer } from 'rxjs';\nimport { filter, startWith, pairwise, take, tap, takeUntil, map, debounceTime } from 'rxjs/operators';\n\nimport { NgZone, ViewContainerRef } from '@angular/core';\nimport { CollectionViewer, ListRange } from '@angular/cdk/collections';\n\nimport { PblNgridExtensionApi } from '../../../ext/table-ext-api';\nimport { PblNgridComponent } from '../../table.component';\nimport { PblNgridPluginController } from '../../../ext/plugin-control';\nimport { PblDataSource } from '../../../data-source/data-source';\nimport { PblCdkTableComponent } from '../../pbl-cdk-table/pbl-cdk-table.component';\nimport { PblCdkVirtualScrollViewportComponent } from './virtual-scroll-viewport.component';\nimport { splitRange, updateStickyRows, measureRangeSize, StickyDirectionVt } from './utils';\nimport { MetaRowStickyScroll } from './meta-row-sticky-scroll';\n\nconst FIXED_HEADER_MODE = true;\n\nfunction sortByIndex(a: { index: number }, b: { index: number }) { return a.index - b.index };\n\nexport interface NgeVirtualTableRowInfo {\n  readonly headerLength: number;\n  readonly rowLength: number;\n  readonly footerLength: number;\n}\n\nexport class PblVirtualScrollForOf<T> implements CollectionViewer, NgeVirtualTableRowInfo {\n  viewChange: Observable<ListRange>;\n\n  dataStream: Observable<T[] | ReadonlyArray<T>>;\n\n  get headerLength(): number { return this.header.rows.length  }\n  get rowLength(): number { return this.vcRefs.data.length  }\n  get footerLength(): number { return this.footer.rows.length  }\n\n  private destroyed = new Subject<void>();\n  private ds: PblDataSource<T>;\n\n  private get vcRefs(): Record<'header' | 'data' | 'footer', ViewContainerRef> {\n    const value = {\n      header: this.cdkTable._headerRowOutlet.viewContainer,\n      data: this.cdkTable._rowOutlet.viewContainer,\n      footer: this.cdkTable._footerRowOutlet.viewContainer,\n    };\n    Object.defineProperty(this, 'vcRefs', { value, configurable: true });\n    return value;\n  }\n\n  private renderedContentOffset = 0;\n  /** A tuple containing the last known ranges [header, data, footer] */\n  private _renderedRanges: [ListRange, ListRange, ListRange];\n  /** The length of meta rows [0] = header [1] = footer */\n  private metaRows: [number, number] = [0, 0];\n\n  private header = { rows: [] as HTMLElement[], sticky: [] as boolean[], rendered: [] as boolean[] };\n  private footer = { rows: [] as HTMLElement[], sticky: [] as boolean[], rendered: [] as boolean[] };\n\n  private table: PblNgridComponent<T>;\n  private cdkTable: PblCdkTableComponent<T>;\n  private viewport: PblCdkVirtualScrollViewportComponent;\n  constructor(private extApi: PblNgridExtensionApi<T>, private ngZone: NgZone) {\n    this.table = extApi.table;\n    this.cdkTable = extApi.cdkTable;\n    this.viewport = extApi.table.viewport;\n\n    this.viewChange = this.cdkTable.viewChange;\n\n    PblNgridPluginController.find(extApi.table).events\n      .pipe( takeUntil(this.destroyed) )\n      .subscribe( event => {\n        if (event.kind === 'onDataSource') {\n          this.detachView();\n          this.attachView(event.curr);\n        }\n      });\n    this.attachView(extApi.table.ds);\n\n    extApi.metaRowService.sync\n      .pipe( takeUntil(this.destroyed) )\n      .subscribe( () => {\n        const headers = extApi.metaRowService.header.row.concat(extApi.metaRowService.header.sticky).sort(sortByIndex);\n        const footers = extApi.metaRowService.footer.row.concat(extApi.metaRowService.footer.sticky).sort(sortByIndex);\n\n        this.header.rows = headers.map( h => h.el );\n        this.header.sticky = headers.map( h => h.rowDef.type === 'sticky' );\n        this.footer.rows = footers.map( h => h.el );\n        this.footer.sticky = footers.map( h => h.rowDef.type === 'sticky' );\n\n        updateStickyRows(this.renderedContentOffset, this.header.rows, this.header.sticky, 'top');\n        updateStickyRows(this.renderedContentOffset, this.footer.rows, this.footer.sticky, 'bottom');\n      });\n\n    if (FIXED_HEADER_MODE) {\n      let offset = 0;\n      const viewPort = this.viewport.elementRef.nativeElement;\n      const metaRowStickyScroll = new MetaRowStickyScroll(this.viewport, viewPort, { header: this.header, footer: this.footer });\n      let scrollPosition: number;\n\n      const wheelListen = () => viewPort.addEventListener('wheel', handler, true);\n      const wheelUnListen = () => viewPort.removeEventListener('wheel', handler, true);\n      const updateScrollPosition = () => scrollPosition = (this.viewport.measureScrollOffset()) / (this.viewport.scrollHeight - this.viewport.getViewportSize());\n\n      const handler = (event: WheelEvent) => {\n        if (event.deltaY) {\n          if ( (scrollPosition === 1 && event.deltaY > 0) || (offset === 0 && event.deltaY < 0)) {\n            return;\n          }\n          let newOffset = offset + event.deltaY;\n          newOffset = Math.min(this.viewport.scrollHeight, Math.max(0, newOffset));\n\n          if (newOffset !== offset) {\n            offset = newOffset;\n            if (metaRowStickyScroll.canMove() && metaRowStickyScroll.move(event.deltaY, viewPort.getBoundingClientRect())) {\n              const scrollEnd$ = this.viewport.scrolling.pipe(filter( s => !s ));\n\n              const restore = () => {\n                metaRowStickyScroll.restore(this.renderedContentOffset);\n                updateScrollPosition();\n              };\n\n              let removedEvent = false;\n              if (this.viewport.wheelMode !== 'blocking') {\n                const wheelMode = this.viewport.wheelMode;\n                if (wheelMode === 'passive') {\n                  wheelUnListen();\n                  this.viewport.scrolling.pipe(debounceTime(150), filter( s => !s ), take(1))\n                    .subscribe( () => {\n                      restore();\n                      wheelListen();\n                    });\n                } else {\n                  this.viewport.scrollFrameRate\n                    .pipe(takeUntil(scrollEnd$.pipe(take(1))))\n                    .subscribe(\n                      frameRate => {\n                        if (!removedEvent && frameRate < wheelMode) {\n                          wheelUnListen();\n                          removedEvent = true;\n                        }\n                      },\n                      null,\n                      () => {\n                        const lastWheel$ = fromEvent(viewPort, 'wheel').pipe(debounceTime(50), take(1));\n                        race(lastWheel$, timer(51) as any)\n                          .subscribe( () => {\n                            restore();\n                            if (removedEvent) {\n                              wheelListen();\n                            }\n                          });\n                          // we restore back after 100 ms, for some reason, if it's immediate, we hit a cycle of wheel/scroll/no-scroll and not wheel/scroll/WAIIIIIT/no-scrol\n                          // TODO: maybe we can measure time between no-scrolling and wheel to find this MS value\n                          //        OR, register a temp `wheel` listener that will detect wheel end and re-register the original handler.\n                      }\n                    );\n                }\n              } else {\n                scrollEnd$.pipe(take(1)).subscribe(restore);\n              }\n            }\n          }\n          this.viewport.scrollToOffset(offset);\n          event.preventDefault();\n          event.stopPropagation();\n          return true;\n        }\n      };\n      updateScrollPosition();\n      wheelListen();\n\n      this.viewport.scrolling.subscribe( isScrolling => {\n        if (!isScrolling) {\n          offset = this.viewport.measureScrollOffset();\n        }\n      });\n    }\n\n    this.viewport.offsetChange\n      .pipe( takeUntil(this.destroyed) )\n      .subscribe( offset => {\n        if (this.renderedContentOffset !== offset) {\n          this.renderedContentOffset = offset;\n          updateStickyRows(offset, this.header.rows, this.header.sticky, 'top');\n          updateStickyRows(offset, this.footer.rows, this.footer.sticky, 'bottom');\n        }\n      });\n  }\n\n  /**\n   * Measures the combined size (width for horizontal orientation, height for vertical) of all items\n   * in the specified range. Throws an error if the range includes items that are not currently\n   * rendered.\n   */\n  measureRangeSize(range: ListRange, orientation: 'horizontal' | 'vertical'): number {\n    if (range.start >= range.end) {\n      return 0;\n    }\n\n    const renderedRanges = this._renderedRanges;\n    const ranges = splitRange(range, this.metaRows[0], this.ds.length);\n    const stickyStates = [ this.header.sticky, [], this.footer.sticky ];\n\n    const vcRefs = [this.vcRefs.header, this.vcRefs.data, this.vcRefs.footer];\n    const vcRefSizeReducer = (total: number, vcRef: ViewContainerRef, index: number): number => {\n      return total + measureRangeSize(vcRef, ranges[index], renderedRanges[index], orientation, stickyStates[index]);\n    };\n\n    return vcRefs.reduce(vcRefSizeReducer, 0);\n  }\n\n  destroy(): void {\n    this.detachView();\n    this.destroyed.next();\n    this.destroyed.complete();\n  }\n\n  private attachView(ds: PblDataSource<T>): void {\n    if (ds) {\n      this.ds = ds;\n      this._renderedRanges = [ { start: 0, end: 0 }, this.cdkTable.viewChange.value, { start: 0, end: 0 } ];\n\n      this.viewport.renderedRangeStream\n        .pipe( takeUntil(this.destroyed) )\n        .subscribe( range => {\n          if (this.headerLength + this.footerLength === 0) { // if no row/sticky meta rows, move on...\n            this._renderedRanges = [ { start: 0, end: 0 }, range, { start: 0, end: 0 } ];\n            return this.cdkTable.viewChange.next(range);\n          }\n\n          /*  WHAT IS GOING ON HERE? */\n\n          /*  Table rows are split into 3 sections: Header, Data, Footer.\n              In the virtual playground only DATA rows are dynamic. Header & Footer rows are fixed.\n\n              The `CdkTable` works the same, also have the same sections with a stream API for DATA rows only.\n              `CdkTable.viewChange.next(RANGE)` will emit to the datasource which will result in a new data section from the datasource.\n\n              `CdkTable` alone does not support virtual scrolling, to achieve it we use a virtual scroll viewport which wraps the entire `CdkTable`.\n              This means that ALL sections are wrapped (hence scrolled over) but only DATA rows are moving...\n\n              Each emission of `ListRange` in `renderedRangeStream` is based on size calculation of ALL sections (see `measureRangeSize` above)\n              and we need to extract the relevant range for DATA rows only and pass it on to the table.\n\n              To make this work we need to extract Header/Footer rows based on the starting position of the range and handle them as well.\n              Because the table will only handle the scrolling of DATA rows we need to update HEADER/FOOTER rows to show/hide based on the range.\n\n              Because Header/Footer rows are fixed we do this by hiding them with `display: none`, unless they are sticky / pinned.\n              One exception is the main header row, which we hide virtually because we need it to render and reflect the cell size.\n\n              We first extract the actual ranges for each section and update the `CdkTable` with the DATA row range.\n              We then wait for the rows to render, which is the time for us to also \"render\" Header/Footer rows...\n              We don't \"render\" them per-se, they are already rendered, we just show/hide them based on the range and state (sticky).\n              This is important, hiding will cause the total height of the scroll container to shrink to the size it should be.\n              We defer this operation to run AFTER the rows are rendered (not immediately) because an immediate change will trigger\n              a change in the scroll container size resulting in a scroll event that will bring us back here but this time with\n              a height that does not fit the range. Immediate change removes rows (Header/Footer) before the new range is applied.\n              Only after the rows are rendered we can show/hide the Header/Footer rows.\n          */\n\n          // Extracting actual ranges for each section.\n          this._renderedRanges = splitRange(range, this.metaRows[0], ds.length);\n          const [ header, data, footer ] = this._renderedRanges;\n\n          this.cdkTable.onRenderRows.pipe(take(1)).subscribe(() => {\n            // We update the header DOM elements in reverse, skipping the last (first when reversed) DOM element.\n            // The skipped element is the table's header row that must keep track of the layout for internal size calculation (e.g. group header rows).\n            // An hidden row is one that is out of range AND not sticky\n            if (this.headerLength > 0) {\n              const htmlRows = this.header.rows;\n              const renderedRows = this.header.rendered;\n              const stickyRows = this.header.sticky;\n              let rowIndex = 0;\n              for (const len = this.header.sticky.length - 1; rowIndex < len; rowIndex++) {\n                // assign rendered state + if not rendered and not sticky, set display to \"none\"\n                htmlRows[rowIndex].style.display = !(renderedRows[rowIndex] = rowIndex >= header.start) && !stickyRows[rowIndex]\n                  ? 'none'\n                  : null\n                ;\n              }\n\n              // Here we update the main header row, when we need to hide it we apply a class that will hide it virtually, i.e. not showing but keeping internal layout.\n              if (!(renderedRows[rowIndex] = rowIndex >= header.start) && !stickyRows[rowIndex]) {\n                htmlRows[rowIndex].classList.add('pbl-ngrid-row-visually-hidden');\n              } else if (this.table.showHeader && htmlRows[rowIndex]) {\n                htmlRows[rowIndex].classList.remove('pbl-ngrid-row-visually-hidden');\n              }\n            }\n\n            if (this.footerLength > 0) {\n              const htmlRows = this.footer.rows;\n              const renderedRows = this.footer.rendered;\n              const stickyRows = this.footer.sticky;\n              let rowIndex = 0;\n              for (const len = this.footer.sticky.length; rowIndex < len; rowIndex++) {\n                // assign rendered state + if not rendered and not sticky, set display to \"none\"\n                htmlRows[rowIndex].style.display = !(renderedRows[rowIndex] = rowIndex < footer.end) && !stickyRows[rowIndex]\n                  ? 'none'\n                  : null\n                ;\n              }\n            }\n          });\n\n          this.cdkTable.viewChange.next(data);\n        });\n\n      // add meta rows to the total row count.\n      this.dataStream = ds.onRenderDataChanging\n        .pipe(\n          takeUntil(this.destroyed),\n          map( ({data}) => {\n            const metaRows = this.metaRows = [ this.header.rows.length, this.footer.rows.length ];\n            return new Array( data.length + metaRows[0] + metaRows[1] );\n          }),\n        );\n\n      ds.onRenderedDataChanged\n        .pipe(\n          takeUntil(this.destroyed),\n          map( () => ds.length ),\n          startWith(0),\n          pairwise(),\n          filter( ([prev, curr]) => prev !== curr ),\n        )\n        .subscribe( ([prev, curr]) => {\n          this.ngZone.onStable.pipe(take(1)).subscribe( () => this.viewport.onSourceLengthChange(prev, curr) );\n        });\n\n      this.viewport.attach(this as any);\n    }\n  }\n\n  private detachView(): void {\n    this.ds = undefined;\n    this.viewport.detach();\n  }\n}\n","import { Observable, Subject } from 'rxjs';\n\nimport {\n  Attribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  Inject,\n  ElementRef,\n  EmbeddedViewRef,\n  IterableDiffers,\n  OnDestroy,\n  Optional,\n  ViewEncapsulation,\n  ViewContainerRef,\n  Injector,\n  NgZone,\n} from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n\nimport { Platform } from '@angular/cdk/platform';\nimport { CDK_TABLE_TEMPLATE, CdkTable, DataRowOutlet, CdkHeaderRowDef, CdkFooterRowDef, RowContext } from '@angular/cdk/table';\nimport { Directionality } from '@angular/cdk/bidi';\n\nimport { PblNgridComponent } from '../table.component';\nimport { PblNgridExtensionApi, EXT_API_TOKEN } from '../../ext/table-ext-api';\nimport { PblNgridColumnDef } from '../directives/column-def';\nimport { PblVirtualScrollForOf } from '../features/virtual-scroll/virtual-scroll-for-of';\n\n/**\n * Wrapper for the CdkTable that extends it's functionality to support various table features.\n * This wrapper also applies Material Design table styles (i.e. `MatTable` styles).\n *\n * Most of the extensions are done using mixins, this is mostly for clarity and separation of the features added.\n * This approach will allow easy removal when a feature is no longer required/implemented natively.\n */\n@Component({\n  selector: 'pbl-cdk-table',\n  exportAs: 'pblCdkTable',\n  template: CDK_TABLE_TEMPLATE,\n  styleUrls: ['./pbl-cdk-table.component.scss'],\n  host: { // tslint:disable-line:use-host-property-decorator\n    'class': 'pbl-cdk-table',\n  },\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class PblCdkTableComponent<T> extends CdkTable<T> implements OnDestroy {\n\n  get _element(): HTMLElement { return this._elementRef.nativeElement; }\n\n  get onRenderRows(): Observable<DataRowOutlet> {\n    if (!this.onRenderRows$) {\n      this.onRenderRows$ = new Subject<DataRowOutlet>();\n    }\n    return this.onRenderRows$.asObservable();\n  }\n\n  get minWidth(): number | null { return this._minWidth; }\n  set minWidth(value: number | null) {\n    this._minWidth = value || null;\n    this._element.style.minWidth = value ? value + 'px' : null;\n  }\n\n  private _minWidth: number | null = null;\n  private onRenderRows$: Subject<DataRowOutlet>;\n  private _lastSticky: PblNgridColumnDef;\n  private _lastStickyEnd: PblNgridColumnDef;\n  private _isStickyPending: boolean;\n\n  constructor(_differs: IterableDiffers,\n              _changeDetectorRef: ChangeDetectorRef,\n              _elementRef: ElementRef<HTMLElement>,\n              @Attribute('role') role: string,\n              @Optional() _dir: Directionality,\n              protected injector: Injector,\n              protected table: PblNgridComponent<T>,\n              @Inject(EXT_API_TOKEN) protected extApi: PblNgridExtensionApi<T>,\n              @Inject(DOCUMENT) _document?: any,\n              platform?: Platform) {\n    super(_differs, _changeDetectorRef, _elementRef, role, _dir, _document, platform);\n    this.table._cdkTable = this;\n    this.trackBy = this.table.trackBy;\n\n    extApi.events.subscribe( e => {\n      if (e.kind === 'beforeInvalidateHeaders') {\n        if (this._lastSticky) {\n          this._lastSticky.queryCellElements('header', 'table', 'footer')\n            .forEach( el => el.classList.remove('pbl-ngrid-sticky-start'));\n          this._lastSticky = undefined;\n        }\n        if (this._lastStickyEnd) {\n          this._lastStickyEnd.queryCellElements('header', 'table', 'footer')\n            .forEach( el => el.classList.remove('pbl-ngrid-sticky-end'));\n          this._lastStickyEnd = undefined;\n        }\n      }\n    });\n  }\n\n  updateStickyColumnStyles() {\n    if (this._isStickyPending) {\n      return;\n    }\n\n    this._isStickyPending = true;\n    Promise.resolve()\n      .then( () => {\n        this._isStickyPending = false;\n        this._updateStickyColumnStyles();\n      });\n  }\n\n  ngOnDestroy(): void {\n    super.ngOnDestroy();\n    if (this.onRenderRows$) {\n      this.onRenderRows$.complete();\n    }\n    this.virtualScrollDestroy();\n  }\n\n  //#region CSS-CLASS-CONTROL\n  addClass(cssClassName: string): void {\n    this._element.classList.add(cssClassName);\n  }\n\n  removeClass(cssClassName: string): void {\n    this._element.classList.remove(cssClassName);\n  }\n  //#endregion CSS-CLASS-CONTROL\n\n  //#region CLEAR-ROW-DEFS\n\n  // TODO: remove if https://github.com/angular/material2/pull/13000 is pushed\n  private _cachedRowDefs = { header: new Set<CdkHeaderRowDef>(), footer: new Set<CdkFooterRowDef>() }; //tslint:disable-line\n\n  // TODO: remove if https://github.com/angular/material2/pull/13000 is pushed\n  addHeaderRowDef(headerRowDef: CdkHeaderRowDef): void {\n    super.addHeaderRowDef(headerRowDef);\n    this._cachedRowDefs.header.add(headerRowDef);\n  }\n\n  // TODO: remove if https://github.com/angular/material2/pull/13000 is pushed\n  clearHeaderRowDefs(): void {\n    const { header } = this._cachedRowDefs;\n    for (const rowDef of Array.from(header.values())) {\n      this.removeHeaderRowDef(rowDef);\n    }\n    header.clear();\n  }\n\n  // TODO: remove if https://github.com/angular/material2/pull/13000 is pushed\n  addFooterRowDef(footerRowDef: CdkFooterRowDef): void {\n    super.addFooterRowDef(footerRowDef);\n    this._cachedRowDefs.footer.add(footerRowDef);\n  }\n\n  // TODO: remove if https://github.com/angular/material2/pull/13000 is pushed\n  clearFooterRowDefs(): void {\n    const { footer } = this._cachedRowDefs;\n    for (const rowDef of Array.from(footer.values())) {\n      this.removeFooterRowDef(rowDef);\n    }\n    footer.clear();\n  }\n  //#endregion CLEAR-ROW-DEFS\n\n  //#region VIRTUAL-SCROLL\n  private forOf: PblVirtualScrollForOf<T>; //tslint:disable-line\n\n  attachViewPort(): void {\n    this.detachViewPort();\n    this.forOf = new PblVirtualScrollForOf<T>(this.extApi, this.injector.get(NgZone));\n  }\n\n  detachViewPort(): void {\n    if (this.forOf) {\n      this.forOf.destroy();\n      this.forOf = undefined;\n    }\n  }\n\n  private virtualScrollDestroy(): void {\n    super.ngOnDestroy();\n    this.detachViewPort();\n  }\n  //#endregion VIRTUAL-SCROLL\n\n  /**\n   * An alias for `_cacheRowDefs()`\n   */\n  updateRowDefCache(): void {\n    (this as any)._cacheRowDefs();\n  }\n\n  renderRows(): void {\n    super.renderRows();\n\n    // The problem of inheritance right at your face\n    // Because material does not allow us to control the context generation for a row we need to get clever.\n    // https://github.com/angular/components/issues/14199\n    // TODO: If they do allow controlling context generation, remove this and apply their solution.\n    const viewContainer = this._rowOutlet.viewContainer;\n    for (let renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {\n      const viewRef = viewContainer.get(renderIndex) as EmbeddedViewRef<RowContext<T>>;\n      const context = viewRef.context;\n      context.gridInstance = this.table;\n    }\n\n    if (this.onRenderRows$) {\n      this.onRenderRows$.next(this._rowOutlet);\n    }\n  }\n\n  /**\n   * Force run change detection for rows.\n   * You can run it for specific groups or for all rows.\n   */\n  syncRows(rowType?: 'all' | boolean, detectChanges?: boolean): void;\n  syncRows(rowType: 'header' | 'data' | 'footer', detectChanges: boolean, ...rows: number[]): void;\n  syncRows(rowType: 'header' | 'data' | 'footer', ...rows: number[]): void;\n  syncRows(rowType: 'header' | 'data' | 'footer' | 'all' | boolean = false, ...rows: any[]): void {\n    const detectChanges: boolean = typeof rowType === 'boolean'\n      ? rowType\n      : typeof rows[0] === 'boolean'\n        ? rows.shift()\n        : false\n    ;\n\n    let vcRef: ViewContainerRef;\n    switch(rowType) {\n      case 'header':\n        vcRef = this._headerRowOutlet.viewContainer;\n        break;\n      case 'data':\n        vcRef = this._rowOutlet.viewContainer;\n        break;\n      case 'footer':\n        vcRef = this._footerRowOutlet.viewContainer;\n        break;\n      default: // boolean or 'all'\n        this._changeDetectorRef.markForCheck();\n        if (detectChanges) {\n          this._changeDetectorRef.detectChanges();\n        }\n        return;\n    }\n\n    const useSpecificRows = rows.length > 0;\n    const count = useSpecificRows ? rows.length : vcRef.length;\n\n    for (let renderIndex = 0; renderIndex < count; renderIndex++) {\n      const viewRef = vcRef.get(useSpecificRows ? rows[renderIndex] : renderIndex) as EmbeddedViewRef<any>;\n      if (viewRef) {\n        viewRef.markForCheck();\n        if (detectChanges) {\n          viewRef.detectChanges();\n        }\n      }\n    }\n  }\n\n  pblForceRenderDataRows(): void {\n    try{\n      (this as any)._forceRenderDataRows();\n    } catch (ex) {\n      this.multiTemplateDataRows = this.multiTemplateDataRows;\n    }\n  }\n\n  private _updateStickyColumnStyles() {\n    const columns = this.table.columnApi.visibleColumns;\n    let sticky: PblNgridColumnDef, stickyEnd: PblNgridColumnDef;\n\n    for (let i = 0, len = columns.length; i < len; i++) {\n      if (columns[i].columnDef && columns[i].columnDef.sticky) {\n        sticky = columns[i].columnDef;\n      }\n    }\n\n    for (let i = columns.length - 1; i > -1; i--) {\n      if (columns[i].columnDef && columns[i].columnDef.stickyEnd) {\n        stickyEnd = columns[i].columnDef;\n      }\n    }\n\n    if (this._lastSticky) {\n      this._lastSticky.queryCellElements('header', 'table', 'footer')\n        .forEach( el => el.classList.remove('pbl-ngrid-sticky-start'));\n    }\n\n    if (sticky) {\n      sticky.queryCellElements('header', 'table', 'footer')\n        .forEach( el => el.classList.add('pbl-ngrid-sticky-start'));\n    }\n    this._lastSticky = sticky;\n\n    if (this._lastStickyEnd) {\n      this._lastStickyEnd.queryCellElements('header', 'table', 'footer')\n        .forEach( el => el.classList.remove('pbl-ngrid-sticky-end'));\n    }\n\n    if (stickyEnd) {\n      stickyEnd.queryCellElements('header', 'table', 'footer')\n        .forEach( el => el.classList.add('pbl-ngrid-sticky-end'));\n    }\n    this._lastStickyEnd = stickyEnd;\n\n    super.updateStickyColumnStyles();\n  }\n}\n","import ResizeObserver from 'resize-observer-polyfill';\n\nimport {\n  Directive,\n  ElementRef,\n  Input,\n  AfterViewInit,\n  OnDestroy\n} from '@angular/core';\n\nimport { PblNgridComponent } from '../../table.component';\nimport { PblColumn, ColumnSizeInfo } from '../../columns/index';\n\nconst PBL_NGRID_MAP = new Map<PblNgridComponent<any>, PblNgridGroupHeaderSizeController>();\n\nclass PblNgridGroupHeaderSizeController {\n  private entries: WeakMap<any, PblColumnSizeObserver>;\n  private ro: ResizeObserver;\n  private columns: PblColumnSizeObserver[] = [];\n\n  constructor(private table: PblNgridComponent<any>) {\n    this.entries = new WeakMap<any, PblColumnSizeObserver>();\n    this.ro = new ResizeObserver( entries => {\n      requestAnimationFrame(() => this.onResize(entries) );\n    });\n  }\n\n  static get(table: PblNgridComponent<any>): PblNgridGroupHeaderSizeController {\n    let controller = PBL_NGRID_MAP.get(table);\n    if (!controller) {\n      controller = new PblNgridGroupHeaderSizeController(table);\n      PBL_NGRID_MAP.set(table, controller);\n    }\n    return controller;\n  }\n\n  add(col: PblColumnSizeObserver): void {\n    this.entries.set(col.target, col);\n    this.ro.observe(col.target);\n    this.columns.push(col);\n  }\n\n  remove(col: PblColumnSizeObserver): void {\n    this.ro.unobserve(col.target);\n    this.entries.delete(col.target);\n    const idx = this.columns.indexOf(col);\n    if (idx > -1) {\n      this.columns.splice(idx, 1);\n    }\n    if (this.columns.length === 0) {\n      this.ro.disconnect();\n      PBL_NGRID_MAP.delete(this.table);\n    }\n  }\n\n  private onResize(entries: ResizeObserverEntry[]): void {\n    const resized: PblColumnSizeObserver[] = [];\n    for (const entry of entries) {\n      const o = this.entries.get(entry.target);\n      if (o) {\n        resized.push(o);\n      }\n    }\n    if (resized.length > 0) {\n      let isDragging = false;\n      for (const c of resized) {\n        isDragging = isDragging || c.column.columnDef.isDragging;\n        c.updateSize();\n      }\n      if (!isDragging) {\n        this.table.resizeColumns(this.columns.map( c => c.column ));\n      }\n    }\n  }\n}\n\n/**\n * A directive that listen to size changes from the element of a cell, using ResizeObserver.\n * When a change occurs it will emit it to the PblTable host of this directive, along with all other observed columns for the table.\n *\n * In other words, all columns of a table, marked with `PblColumnSizeObserver`, will be sent.\n *\n * Because most of the size changes concern all columns of a row and because ResizeObserver will emit them all in the same event\n * an entire row should emit once, with all columns.\n */\n@Directive({ selector: 'pbl-ngrid-cell[observeSize], pbl-ngrid-header-cell[observeSize]' })\nexport class PblColumnSizeObserver extends ColumnSizeInfo implements AfterViewInit, OnDestroy {\n  @Input('observeSize') get column(): PblColumn { return this._column; }\n  set column(value: PblColumn) { this.attachColumn(value); }\n\n  private controller: PblNgridGroupHeaderSizeController;\n\n  constructor(el: ElementRef, table: PblNgridComponent<any>) {\n    super(el.nativeElement);\n    this.controller = PblNgridGroupHeaderSizeController.get(table);\n  }\n\n  ngAfterViewInit(): void {\n    this.controller.add(this);\n  }\n\n  ngOnDestroy() {\n    this.controller.remove(this);\n    this.detachColumn();\n  }\n}\n","import { Observable } from 'rxjs';\nimport { Directive, Input, OnInit, OnChanges, ElementRef } from '@angular/core';\n\nimport { coerceNumberProperty } from '@angular/cdk/coercion';\nimport { ListRange } from '@angular/cdk/collections';\nimport { CdkVirtualScrollViewport, FixedSizeVirtualScrollStrategy, VirtualScrollStrategy, VIRTUAL_SCROLL_STRATEGY } from '@angular/cdk/scrolling';\nimport { AutoSizeVirtualScrollStrategy, ItemSizeAverager } from '@angular/cdk-experimental/scrolling';\n\nimport { PblNgridComponent } from '../../table.component';\nimport { NgeVirtualTableRowInfo } from './virtual-scroll-for-of';\nimport { P } from '@angular/cdk/keycodes';\n\nconst noop = function(nv?: any, nv1?: any) { };\n\nexport class NoVirtualScrollStrategy implements VirtualScrollStrategy {\n  scrolledIndexChange: any;\n  attach: (viewport: CdkVirtualScrollViewport) => void = noop;\n  detach: () => void = noop;\n  onContentScrolled: () => void = noop;\n  onDataLengthChanged: () => void = noop;\n  onContentRendered: () => void = noop;\n  onRenderedOffsetChanged: () => void = noop;\n  scrollToIndex: (index: number, behavior: ScrollBehavior) => void = noop;\n}\n\nexport class TableItemSizeAverager extends ItemSizeAverager {\n  private rowInfo: NgeVirtualTableRowInfo;\n\n  addSample(range: ListRange, size: number) {\n    if (this.rowInfo && this.rowInfo.rowLength === 0) {\n      this.reset();\n    } else {\n      super.addSample(range, size);\n    }\n  }\n\n  /**\n   * A temp workaround to solve the actual vs wanted rendered row issue in `CdkVirtualScrollViewport`\n   *\n   * `CdkVirtualScrollViewport.getRenderedRange()` return the rows that the virtual container want's the table to render\n   * however, the actual rendered rows might be different. This is a problem especially in init, when the rendered rows are actually 0\n   * but `CdkVirtualScrollViewport.getRenderedRange()` return the initial range of rows that should be rendered. This results in a wrong\n   * calculation of the average item size in `ItemSizeAverager`\n   *\n   * SEE: https://github.com/angular/material2/blob/a9e550e5bf93cd68c342d1a50d8576d8f3812ebe/src/cdk/scrolling/virtual-scroll-viewport.ts#L212-L220\n   */\n  setRowInfo(rowInfo: NgeVirtualTableRowInfo): void {\n    this.rowInfo = rowInfo;\n  }\n}\n\nexport class PblNgridFixedSizeVirtualScrollStrategy extends FixedSizeVirtualScrollStrategy {\n\n  private _ngridViewport: CdkVirtualScrollViewport;\n\n  constructor(private itemSize: number, minBufferPx: number, maxBufferPx: number) {\n    super(itemSize, minBufferPx, maxBufferPx);\n  }\n\n  attach(viewport: CdkVirtualScrollViewport) {\n    super.attach(this._ngridViewport = viewport);\n  }\n\n  onContentScrolled() {\n    // https://github.com/shlomiassaf/ngrid/issues/11\n\n    // This is a workaround an issue with FixedSizeVirtualScrollStrategy\n    // When:\n    //    - The rendered data is changed so the data length is now LOWER then the current range (end - start)\n    //    - The rendering direction is towards the top (start > end)\n    //\n    // For the issue to occur a big gap between the data length and the range length (gap), which does not happen on normal scrolling\n    // but only when the data source is replaced (e.g. filtering).\n    //\n    // In such cases `onDataLengthChanged` is called which will call `_updateRenderedRange` which will calculate a new range\n    // that is big, it will give the `start` a new value which creates the big gap.\n    // It will then calculate a new \"end\" and leave the \"start\" so we have a big gap, larger then the viewport size.\n    // After that it will create the new offset which is the itemSize * start, which is a bit lower then the offset but is large and again does not fit the viewport size\n    // The scroll change will trigger `onContentScrolled` which will call `_updateRenderedRange` again,\n    // with the same outcome, reducing the offset slightly, calling `onContentScrolled` again.\n    // It will repeat until reaching the proper offset.\n    //\n    // The amount of offset reduced each time is approx the size of the buffers. (mix/max Buffer).\n    //\n    // This strategy is here only because of this error, it will let the initial update run and catch it's subsequent scroll event.\n    if (!this._ngridViewport) {\n      return;\n    }\n    let { start, end } = this._ngridViewport.getRenderedRange();\n    const rangeLength = end - start;\n    const dataLength = this._ngridViewport.getDataLength();\n    if (rangeLength < 0 && dataLength < -rangeLength) {\n      start = dataLength - end;\n      this._ngridViewport.setRenderedRange({ start, end });\n      this._ngridViewport.setRenderedContentOffset(this.itemSize * start);\n      // this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));\n    } else {\n      super.onContentScrolled();\n    }\n  }\n}\n\nexport class TableAutoSizeVirtualScrollStrategy extends AutoSizeVirtualScrollStrategy {\n  constructor(minBufferPx: number, maxBufferPx: number, public readonly averager = new TableItemSizeAverager()) {\n    super(minBufferPx, maxBufferPx, averager);\n  }\n}\n\nconst TYPES: Array<'vScrollFixed' | 'vScrollAuto' | 'vScrollNone'> = ['vScrollAuto', 'vScrollFixed', 'vScrollNone'];\n\nexport function _vScrollStrategyFactory(directive: { _scrollStrategy: VirtualScrollStrategy; }) {\n  return directive._scrollStrategy;\n}\n\n/** A virtual scroll strategy that supports unknown or dynamic size items. */\n@Directive({\n  selector: 'pbl-ngrid[vScrollAuto], pbl-ngrid[vScrollFixed], pbl-ngrid[vScrollNone]',\n  providers: [{\n    provide: VIRTUAL_SCROLL_STRATEGY,\n    useExisting: PblCdkVirtualScrollDirective,\n  }],\n})\nexport class PblCdkVirtualScrollDirective implements OnInit, OnChanges, VirtualScrollStrategy {\n    /**\n   * The size of the items in the list (in pixels).\n   * Valid for `vScrollFixed` only!\n   *\n   * Default: 20\n   */\n  @Input() get vScrollAuto(): number { return this._vScrollAuto; }\n  set vScrollAuto(value: number) { this._vScrollAuto = coerceNumberProperty(value); }\n  _vScrollAuto: number;\n\n  /**\n   * The size of the items in the list (in pixels).\n   * Valid for `vScrollFixed` only!\n   *\n   * Default: 20\n   */\n  @Input() get vScrollFixed(): number { return this._vScrollFixed; }\n  set vScrollFixed(value: number) { this._vScrollFixed = value; }\n  _vScrollFixed: number;\n\n  /**\n   * The minimum amount of buffer rendered beyond the viewport (in pixels).\n   * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n   *\n   * Valid for `vScrollAuto` and `vScrollFixed` only!\n   * Default: 100\n   */\n  @Input() get minBufferPx(): number { return this._minBufferPx; }\n  set minBufferPx(value: number) { this._minBufferPx = coerceNumberProperty(value); }\n  _minBufferPx = 100;\n\n  /**\n   * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.\n   *\n   * Valid for `vScrollAuto` and `vScrollFixed` only!\n   * Default: 100\n   */\n  @Input() get maxBufferPx(): number { return this._maxBufferPx; }\n  set maxBufferPx(value: number) { this._maxBufferPx = coerceNumberProperty(value); }\n  _maxBufferPx = 200;\n\n  @Input() get wheelMode(): 'passive' | 'blocking' | number { return this._wheelMode; }\n  set wheelMode(value: 'passive' | 'blocking' | number) {\n    switch (value) {\n      case 'passive':\n      case 'blocking':\n       this._wheelMode = value;\n       break;\n      default:\n        const wheelMode = coerceNumberProperty(value);\n        if (wheelMode && wheelMode >= 1 && wheelMode <= 60) {\n          this._wheelMode = wheelMode;\n        }\n        break;\n    }\n  }\n  _wheelMode: 'passive' | 'blocking' | number;\n\n  /** The scroll strategy used by this directive. */\n  _scrollStrategy: VirtualScrollStrategy;\n\n  get type(): 'vScrollFixed' | 'vScrollAuto' | 'vScrollNone' { return this._type; };\n  private _type: 'vScrollFixed' | 'vScrollAuto' | 'vScrollNone';\n\n  constructor(el: ElementRef<HTMLElement>, private table: PblNgridComponent<any>) {\n    const types = TYPES.filter( t => el.nativeElement.hasAttribute(t));\n\n    if (types.length > 1) {\n      throw new Error(`Invalid vScroll instruction, only one value is allow: ${JSON.stringify(types)}`);\n    } else {\n      this._type = types[0];\n    }\n  }\n\n  ngOnInit(): void {\n    if (!this._type) {\n      if ('_vScrollFixed' in <any>this) {\n        this._type = 'vScrollFixed';\n      } else if ('_vScrollAuto' in <any>this) {\n        this._type = 'vScrollAuto';\n      } else {\n        this._type = 'vScrollNone';\n      }\n    }\n    switch (this.type) {\n      case 'vScrollFixed':\n        if (!this._vScrollFixed) {\n          this.vScrollFixed  = this.table.findInitialRowHeight() || 48;\n        }\n        this._scrollStrategy = new PblNgridFixedSizeVirtualScrollStrategy(this.vScrollFixed, this.minBufferPx, this.maxBufferPx);\n        break;\n      case 'vScrollAuto':\n        if (!this._vScrollAuto) {\n          this._vScrollAuto  = this.table.findInitialRowHeight() || 48;\n        }\n        this._scrollStrategy = new TableAutoSizeVirtualScrollStrategy(this.minBufferPx, this.maxBufferPx, new TableItemSizeAverager(this._vScrollAuto));\n        break;\n      default:\n        this._scrollStrategy = new NoVirtualScrollStrategy();\n        break;\n    }\n  }\n\n  ngOnChanges() {\n    if (this._scrollStrategy) {\n      switch (this.type) {\n        case 'vScrollFixed':\n          (this._scrollStrategy as PblNgridFixedSizeVirtualScrollStrategy)\n            .updateItemAndBufferSize(this.vScrollFixed, this.minBufferPx, this.maxBufferPx);\n          break;\n        case 'vScrollAuto':\n          (this._scrollStrategy as TableAutoSizeVirtualScrollStrategy)\n            .updateBufferSize(this.minBufferPx, this.maxBufferPx);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  get scrolledIndexChange(): Observable<number> { return this._scrollStrategy.scrolledIndexChange; }\n  set scrolledIndexChange(value: Observable<number>) { this._scrollStrategy.scrolledIndexChange = value; }\n  attach(viewport: CdkVirtualScrollViewport): void { this._scrollStrategy.attach(viewport); }\n  detach(): void { this._scrollStrategy.detach(); }\n  onContentScrolled(): void { this._scrollStrategy.onContentScrolled(); }\n  onDataLengthChanged(): void { this._scrollStrategy.onDataLengthChanged(); }\n  onContentRendered(): void { this._scrollStrategy.onContentRendered(); }\n  onRenderedOffsetChanged(): void { this._scrollStrategy.onRenderedOffsetChanged(); }\n  scrollToIndex(index: number, behavior: ScrollBehavior): void { this._scrollStrategy.scrollToIndex(index, behavior); }\n}\n","import { Observable, Subject } from 'rxjs';\n\nimport {\n  AfterViewInit,\n  Component,\n  ChangeDetectionStrategy,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  Input,\n  ChangeDetectorRef,\n  ViewEncapsulation,\n  NgZone,\n  Output,\n  Optional,\n  OnInit,\n  OnDestroy,\n} from '@angular/core';\n\nimport { Directionality } from '@angular/cdk/bidi';\nimport {\n  CdkVirtualScrollViewport,\n  VIRTUAL_SCROLL_STRATEGY,\n  VirtualScrollStrategy,\n  ScrollDispatcher,\n  CdkVirtualForOf,\n  CdkScrollable,\n} from '@angular/cdk/scrolling';\n\nimport { UnRx } from '@pebula/utils';\n\nimport { PblNgridPluginController } from '../../../ext/plugin-control';\nimport { PblNgridConfigService } from '../../services/config';\nimport { PblNgridComponent } from '../../table.component';\nimport { PblCdkVirtualScrollDirective, NoVirtualScrollStrategy, TableAutoSizeVirtualScrollStrategy } from './strategies';\nimport { NgeVirtualTableRowInfo } from './virtual-scroll-for-of';\n\ndeclare module '../../services/config' {\n  interface PblNgridConfig {\n    virtualScroll?: {\n      wheelMode?: PblCdkVirtualScrollDirective['wheelMode'];\n      defaultStrategy?(): VirtualScrollStrategy;\n    }\n  }\n}\n\nfunction resolveScrollStrategy(config: PblNgridConfigService, scrollStrategy?: VirtualScrollStrategy): VirtualScrollStrategy {\n  if (!scrollStrategy && config.has('virtualScroll')) {\n    const virtualScrollConfig = config.get('virtualScroll');\n    if (typeof virtualScrollConfig.defaultStrategy === 'function') {\n      scrollStrategy = virtualScrollConfig.defaultStrategy();\n    }\n  }\n\n  return scrollStrategy || new TableAutoSizeVirtualScrollStrategy(100, 200);\n}\n\n@Component({\n  selector: 'pbl-cdk-virtual-scroll-viewport',\n  templateUrl: 'virtual-scroll-viewport.component.html',\n  styleUrls: [ './virtual-scroll-viewport.component.scss' ],\n  host: { // tslint:disable-line:use-host-property-decorator\n    class: 'cdk-virtual-scroll-viewport',\n    '[class.cdk-virtual-scroll-disabled]': '!enabled',\n    '[class.cdk-virtual-scroll-orientation-horizontal]': 'orientation === \"horizontal\"',\n    '[class.cdk-virtual-scroll-orientation-vertical]': 'orientation === \"vertical\"'\n  },\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\n@UnRx()\nexport class PblCdkVirtualScrollViewportComponent extends CdkVirtualScrollViewport implements OnInit, AfterViewInit, OnDestroy {\n\n  get isScrolling(): boolean { return this._isScrolling; }\n  readonly enabled: boolean;\n\n  /**\n   * Emits the offset (in pixels) of the rendered content every time it changes.\n   * The emission is done OUTSIDE of angular (i.e. no change detection cycle is triggered).\n   *\n   * Note that when not enabled (i.e `NoVirtualScrollStrategy` is used) there are no emissions.\n   */\n  readonly offsetChange: Observable<number>;\n\n  @Input() minWidth: number;\n\n  @Input() stickyRowHeaderContainer: HTMLElement;\n  @Input() stickyRowFooterContainer: HTMLElement;\n\n  /**\n   * Event emitted when the scrolling state of rows in the table changes.\n   * When scrolling starts `true` is emitted and when the scrolling ends `false` is emitted.\n   *\n   * The table is in \"scrolling\" state from the first scroll event and until 2 animation frames\n   * have passed without a scroll event.\n   *\n   * When scrolling, the emitted value is the direction: -1 or 1\n   * When not scrolling, the emitted value is 0.\n   *\n   * NOTE: This event runs outside the angular zone.\n   */\n  @Output() scrolling = new EventEmitter< -1 | 0 | 1 >();\n\n  /**\n   * Emits an estimation of the current frame rate while scrolling, in a 500ms interval.\n   *\n   * The frame rate value is the average frame rate from all measurements since the scrolling began.\n   * To estimate the frame rate, a significant number of measurements is required so value is emitted every 500 ms.\n   * This means that a single scroll or short scroll bursts will not result in a `scrollFrameRate` emissions.\n   *\n   * Valid on when virtual scrolling is enabled.\n   *\n   * NOTE: This event runs outside the angular zone.\n   *\n   * In the future the measurement logic might be replaced with the Frame Timing API\n   * See:\n   * - https://developers.google.com/web/updates/2014/11/frame-timing-api\n   * - https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver\n   * - https://github.com/googlearchive/frame-timing-polyfill/wiki/Explainer\n   */\n  @Output() scrollFrameRate = new EventEmitter<number>();\n\n  /**\n   * The `scrollHeight` of the virtual scroll viewport.\n   * The `scrollHeight` is updated by the virtual scroll (update logic and frequency depends on the strategy implementation) through\n   * the `setTotalContentSize(size)` method. The input size is used to position a dummy spacer element at a position that mimics the `scrollHeight`.\n   *\n   * In theory, the size sent to `setTotalContentSize` should equal the `scrollHeight` value, once the browser update's the layout.\n   * In reality it does not happen, sometimes they are not equal. Setting a size will result in a different `scrollHeight`.\n   * This might be due to changes in measurements when handling sticky meta rows (moving back and forth)\n   *\n   * Because the position of the dummy spacer element is set through DI the layout will run in the next micro-task after the call to `setTotalContentSize`.\n   */\n  scrollHeight = 0;\n\n  ngeRenderedContentSize = 0;\n  pblFillerHeight: string;\n\n  get wheelMode(): PblCdkVirtualScrollDirective['wheelMode'] {\n    return (this.pblScrollStrategy as PblCdkVirtualScrollDirective).wheelMode || this.wheelModeDefault || 'passive';\n  }\n\n  get innerWidth(): number {\n    const innerWidthHelper = this.elementRef.nativeElement.querySelector('.cdk-virtual-scroll-inner-width') as HTMLElement;\n    return innerWidthHelper.getBoundingClientRect().width;\n  }\n\n  get outerWidth(): number {\n    return this.elementRef.nativeElement.getBoundingClientRect().width;\n  }\n\n  get innerHeight(): number {\n    const innerWidthHelper = this.elementRef.nativeElement.querySelector('.cdk-virtual-scroll-inner-width') as HTMLElement;\n    return innerWidthHelper.getBoundingClientRect().height;\n  }\n\n  get outerHeight(): number {\n    return this.elementRef.nativeElement.getBoundingClientRect().height;\n  }\n\n  /// TODO(shlomiassaf): Remove when not supporting 8.1.2 and below\n  /// COMPATIBILITY 8.1.2- <-> 8.1.3+\n    /** A string representing the `style.width` property value to be used for the spacer element. */\n    _totalContentWidth = '';\n    /** A string representing the `style.height` property value to be used for the spacer element. */\n   _totalContentHeight = '';\n    /**\n   * The transform used to scale the spacer to the same size as all content, including content that\n   * is not currently rendered.\n   * @deprecated\n   */\n  _totalContentSizeTransform = '';\n /// COMPATIBILITY 8.1.2- <-> 8.1.3+\n\n  private offsetChange$ = new Subject<number>();\n  private offset: number;\n  private isCDPending: boolean;\n  private _isScrolling = false;\n\n  private wheelModeDefault:  PblCdkVirtualScrollDirective['wheelMode'];\n\n  constructor(elementRef: ElementRef<HTMLElement>,\n              private cdr: ChangeDetectorRef,\n              ngZone: NgZone,\n              config: PblNgridConfigService,\n              @Optional() @Inject(VIRTUAL_SCROLL_STRATEGY) public pblScrollStrategy: VirtualScrollStrategy,\n              @Optional() dir: Directionality,\n              scrollDispatcher: ScrollDispatcher,\n              pluginCtrl: PblNgridPluginController,\n              private table: PblNgridComponent<any>) {\n    super(elementRef,\n          cdr,\n          ngZone,\n          pblScrollStrategy = resolveScrollStrategy(config, pblScrollStrategy),\n          dir,\n          scrollDispatcher);\n\n    if (config.has('virtualScroll')) {\n      this.wheelModeDefault = config.get('virtualScroll').wheelMode;\n    }\n    config.onUpdate('virtualScroll').pipe(UnRx(this)).subscribe( change => this.wheelModeDefault = change.curr.wheelMode);\n\n    if (pblScrollStrategy instanceof PblCdkVirtualScrollDirective) {\n      this.enabled = pblScrollStrategy.type !== 'vScrollNone';\n    } else {\n      this.enabled = !(pblScrollStrategy instanceof NoVirtualScrollStrategy);\n    }\n    pluginCtrl.extApi.setViewport(this);\n    this.offsetChange = this.offsetChange$.asObservable();\n  }\n\n  ngOnInit(): void {\n    if (this.enabled) {\n      super.ngOnInit();\n    } else {\n      CdkScrollable.prototype.ngOnInit.call(this);\n    }\n    this.ngZone.runOutsideAngular( () => this.initScrollWatcher() );\n  }\n\n  ngAfterViewInit(): void {\n    // If virtual scroll is disabled (`NoVirtualScrollStrategy`) we need to disable any effect applied\n    // by the viewport, wrapping the content injected to it.\n    // The main effect is the table having height 0 at all times, unless the height is explicitly set.\n    // This happens because the content taking out of the layout, wrapped in absolute positioning.\n    // Additionally, the host itself (viewport) is set to contain: strict.\n    const { table } = this;\n    if (this.enabled) {\n      table._cdkTable.attachViewPort();\n    }\n\n    this.scrolling\n      .pipe(UnRx(this))\n      .subscribe( isScrolling => {\n        this._isScrolling = !!isScrolling;\n        if (isScrolling) {\n          table.addClass('pbl-ngrid-scrolling');\n        } else {\n          table.removeClass('pbl-ngrid-scrolling');\n        }\n      });\n  }\n\n  ngOnDestroy(): void {\n    super.ngOnDestroy();\n    this.offsetChange$.complete();\n  }\n\n  setTotalContentSize(size: number) {\n    super.setTotalContentSize(size);\n\n    // TODO(shlomiassaf)[perf, 3]: run this once... (aggregate all calls within the same animation frame)\n    requestAnimationFrame(() => {\n      this.scrollHeight = this.elementRef.nativeElement.scrollHeight; //size;\n      this.updateFiller();\n      // We must trigger a change detection cycle because the filler div element is updated through bindings\n      this.cdr.detectChanges();\n    })\n  }\n\n  checkViewportSize() {\n    // TODO: Check for changes in `CdkVirtualScrollViewport` source code, when resizing is handled!\n    // see https://github.com/angular/material2/blob/28fb3abe77c5336e4739c820584ec99c23f1ae38/src/cdk/scrolling/virtual-scroll-viewport.ts#L341\n    const prev = this.getViewportSize();\n    super.checkViewportSize();\n    if (prev !== this.getViewportSize()) {\n      this.updateFiller();\n    }\n  }\n\n  /** Measure the combined size of all of the rendered items. */\n  measureRenderedContentSize(): number {\n    let size = super.measureRenderedContentSize();\n    if (this.orientation === 'vertical') {\n      size -= this.stickyRowHeaderContainer.offsetHeight + this.stickyRowFooterContainer.offsetHeight;\n\n      // Compensate for hz scroll bar, if exists, only in non virtual scroll mode.\n      if (!this.enabled) {\n        size += this.outerHeight - this.innerHeight;\n      }\n    }\n    return this.ngeRenderedContentSize = size;\n  }\n\n  private updateFiller(): void {\n    this.measureRenderedContentSize();\n    if (this.table.noFiller) {\n      this.pblFillerHeight = undefined;\n    } else {\n      this.pblFillerHeight = this.getViewportSize() >= this.ngeRenderedContentSize ?\n        `calc(100% - ${this.ngeRenderedContentSize}px)`\n        : undefined\n      ;\n    }\n  }\n\n  onSourceLengthChange(prev: number, curr: number): void {\n    this.checkViewportSize();\n    this.updateFiller();\n  }\n\n  attach(forOf: CdkVirtualForOf<any> & NgeVirtualTableRowInfo) {\n    super.attach(forOf);\n    const scrollStrategy = this.pblScrollStrategy instanceof PblCdkVirtualScrollDirective\n      ? this.pblScrollStrategy._scrollStrategy\n      : this.pblScrollStrategy\n    ;\n    if (scrollStrategy instanceof TableAutoSizeVirtualScrollStrategy) {\n      scrollStrategy.averager.setRowInfo(forOf);\n    }\n  }\n\n  setRenderedContentOffset(offset: number, to: 'to-start' | 'to-end' = 'to-start') {\n    super.setRenderedContentOffset(offset, to);\n    if (this.enabled) {\n      if (this.offset !== offset) {\n        this.offset = offset;\n        if (!this.isCDPending) {\n          this.isCDPending = true;\n\n          const syncTransform = () => { };\n\n          this.ngZone.runOutsideAngular(() => Promise.resolve()\n            .then( () => syncTransform() )\n            .then( () => {\n              this.isCDPending = false;\n              this.offsetChange$.next(this.offset);\n            })\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Init the scrolling watcher which track scroll events an emits `scrolling` and `scrollFrameRate` events.\n   */\n  private initScrollWatcher(): void {\n    let scrolling = 0;\n    let lastOffset = this.measureScrollOffset();\n    this.elementScrolled()\n      .subscribe(() => {\n        /*  `scrolling` is a boolean flag that turns on with the first `scroll` events and ends after 2 browser animation frames have passed without a `scroll` event.\n            This is an attempt to detect a scroll end event, which does not exist.\n\n            `scrollFrameRate` is a number that represent a rough estimation of the frame rate by measuring the time passed between each request animation frame\n            while the `scrolling` state is true. The frame rate value is the average frame rate from all measurements since the scrolling began.\n            To estimate the frame rate, a significant number of measurements is required so value is emitted every 500 ms.\n            This means that a single scroll or short scroll bursts will not result in a `scrollFrameRate` emissions.\n\n        */\n        if (scrolling === 0) {\n          /*  The measure array holds values required for frame rate measurements.\n              [0] Storage for last timestamp taken\n              [1] The sum of all measurements taken (a measurement is the time between 2 snapshots)\n              [2] The count of all measurements\n              [3] The sum of all measurements taken WITHIN the current buffer window. This buffer is flushed into [1] every X ms (see buggerWindow const).\n          */\n          const bufferWindow = 499;\n          const measure = [ performance.now(), 0, 0, 0 ];\n          const offset = this.measureScrollOffset();\n          if (lastOffset === offset) { return; }\n          const delta = lastOffset < offset ? 1 : -1;\n\n          this.scrolling.next(delta);\n\n          const raf = () => {\n            const time = -measure[0] + (measure[0] = performance.now());\n            if (time > 5) {\n              measure[1] += time;\n              measure[2] += 1;\n            }\n            if (scrolling === -1) {\n              scrolling = 0;\n              lastOffset = this.measureScrollOffset();\n              this.scrolling.next(0);\n            }\n            else {\n              if (measure[1] > bufferWindow) {\n                measure[3] += measure[1];\n                measure[1] = 0;\n                this.scrollFrameRate.emit(1000 / (measure[3]/measure[2]));\n              }\n              scrolling = scrolling === 1 ? -1 : 1;\n              requestAnimationFrame(raf);\n            }\n          };\n          requestAnimationFrame(raf);\n        }\n        scrolling++;\n      });\n  }\n}\n\ndeclare global {\n  interface CSSStyleDeclaration {\n    contain: 'none' | 'strict' | 'content' | 'size' | 'layout' | 'style' | 'paint' | 'inherit' | 'initial' | 'unset';\n  }\n}\n","import { Directive, EventEmitter, Output, NgZone } from '@angular/core';\nimport { PblNgridPluginController } from '../../../ext/plugin-control';\nimport { PblNgridComponent } from '../../table.component';\n\n@Directive({\n  selector: 'pbl-ngrid[scrolling]'\n})\nexport class PblNgridScrolling<T = any> {\n\n  /**\n   * Event emitted when the scrolling state of rows in the table changes.\n   * When scrolling starts `true` is emitted and when the scrolling ends `false` is emitted.\n   *\n   * The table is in \"scrolling\" state from the first scroll event and until 2 animation frames\n   * have passed without a scroll event.\n   *\n   * When scrolling, the emitted value is the direction: -1 or 1\n   * When not scrolling, the emitted value is 0.\n   *\n   * NOTE: This event runs outside the angular zone.\n   */\n  @Output() scrolling = new EventEmitter< -1 | 0 | 1 >();\n\n  constructor(table: PblNgridComponent<T>, pluginCtrl: PblNgridPluginController, zone: NgZone) {\n    let subscription = pluginCtrl.events.subscribe( event => {\n      if (event.kind === 'onInit') {\n        const { viewport } = table;\n        if (viewport) {\n          viewport.scrolling.subscribe( isScrolling => zone.run( () => this.scrolling.next(isScrolling) ) );\n        }\n        subscription.unsubscribe();\n        subscription = undefined;\n      }\n    });\n  }\n}\n","import { ANALYZE_FOR_ENTRY_COMPONENTS, ComponentRef, Inject, InjectionToken, Injector, Type, Optional, NgModule, NgModuleRef, ModuleWithProviders, Self } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { ScrollingModule as ScrollingModuleExp } from '@angular/cdk-experimental/scrolling';\nimport { ScrollingModule } from '@angular/cdk/scrolling';\nimport { CdkTableModule } from '@angular/cdk/table';\n\nimport {\n  PEB_NGRID_CONFIG, PblNgridConfig,\n  PblNgridRegistryService,\n  PblCdkTableComponent,\n  PblNgridComponent,\n\n  PblNgridRowComponent,\n  PblNgridMetaRowContainerComponent, PblMetaRowDirective,\n  PblNgridColumnDef,\n  PblNgridHeaderCellDefDirective,\n  PblNgridFooterCellDefDirective,\n  PblNgridCellDefDirective, PblNgridEditorCellDefDirective,\n  PblNgridHeaderCellComponent,\n  PblNgridCellDirective,\n  PblNgridFooterCellDirective,\n\n  PblNgridCellStyling,\n  PblNgridOuterSectionDirective,\n  PblNgridHeaderExtensionRefDirective,\n  PblNgridNoDataRefDirective,\n  PblNgridPaginatorRefDirective,\n\n  PblColumnSizeObserver,\n  PblCdkVirtualScrollViewportComponent, PblCdkVirtualScrollDirective, PblNgridScrolling,\n\n  PblNgridCellEditAutoFocusDirective,\n\n  PblNgridConfigService,\n} from './table/index';\n\nexport const COMMON_TABLE_TEMPLATE_INIT = new InjectionToken('COMMON TABLE TEMPLATE INIT');\n\nexport interface CommonTemplateInit {\n  component: Type<any>;\n  /**\n   * When true will use the root registry service (for templates).\n   * Otherwise, uses the provided registry from the dependency tree.\n   */\n  root?: boolean;\n}\n\nexport function provideCommon(components: CommonTemplateInit[]): any {\n  return [\n    { provide: ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: components },\n    { provide: COMMON_TABLE_TEMPLATE_INIT, multi: true, useValue: components },\n  ];\n}\n\n@NgModule({\n  imports: [\n    CommonModule,\n    ScrollingModule, ScrollingModuleExp,\n    CdkTableModule,\n  ],\n  declarations: [\n    PblNgridMetaRowContainerComponent, PblMetaRowDirective,\n    PblCdkTableComponent,\n    PblNgridColumnDef,\n    PblNgridRowComponent,\n    PblNgridCellStyling,\n    PblNgridOuterSectionDirective,\n    PblNgridHeaderExtensionRefDirective,\n    PblNgridNoDataRefDirective,\n    PblNgridPaginatorRefDirective,\n    PblNgridHeaderCellDefDirective,\n    PblNgridFooterCellDefDirective,\n    PblNgridCellDefDirective, PblNgridEditorCellDefDirective,\n    PblNgridHeaderCellComponent,\n    PblNgridCellDirective,\n    PblNgridFooterCellDirective,\n\n    PblColumnSizeObserver,\n    PblCdkVirtualScrollViewportComponent, PblCdkVirtualScrollDirective, PblNgridScrolling,\n\n    PblNgridCellEditAutoFocusDirective,\n\n    PblNgridComponent,\n  ],\n  exports: [\n    PblNgridRowComponent,\n    PblNgridCellStyling,\n    PblNgridOuterSectionDirective,\n    PblNgridHeaderExtensionRefDirective,\n    PblNgridNoDataRefDirective,\n    PblNgridPaginatorRefDirective,\n    PblNgridHeaderCellDefDirective,\n    PblNgridFooterCellDefDirective,\n    PblNgridCellDefDirective, PblNgridEditorCellDefDirective, PblNgridScrolling,\n    PblNgridHeaderCellComponent,\n    PblNgridCellDirective,\n    PblNgridFooterCellDirective,\n\n    PblColumnSizeObserver,\n    PblCdkVirtualScrollDirective,\n\n    PblNgridCellEditAutoFocusDirective,\n\n    PblNgridComponent,\n  ],\n})\nexport class PblNgridModule {\n\n  constructor(ngRef: NgModuleRef<any>,\n              registry: PblNgridRegistryService,\n              @Inject(COMMON_TABLE_TEMPLATE_INIT) @Optional() @Self() components: CommonTemplateInit[][]) {\n    if (components) {\n      for (const multi of components) {\n        for (const c of multi) {\n          if (c.root) {\n            registry = registry.getRoot();\n          }\n          PblNgridModule.loadCommonTemplates(ngRef, c.component, { registry, destroy: true });\n        }\n      }\n    }\n  }\n\n  static forRoot(config: PblNgridConfig, components: CommonTemplateInit[]): ModuleWithProviders {\n    return {\n      ngModule: PblNgridModule,\n      providers: [\n        { provide: PEB_NGRID_CONFIG, useValue: config },\n        PblNgridConfigService,\n        provideCommon(components),\n      ]\n    };\n  }\n\n  static withCommon(components: CommonTemplateInit[]): ModuleWithProviders {\n    return {\n      ngModule: PblNgridModule,\n      providers: provideCommon(components),\n    };\n  }\n\n  static loadCommonTemplates<T>(ngRef: NgModuleRef<any>,\n                                component: Type<T>,\n                                options?: {\n                                  /** When set will use it as first registry in the DI tree */\n                                  registry?: PblNgridRegistryService;\n                                  /** When set will destroy the component when the module is destroyed. */\n                                  destroy?: boolean;\n                                }): ComponentRef<T> {\n    let { injector } = ngRef;\n    const { registry, destroy } = options || ({} as any);\n\n    if (registry) {\n      injector = Injector.create({\n        providers: [ { provide: PblNgridRegistryService, useValue: registry.getRoot() } ],\n        parent: ngRef.injector\n      });\n    }\n\n    const cmpRef = ngRef.componentFactoryResolver.resolveComponentFactory<T>(component).create(injector);\n    cmpRef.changeDetectorRef.detectChanges();\n\n    if (destroy) {\n      ngRef.onDestroy( () => {\n        try {\n          cmpRef.destroy();\n        } catch( err) {}\n      });\n    }\n\n    return cmpRef;\n  }\n}\n","import { isPblColumn, isPblMetaColumn, isPblColumnGroup } from './lib/table/index';\n\nexport {\n  PblNgridPaginatorKind,\n  PblPaginator,\n  PblPagingPaginator,\n  PblTokenPaginator,\n  PblPaginatorChangeEvent\n} from './lib/paginator/index';\n\nexport {\n  PblDataSourceConfigurableTriggers,\n  PblDataSourceTriggers,\n  PblDataSourceTriggerChange,\n  PblDataSourceTriggerChangedEvent,\n  PblDataSourceAdapter,\n  PblDataSource, PblDataSourceOptions,\n  PblNgridSortInstructions, PblNgridSortDefinition, PblNgridSorter, applySort, PblNgridSortOrder,\n  PblDataSourceFactory, createDS, DataSourceOf,\n  DataSourceFilterToken, DataSourcePredicate, DataSourceColumnPredicate,\n  PblDataSourceAdapterProcessedResult,\n} from './lib/data-source/index';\n\nexport {\n  PEB_NGRID_CONFIG, PblNgridConfig, PblNgridConfigService,\n\n  PblColumn, PblMetaColumn, PblColumnGroup, PblColumnFactory, COLUMN, columnFactory,\n\n  PBL_NGRID_ROW_TEMPLATE, PblNgridRowComponent,\n\n  PblNgridComponent,\n  PblNgridRegistryService,\n  AutoSizeToFitOptions, ColumnApi,\n\n  PblNgridSingleTemplateRegistry, PblNgridMultiTemplateRegistry, PblNgridMultiComponentRegistry,\n  PblNgridDataHeaderExtensionRef, PblNgridDataHeaderExtensionContext,\n  PblNgridCellDefDirective,\n  PblNgridHeaderCellDefDirective,\n  PblNgridFooterCellDefDirective,\n  PblNgridCellStyling,\n  PblNgridNoDataRefDirective,\n  PblColumnTypeDefinition, PblColumnTypeDefinitionDataMap,\n  PblColumnDefinition,\n  PblMetaColumnDefinition,\n  PblColumnGroupDefinition,\n  PblColumnSet, PblMetaRowDefinitions,\n  PblNgridColumnSet, PblNgridColumnDefinitionSet,\n\n  NoVirtualScrollStrategy, TableAutoSizeVirtualScrollStrategy,\n\n  PblNgridFocusChangedEvent, PblNgridSelectionChangedEvent,\n  PblNgridMetaCellContext, PblNgridCellContext, PblNgridRowContext, PblRowContext, PblNgridContextApi,\n  CellReference, GridDataPoint,\n} from './lib/table/index';\n\nexport {\n  PblNgridPlugin,\n  PblNgridPluginExtension,\n  PblNgridOnInitEvent,\n  PblNgridOnResizeRowEvent,\n  PblNgridOnInvalidateHeadersEvent,\n  PblNgridOnDataSourceEvent,\n  PblNgridEvents,\n } from './lib/ext/types';\n\nexport { EXT_API_TOKEN, PblNgridExtensionApi } from './lib/ext/table-ext-api';\nexport { TablePlugin, TablePluginMetadata } from './lib/ext/table-plugin';\nexport { PblNgridPluginController } from './lib/ext/plugin-control';\n\nexport const utils = {\n  isPblColumn,\n  isPblMetaColumn,\n  isPblColumnGroup,\n};\n\nexport { PblNgridModule, provideCommon } from './lib/table.module';\n"]}