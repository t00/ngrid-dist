import { take } from 'rxjs/operators';
import { PblDataSource } from '@pebula/ngrid';
import { INFINITE_SCROLL_DEFFERED_ROW } from './infinite-scroll-deffered-row';
export class PblInfiniteScrollDataSource extends PblDataSource {
    constructor(context, options) {
        super(context.getAdapter(), options);
        this.context = context;
    }
    get maxCacheSize() { return this.context.cache.maxSize; }
    get cacheSize() { return this.context.cache.size; }
    setCacheSize(maxSize) {
        this.context.cache.setCacheSize(maxSize);
    }
    purgeCache() {
        const source = this.source;
        for (const [start, end] of this.context.cache.clear()) {
            for (let i = start; i <= end; i++) {
                source[i] = INFINITE_SCROLL_DEFFERED_ROW;
            }
        }
        this.refresh();
    }
    isVirtualRow(row) {
        return row === INFINITE_SCROLL_DEFFERED_ROW;
    }
    isVirtualContext(context) {
        return context.$implicit === INFINITE_SCROLL_DEFFERED_ROW;
    }
    /**
     * Update the size of the datasource to reflect a virtual size.
     * This will extend the scrollable size of the grid.
     *
     * > Note that you can only add to the size, if the current size is larger than the new size nothing will happen.
     */
    updateVirtualSize(newSize) {
        if (this.adapter.inFlight) {
            this.onRenderDataChanging
                .pipe(take(1))
                .subscribe(r => {
                PblInfiniteScrollDataSource.updateVirtualSize(newSize, r.data);
                // we must refire so virtual scroll viewport can catch it
                // because it also listen's to this stream but it is registered before us.
                // See virtual-scroll/virtual-scroll-for-of.ts where "dataStream" is assigned
                this._onRenderDataChanging.next(r);
            });
        }
        else {
            PblInfiniteScrollDataSource.updateVirtualSize(newSize, this.source);
        }
    }
    static updateVirtualSize(newSize, values) {
        if (values && values.length < newSize) {
            for (let i = values.length; i < newSize; i++) {
                values[i] = INFINITE_SCROLL_DEFFERED_ROW;
            }
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5maW5pdGUtc2Nyb2xsLWRhdGFzb3VyY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL25ncmlkL2luZmluaXRlLXNjcm9sbC9zcmMvbGliL2luZmluaXRlLXNjcm9sbC1kYXRhLXNvdXJjZS9pbmZpbml0ZS1zY3JvbGwtZGF0YXNvdXJjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDdEMsT0FBTyxFQUFFLGFBQWEsRUFBNEMsTUFBTSxlQUFlLENBQUM7QUFFeEYsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFJOUUsTUFBTSxPQUFPLDJCQUFrRCxTQUFRLGFBRzJEO0lBS2hJLFlBQTZCLE9BQTZDLEVBQUUsT0FBOEI7UUFDeEcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztRQURWLFlBQU8sR0FBUCxPQUFPLENBQXNDO0lBRTFFLENBQUM7SUFMRCxJQUFJLFlBQVksS0FBSyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDekQsSUFBSSxTQUFTLEtBQUssT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBTW5ELFlBQVksQ0FBQyxPQUFlO1FBQzFCLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRUQsVUFBVTtRQUNSLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDM0IsS0FBSyxNQUFNLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQ3JELEtBQUssSUFBSSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ2pDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyw0QkFBNEIsQ0FBQzthQUMxQztTQUNGO1FBQ0QsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ2pCLENBQUM7SUFFRCxZQUFZLENBQUMsR0FBUTtRQUNuQixPQUFPLEdBQUcsS0FBSyw0QkFBNEIsQ0FBQztJQUM5QyxDQUFDO0lBRUQsZ0JBQWdCLENBQUMsT0FBZ0M7UUFDL0MsT0FBTyxPQUFPLENBQUMsU0FBUyxLQUFLLDRCQUE0QixDQUFDO0lBQzVELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGlCQUFpQixDQUFDLE9BQWU7UUFDL0IsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRTtZQUN6QixJQUFJLENBQUMsb0JBQW9CO2lCQUN0QixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUNiLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRTtnQkFDYiwyQkFBMkIsQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUMvRCx5REFBeUQ7Z0JBQ3pELDBFQUEwRTtnQkFDMUUsNkVBQTZFO2dCQUM3RSxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLENBQUMsQ0FBQyxDQUFDO1NBQ047YUFBTTtZQUNMLDJCQUEyQixDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDckU7SUFDSCxDQUFDO0lBRUQsTUFBTSxDQUFDLGlCQUFpQixDQUFDLE9BQWUsRUFBRSxNQUFhO1FBQ3JELElBQUksTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsT0FBTyxFQUFFO1lBQ3JDLEtBQUssSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsT0FBTyxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUM1QyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsNEJBQTRCLENBQUM7YUFDMUM7U0FDRjtJQUNILENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRha2UgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBQYmxEYXRhU291cmNlLCBQYmxEYXRhU291cmNlT3B0aW9ucywgUGJsTmdyaWRSb3dDb250ZXh0IH0gZnJvbSAnQHBlYnVsYS9uZ3JpZCc7XG5pbXBvcnQgeyBQYmxJbmZpbml0ZVNjcm9sbERTQ29udGV4dCB9IGZyb20gJy4vaW5maW5pdGUtc2Nyb2xsLWRhdGFzb3VyY2UuY29udGV4dCc7XG5pbXBvcnQgeyBJTkZJTklURV9TQ1JPTExfREVGRkVSRURfUk9XIH0gZnJvbSAnLi9pbmZpbml0ZS1zY3JvbGwtZGVmZmVyZWQtcm93JztcbmltcG9ydCB7IFBibEluZmluaXRlU2Nyb2xsRGF0YVNvdXJjZUFkYXB0ZXIgfSBmcm9tICcuL2luZmluaXRlLXNjcm9sbC1kYXRhc291cmNlLWFkYXB0ZXInO1xuaW1wb3J0IHsgUGJsSW5maW5pdGVTY3JvbGxUcmlnZ2VyQ2hhbmdlZEV2ZW50IH0gZnJvbSAnLi9pbmZpbml0ZS1zY3JvbGwtZGF0YXNvdXJjZS50eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBQYmxJbmZpbml0ZVNjcm9sbERhdGFTb3VyY2U8VCA9IGFueSwgVERhdGEgPSBhbnk+IGV4dGVuZHMgUGJsRGF0YVNvdXJjZTxULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFREYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBibEluZmluaXRlU2Nyb2xsVHJpZ2dlckNoYW5nZWRFdmVudDxURGF0YT4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUGJsSW5maW5pdGVTY3JvbGxEYXRhU291cmNlQWRhcHRlcjxULCBURGF0YT4+IHtcblxuICBnZXQgbWF4Q2FjaGVTaXplKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LmNhY2hlLm1heFNpemU7IH1cbiAgZ2V0IGNhY2hlU2l6ZSgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5jYWNoZS5zaXplOyB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBjb250ZXh0OiBQYmxJbmZpbml0ZVNjcm9sbERTQ29udGV4dDxULCBURGF0YT4sIG9wdGlvbnM/OiBQYmxEYXRhU291cmNlT3B0aW9ucykge1xuICAgIHN1cGVyKGNvbnRleHQuZ2V0QWRhcHRlcigpLCBvcHRpb25zKTtcbiAgfVxuXG4gIHNldENhY2hlU2l6ZShtYXhTaXplOiBudW1iZXIpIHtcbiAgICB0aGlzLmNvbnRleHQuY2FjaGUuc2V0Q2FjaGVTaXplKG1heFNpemUpO1xuICB9XG5cbiAgcHVyZ2VDYWNoZSgpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICBmb3IgKGNvbnN0IFtzdGFydCwgZW5kXSBvZiB0aGlzLmNvbnRleHQuY2FjaGUuY2xlYXIoKSkge1xuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgIHNvdXJjZVtpXSA9IElORklOSVRFX1NDUk9MTF9ERUZGRVJFRF9ST1c7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVmcmVzaCgpO1xuICB9XG5cbiAgaXNWaXJ0dWFsUm93KHJvdzogYW55KSB7XG4gICAgcmV0dXJuIHJvdyA9PT0gSU5GSU5JVEVfU0NST0xMX0RFRkZFUkVEX1JPVztcbiAgfVxuXG4gIGlzVmlydHVhbENvbnRleHQoY29udGV4dDogUGJsTmdyaWRSb3dDb250ZXh0PGFueT4pIHtcbiAgICByZXR1cm4gY29udGV4dC4kaW1wbGljaXQgPT09IElORklOSVRFX1NDUk9MTF9ERUZGRVJFRF9ST1c7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBzaXplIG9mIHRoZSBkYXRhc291cmNlIHRvIHJlZmxlY3QgYSB2aXJ0dWFsIHNpemUuXG4gICAqIFRoaXMgd2lsbCBleHRlbmQgdGhlIHNjcm9sbGFibGUgc2l6ZSBvZiB0aGUgZ3JpZC5cbiAgICpcbiAgICogPiBOb3RlIHRoYXQgeW91IGNhbiBvbmx5IGFkZCB0byB0aGUgc2l6ZSwgaWYgdGhlIGN1cnJlbnQgc2l6ZSBpcyBsYXJnZXIgdGhhbiB0aGUgbmV3IHNpemUgbm90aGluZyB3aWxsIGhhcHBlbi5cbiAgICovXG4gIHVwZGF0ZVZpcnR1YWxTaXplKG5ld1NpemU6IG51bWJlcikge1xuICAgIGlmICh0aGlzLmFkYXB0ZXIuaW5GbGlnaHQpIHtcbiAgICAgIHRoaXMub25SZW5kZXJEYXRhQ2hhbmdpbmdcbiAgICAgICAgLnBpcGUodGFrZSgxKSlcbiAgICAgICAgLnN1YnNjcmliZShyID0+IHtcbiAgICAgICAgICBQYmxJbmZpbml0ZVNjcm9sbERhdGFTb3VyY2UudXBkYXRlVmlydHVhbFNpemUobmV3U2l6ZSwgci5kYXRhKTtcbiAgICAgICAgICAvLyB3ZSBtdXN0IHJlZmlyZSBzbyB2aXJ0dWFsIHNjcm9sbCB2aWV3cG9ydCBjYW4gY2F0Y2ggaXRcbiAgICAgICAgICAvLyBiZWNhdXNlIGl0IGFsc28gbGlzdGVuJ3MgdG8gdGhpcyBzdHJlYW0gYnV0IGl0IGlzIHJlZ2lzdGVyZWQgYmVmb3JlIHVzLlxuICAgICAgICAgIC8vIFNlZSB2aXJ0dWFsLXNjcm9sbC92aXJ0dWFsLXNjcm9sbC1mb3Itb2YudHMgd2hlcmUgXCJkYXRhU3RyZWFtXCIgaXMgYXNzaWduZWRcbiAgICAgICAgICB0aGlzLl9vblJlbmRlckRhdGFDaGFuZ2luZy5uZXh0KHIpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgUGJsSW5maW5pdGVTY3JvbGxEYXRhU291cmNlLnVwZGF0ZVZpcnR1YWxTaXplKG5ld1NpemUsIHRoaXMuc291cmNlKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgdXBkYXRlVmlydHVhbFNpemUobmV3U2l6ZTogbnVtYmVyLCB2YWx1ZXM6IGFueVtdKSB7XG4gICAgaWYgKHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoIDwgbmV3U2l6ZSkge1xuICAgICAgZm9yIChsZXQgaSA9IHZhbHVlcy5sZW5ndGg7IGkgPCBuZXdTaXplOyBpKyspIHtcbiAgICAgICAgdmFsdWVzW2ldID0gSU5GSU5JVEVfU0NST0xMX0RFRkZFUkVEX1JPVztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ==