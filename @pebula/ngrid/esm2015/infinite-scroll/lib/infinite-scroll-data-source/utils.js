import { INFINITE_SCROLL_DEFFERED_ROW } from './infinite-scroll-deffered-row';
export function normalizeOptions(rawOptions) {
    const options = rawOptions || {};
    options.blockSize = Number(options.blockSize);
    if (Number.isNaN(options.blockSize)) {
        options.blockSize = 50;
    }
    else if (options.blockSize <= 0) {
        options.blockSize = 50;
    }
    options.initialVirtualSize = Number(options.initialVirtualSize);
    if (Number.isNaN(options.initialVirtualSize)) {
        options.initialVirtualSize = 0;
    }
    return options;
}
export function shouldTriggerInvisibleScroll(context) {
    const ds = context.getDataSource();
    if (context.totalLength && ds.renderStart > context.totalLength) {
        return false;
    }
    return !!(context.cache.matchNewBlock());
}
export function tryAddVirtualRowsBlock(source, event, blockSize) {
    const currLen = source.length;
    if (currLen < event.totalLength && event.totalLength > event.toRow && source[currLen - 1] !== INFINITE_SCROLL_DEFFERED_ROW) {
        const len = Math.min(currLen + blockSize - 1, event.totalLength);
        for (let i = currLen; i < len; i++) {
            source[i] = INFINITE_SCROLL_DEFFERED_ROW;
        }
        return true;
    }
    return false;
}
export function upgradeChangeEventToInfinite(totalLength, event, blockMatch) {
    const [direction, start, end] = blockMatch;
    if (!event.isInitial) {
        if (direction === 1 && end === totalLength - 1) {
            event.isLastBlock = true;
        }
    }
    event.direction = direction;
    event.fromRow = start;
    event.offset = (end - start) + 1;
    event.toRow = end;
    return event;
}
/**
 * Update the cache with new block information to reflect the last triggered event and
 * also update the datasource with the new values, removing values that are purged due to cache logic.
 * Returns the new datasource, or the original datasource editing in-place.
 *
 * For example, if the cache was empty the values provided are returned
 * Otherwise, the original datasource is edited and returned.
 */
export function updateCacheAndDataSource(context, event, values) {
    if (context.cache.empty) {
        return values;
    }
    const source = context.getDataSource().source;
    const toRemove = context.cache.update(event.fromRow, event.toRow, event.direction);
    for (const [start, end] of toRemove) {
        for (let i = start; i <= end; i++) {
            source[i] = INFINITE_SCROLL_DEFFERED_ROW;
        }
    }
    const { fromRow } = event;
    for (let i = 0, len = values.length; i < len; i++) {
        source[i + fromRow] = values[i];
    }
    return source;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL25ncmlkL2luZmluaXRlLXNjcm9sbC9zcmMvbGliL2luZmluaXRlLXNjcm9sbC1kYXRhLXNvdXJjZS91dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFJQSxPQUFPLEVBQUUsNEJBQTRCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUU5RSxNQUFNLFVBQVUsZ0JBQWdCLENBQUMsVUFBc0M7SUFDckUsTUFBTSxPQUFPLEdBQStCLFVBQVUsSUFBSSxFQUFFLENBQUM7SUFFN0QsT0FBTyxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzlDLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUU7UUFDbkMsT0FBTyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7S0FDeEI7U0FBTSxJQUFJLE9BQU8sQ0FBQyxTQUFTLElBQUksQ0FBQyxFQUFFO1FBQ2pDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDO0tBQ3hCO0lBRUQsT0FBTyxDQUFDLGtCQUFrQixHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztJQUNoRSxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLGtCQUFrQixDQUFDLEVBQUU7UUFDNUMsT0FBTyxDQUFDLGtCQUFrQixHQUFHLENBQUMsQ0FBQztLQUNoQztJQUVELE9BQU8sT0FBTyxDQUFDO0FBQ2pCLENBQUM7QUFFRCxNQUFNLFVBQVUsNEJBQTRCLENBQWlCLE9BQTZDO0lBQ3hHLE1BQU0sRUFBRSxHQUFHLE9BQU8sQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUNuQyxJQUFJLE9BQU8sQ0FBQyxXQUFXLElBQUksRUFBRSxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsV0FBVyxFQUFFO1FBQy9ELE9BQU8sS0FB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b250ZW50IjpbImltcG9ydCB7IFBibERhdGFTb3VyY2VUcmlnZ2VyQ2hhbmdlZEV2ZW50IH0gZnJvbSAnQHBlYnVsYS9uZ3JpZCc7XG5pbXBvcnQgeyBDYWNoZUJsb2NrIH0gZnJvbSAnLi9jYWNoaW5nJztcbmltcG9ydCB7IFBibEluZmluaXRlU2Nyb2xsRFNDb250ZXh0IH0gZnJvbSAnLi9pbmZpbml0ZS1zY3JvbGwtZGF0YXNvdXJjZS5jb250ZXh0JztcbmltcG9ydCB7IFBibEluZmluaXRlU2Nyb2xsRHNPcHRpb25zLCBQYmxJbmZpbml0ZVNjcm9sbFRyaWdnZXJDaGFuZ2VkRXZlbnQgfSBmcm9tICcuL2luZmluaXRlLXNjcm9sbC1kYXRhc291cmNlLnR5cGVzJztcbmltcG9ydCB7IElORklOSVRFX1NDUk9MTF9ERUZGRVJFRF9ST1cgfSBmcm9tICcuL2luZmluaXRlLXNjcm9sbC1kZWZmZXJlZC1yb3cnO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9ucyhyYXdPcHRpb25zOiBQYmxJbmZpbml0ZVNjcm9sbERzT3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zOiBQYmxJbmZpbml0ZVNjcm9sbERzT3B0aW9ucyA9IHJhd09wdGlvbnMgfHwge307XG5cbiAgb3B0aW9ucy5ibG9ja1NpemUgPSBOdW1iZXIob3B0aW9ucy5ibG9ja1NpemUpO1xuICBpZiAoTnVtYmVyLmlzTmFOKG9wdGlvbnMuYmxvY2tTaXplKSkge1xuICAgIG9wdGlvbnMuYmxvY2tTaXplID0gNTA7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5ibG9ja1NpemUgPD0gMCkge1xuICAgIG9wdGlvbnMuYmxvY2tTaXplID0gNTA7XG4gIH1cblxuICBvcHRpb25zLmluaXRpYWxWaXJ0dWFsU2l6ZSA9IE51bWJlcihvcHRpb25zLmluaXRpYWxWaXJ0dWFsU2l6ZSk7XG4gIGlmIChOdW1iZXIuaXNOYU4ob3B0aW9ucy5pbml0aWFsVmlydHVhbFNpemUpKSB7XG4gICAgb3B0aW9ucy5pbml0aWFsVmlydHVhbFNpemUgPSAwO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRUcmlnZ2VySW52aXNpYmxlU2Nyb2xsPFQsIFREYXRhID0gYW55Pihjb250ZXh0OiBQYmxJbmZpbml0ZVNjcm9sbERTQ29udGV4dDxULCBURGF0YT4pIHtcbiAgY29uc3QgZHMgPSBjb250ZXh0LmdldERhdGFTb3VyY2UoKTtcbiAgaWYgKGNvbnRleHQudG90YWxMZW5ndGggJiYgZHMucmVuZGVyU3RhcnQgPiBjb250ZXh0LnRvdGFsTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEhKGNvbnRleHQuY2FjaGUubWF0Y2hOZXdCbG9jaygpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyeUFkZFZpcnR1YWxSb3dzQmxvY2s8VD4oc291cmNlOiBUW10sIGV2ZW50OiBQYmxJbmZpbml0ZVNjcm9sbFRyaWdnZXJDaGFuZ2VkRXZlbnQ8YW55PiwgYmxvY2tTaXplOiBudW1iZXIpIHtcbiAgY29uc3QgY3VyckxlbiA9IHNvdXJjZS5sZW5ndGg7XG4gIGlmIChjdXJyTGVuIDwgZXZlbnQudG90YWxMZW5ndGggJiYgZXZlbnQudG90YWxMZW5ndGggPiBldmVudC50b1JvdyAmJiBzb3VyY2VbY3VyckxlbiAtIDFdICE9PSBJTkZJTklURV9TQ1JPTExfREVGRkVSRURfUk9XKSB7XG4gICAgY29uc3QgbGVuID0gTWF0aC5taW4oY3VyckxlbiArIGJsb2NrU2l6ZSAtIDEsIGV2ZW50LnRvdGFsTGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gY3VyckxlbjsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzb3VyY2VbaV0gPSBJTkZJTklURV9TQ1JPTExfREVGRkVSRURfUk9XO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGdyYWRlQ2hhbmdlRXZlbnRUb0luZmluaXRlPFQsIFREYXRhID0gYW55Pih0b3RhbExlbmd0aDogbnVtYmVyLCBldmVudDogUGJsRGF0YVNvdXJjZVRyaWdnZXJDaGFuZ2VkRXZlbnQ8VERhdGE+LCBibG9ja01hdGNoOiBDYWNoZUJsb2NrKSB7XG4gIGNvbnN0IFsgZGlyZWN0aW9uLCBzdGFydCwgZW5kIF0gPSBibG9ja01hdGNoO1xuXG4gIGlmICghZXZlbnQuaXNJbml0aWFsKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gMSAmJiBlbmQgPT09IHRvdGFsTGVuZ3RoIC0gMSkge1xuICAgICAgKGV2ZW50IGFzIFBibEluZmluaXRlU2Nyb2xsVHJpZ2dlckNoYW5nZWRFdmVudCkuaXNMYXN0QmxvY2sgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIChldmVudCBhcyBQYmxJbmZpbml0ZVNjcm9sbFRyaWdnZXJDaGFuZ2VkRXZlbnQpLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgKGV2ZW50IGFzIFBibEluZmluaXRlU2Nyb2xsVHJpZ2dlckNoYW5nZWRFdmVudCkuZnJvbVJvdyA9IHN0YXJ0O1xuICAoZXZlbnQgYXMgUGJsSW5maW5pdGVTY3JvbGxUcmlnZ2VyQ2hhbmdlZEV2ZW50KS5vZmZzZXQgPSAoZW5kIC0gc3RhcnQpICsgMTtcbiAgKGV2ZW50IGFzIFBibEluZmluaXRlU2Nyb2xsVHJpZ2dlckNoYW5nZWRFdmVudCkudG9Sb3cgPSBlbmQ7XG5cbiAgcmV0dXJuIGV2ZW50IGFzIFBibEluZmluaXRlU2Nyb2xsVHJpZ2dlckNoYW5nZWRFdmVudDxURGF0YT4gfCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjYWNoZSB3aXRoIG5ldyBibG9jayBpbmZvcm1hdGlvbiB0byByZWZsZWN0IHRoZSBsYXN0IHRyaWdnZXJlZCBldmVudCBhbmRcbiAqIGFsc28gdXBkYXRlIHRoZSBkYXRhc291cmNlIHdpdGggdGhlIG5ldyB2YWx1ZXMsIHJlbW92aW5nIHZhbHVlcyB0aGF0IGFyZSBwdXJnZWQgZHVlIHRvIGNhY2hlIGxvZ2ljLlxuICogUmV0dXJucyB0aGUgbmV3IGRhdGFzb3VyY2UsIG9yIHRoZSBvcmlnaW5hbCBkYXRhc291cmNlIGVkaXRpbmcgaW4tcGxhY2UuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHRoZSBjYWNoZSB3YXMgZW1wdHkgdGhlIHZhbHVlcyBwcm92aWRlZCBhcmUgcmV0dXJuZWRcbiAqIE90aGVyd2lzZSwgdGhlIG9yaWdpbmFsIGRhdGFzb3VyY2UgaXMgZWRpdGVkIGFuZCByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUNhY2hlQW5kRGF0YVNvdXJjZTxULCBURGF0YSA9IGFueT4oY29udGV4dDogUGJsSW5maW5pdGVTY3JvbGxEU0NvbnRleHQ8VCwgVERhdGE+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFBibEluZmluaXRlU2Nyb2xsVHJpZ2dlckNoYW5nZWRFdmVudDxURGF0YT4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IFRbXSkge1xuXG4gIGlmIChjb250ZXh0LmNhY2hlLmVtcHR5KSB7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIGNvbnN0IHNvdXJjZSA9IGNvbnRleHQuZ2V0RGF0YVNvdXJjZSgpLnNvdXJjZTtcbiAgY29uc3QgdG9SZW1vdmUgPSBjb250ZXh0LmNhY2hlLnVwZGF0ZShldmVudC5mcm9tUm93LCBldmVudC50b1JvdywgZXZlbnQuZGlyZWN0aW9uKTtcbiAgZm9yKGNvbnN0IFtzdGFydCwgZW5kXSBvZiB0b1JlbW92ZSkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgc291cmNlW2ldID0gSU5GSU5JVEVfU0NST0xMX0RFRkZFUkVEX1JPVztcbiAgICB9XG4gIH1cblxuICBjb25zdCB7IGZyb21Sb3cgfSA9IGV2ZW50O1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc291cmNlW2kgKyBmcm9tUm93XSA9IHZhbHVlc1tpXTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2U7XG59XG4iXX0=