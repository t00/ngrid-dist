import { createStateChunkHandler } from '../../handling';
export function registerColumnDefChildHandlers() {
    /* ====================================================================================================================================================== */
    createStateChunkHandler('dataColumn')
        .requiredKeys('id', 'prop')
        .handleKeys('label', 'css', 'type', 'width', 'minWidth', 'maxWidth', // PblNgridBaseColumnState (all optional)
    'headerType', 'footerType', 'sort', 'alias', 'editable', 'pin')
        .serialize((key, ctx) => {
        const c = ctx.data.activeColumn || ctx.data.pblColumn;
        if (c) {
            switch (key) {
                case 'prop':
                    return c.orgProp;
                default:
                    break;
            }
        }
        const value = c ? c[key] : ctx.source[key];
        switch (key) {
            case 'sort':
                if (typeof value === 'boolean') {
                    return value;
                }
                else {
                    return;
                }
            default:
                break;
        }
        return value;
    })
        .deserialize((key, stateValue, ctx) => {
        const { activeColumn } = ctx.data;
        if (activeColumn) {
            switch (key) {
                case 'width':
                    activeColumn.updateWidth(stateValue);
                    break;
            }
        }
        if (ctx.source) {
            switch (key) {
                case 'prop':
                    return;
                case 'type':
                case 'headerType':
                case 'footerType':
                    const typeValue = ctx.source[key];
                    const stateTypeDef = stateValue;
                    if (stateTypeDef && typeof stateTypeDef !== 'string' && typeValue && typeof typeValue !== 'string') {
                        typeValue.name = stateTypeDef.name;
                        if (stateTypeDef.data) {
                            typeValue.data = Object.assign(typeValue.data || {}, stateTypeDef.data);
                        }
                        return;
                    }
                    break;
            }
            // We must assert the type starting from 3.5 onwards
            // See "Fixes to unsound writes to indexed access types" in https://devblogs.microsoft.com/typescript/announcing-typescript-3-5
            ctx.source[key] = stateValue;
        }
    })
        .register();
    /* ====================================================================================================================================================== */
    createStateChunkHandler('dataMetaRow')
        .handleKeys('rowClassName', 'type') // All Optional
        .serialize((key, ctx) => {
        const active = ctx.data.active || ctx.source;
        if (active) {
            return active[key];
        }
    })
        .deserialize((key, stateValue, ctx) => {
        // We must assert the type starting from 3.5 onwards
        // See "Fixes to unsound writes to indexed access types" in https://devblogs.microsoft.com/typescript/announcing-typescript-3-5
        ctx.source[key] = stateValue;
    })
        .register();
    /* ====================================================================================================================================================== */
    createStateChunkHandler('metaRow')
        // Note that we are not handling `cols`, this should be called from the parent, as a different child chunk handling process for each column
        .handleKeys('rowClassName', 'type', // All Optional like dataMetaRow
    'rowIndex')
        .serialize((key, ctx) => {
        return ctx.source[key];
    })
        .deserialize((key, stateValue, ctx) => {
    })
        .register();
    /* ====================================================================================================================================================== */
    createStateChunkHandler('metaGroupRow')
        // Note that we are not handling `cols`, this should be called from the parent, as a different child chunk handling process for each column
        .handleKeys('rowClassName', 'type', // All Optional like dataMetaRow
    'rowIndex')
        .serialize((key, ctx) => {
        return ctx.source[key];
    })
        .deserialize((key, stateValue, ctx) => {
    })
        .register();
    /* ====================================================================================================================================================== */
    createStateChunkHandler('metaColumn')
        .requiredKeys('kind', 'rowIndex')
        .handleKeys('id', 'label', 'css', 'type', 'width', 'minWidth', 'maxWidth')
        .serialize((key, ctx) => {
        return ctx.source[key];
    })
        .deserialize((key, stateValue, ctx) => {
    })
        .register();
    /* ====================================================================================================================================================== */
    createStateChunkHandler('metaGroupColumn')
        .requiredKeys('columnIds', 'rowIndex')
        .handleKeys('id', 'label', 'css', 'type', 'width', 'minWidth', 'maxWidth')
        .serialize((key, ctx) => {
        return ctx.source[key];
    })
        .deserialize((key, stateValue, ctx) => {
    })
        .register();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hpbGRyZW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL25ncmlkL3N0YXRlL3NyYy9saWIvY29yZS9idWlsdC1pbi1oYW5kbGVycy9jb2x1bW4tZGVmL2NoaWxkcmVuLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXpELE1BQU0sVUFBVSw4QkFBOEI7SUFDNUMsNEpBQTRKO0lBRTVKLHVCQUF1QixDQUFDLFlBQVksQ0FBQztTQUNsQyxZQUFZLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQztTQUMxQixVQUFVLENBQ1QsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQVcseUNBQXlDO0lBQzNHLFlBQVksRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsS0FBSyxDQUMvRDtTQUNBLFNBQVMsQ0FBRSxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRTtRQUN2QixNQUFNLENBQUMsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVksSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUN0RCxJQUFJLENBQUMsRUFBRTtZQUNMLFFBQVEsR0FBRyxFQUFFO2dCQUNYLEtBQUssTUFBTTtvQkFDVCxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUM7Z0JBQ25CO29CQUNFLE1BQU07YUFDVDtTQUNGO1FBRUQsTUFBTSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFM0MsUUFBUSxHQUFHLEVBQUU7WUFDWCxLQUFLLE1BQU07Z0JBQ1QsSUFBSSxPQUFPLEtBQUssS0FBSyxTQUFTLEVB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LENBQUMsR0FBRyxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsRUFBRTtJQUV2QyxDQUFDLENBQUM7U0FDRCxRQUFRLEVBQUUsQ0FBQztBQUNoQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGJsQ29sdW1uVHlwZURlZmluaXRpb24gfSBmcm9tICdAcGVidWxhL25ncmlkL2NvcmUnO1xuaW1wb3J0IHsgY3JlYXRlU3RhdGVDaHVua0hhbmRsZXIgfSBmcm9tICcuLi8uLi9oYW5kbGluZyc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckNvbHVtbkRlZkNoaWxkSGFuZGxlcnMoKSB7XG4gIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gIGNyZWF0ZVN0YXRlQ2h1bmtIYW5kbGVyKCdkYXRhQ29sdW1uJylcbiAgICAucmVxdWlyZWRLZXlzKCdpZCcsICdwcm9wJylcbiAgICAuaGFuZGxlS2V5cyhcbiAgICAgICdsYWJlbCcsICdjc3MnLCAndHlwZScsICd3aWR0aCcsICdtaW5XaWR0aCcsICdtYXhXaWR0aCcsICAgICAgICAgIC8vIFBibE5ncmlkQmFzZUNvbHVtblN0YXRlIChhbGwgb3B0aW9uYWwpXG4gICAgICAnaGVhZGVyVHlwZScsICdmb290ZXJUeXBlJywgJ3NvcnQnLCAnYWxpYXMnLCAnZWRpdGFibGUnLCAncGluJywgICAvLyBBbGwgT3B0aW9uYWxcbiAgICApXG4gICAgLnNlcmlhbGl6ZSggKGtleSwgY3R4KSA9PiB7XG4gICAgICBjb25zdCBjID0gY3R4LmRhdGEuYWN0aXZlQ29sdW1uIHx8IGN0eC5kYXRhLnBibENvbHVtbjtcbiAgICAgIGlmIChjKSB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgY2FzZSAncHJvcCc6XG4gICAgICAgICAgICByZXR1cm4gYy5vcmdQcm9wO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWx1ZSA9IGMgPyBjW2tleV0gOiBjdHguc291cmNlW2tleV07XG5cbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ3NvcnQnOlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSlcbiAgICAuZGVzZXJpYWxpemUoIChrZXksIHN0YXRlVmFsdWUsIGN0eCkgPT4ge1xuICAgICAgY29uc3QgeyBhY3RpdmVDb2x1bW4gfSA9IGN0eC5kYXRhO1xuICAgICAgaWYgKGFjdGl2ZUNvbHVtbikge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgICAgIGFjdGl2ZUNvbHVtbi51cGRhdGVXaWR0aChzdGF0ZVZhbHVlIGFzIGFueSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN0eC5zb3VyY2UpIHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlICdwcm9wJzpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgICBjYXNlICdoZWFkZXJUeXBlJzpcbiAgICAgICAgICBjYXNlICdmb290ZXJUeXBlJzpcbiAgICAgICAgICAgIGNvbnN0IHR5cGVWYWx1ZSA9IGN0eC5zb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlVHlwZURlZjogUGJsQ29sdW1uVHlwZURlZmluaXRpb24gPSBzdGF0ZVZhbHVlIGFzIGFueTtcbiAgICAgICAgICAgIGlmIChzdGF0ZVR5cGVEZWYgJiYgdHlwZW9mIHN0YXRlVHlwZURlZiAhPT0gJ3N0cmluZycgJiYgdHlwZVZhbHVlICYmIHR5cGVvZiB0eXBlVmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHR5cGVWYWx1ZS5uYW1lID0gc3RhdGVUeXBlRGVmLm5hbWU7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZVR5cGVEZWYuZGF0YSkge1xuICAgICAgICAgICAgICAgIHR5cGVWYWx1ZS5kYXRhID0gT2JqZWN0LmFzc2lnbih0eXBlVmFsdWUuZGF0YSB8fCB7fSwgc3RhdGVUeXBlRGVmLmRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgbXVzdCBhc3NlcnQgdGhlIHR5cGUgc3RhcnRpbmcgZnJvbSAzLjUgb253YXJkc1xuICAgICAgICAvLyBTZWUgXCJGaXhlcyB0byB1bnNvdW5kIHdyaXRlcyB0byBpbmRleGVkIGFjY2VzcyB0eXBlc1wiIGluIGh0dHBzOi8vZGV2YmxvZ3MubWljcm9zb2Z0LmNvbS90eXBlc2NyaXB0L2Fubm91bmNpbmctdHlwZXNjcmlwdC0zLTVcbiAgICAgICAgY3R4LnNvdXJjZVtrZXkgYXMgYW55XSA9IHN0YXRlVmFsdWU7XG4gICAgICB9XG5cbiAgICB9KVxuICAgIC5yZWdpc3RlcigpO1xuXG4gIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gIGNyZWF0ZVN0YXRlQ2h1bmtIYW5kbGVyKCdkYXRhTWV0YVJvdycpXG4gICAgLmhhbmRsZUtleXMoJ3Jvd0NsYXNzTmFtZScsICd0eXBlJykgICAgLy8gQWxsIE9wdGlvbmFsXG4gICAgLnNlcmlhbGl6ZSggKGtleSwgY3R4KSA9PiB7XG4gICAgICBjb25zdCBhY3RpdmUgPSBjdHguZGF0YS5hY3RpdmUgfHwgY3R4LnNvdXJjZTtcbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZVtrZXldO1xuICAgICAgfVxuICAgIH0pXG4gICAgLmRlc2VyaWFsaXplKCAoa2V5LCBzdGF0ZVZhbHVlLCBjdHgpID0+IHtcbiAgICAgIC8vIFdlIG11c3QgYXNzZXJ0IHRoZSB0eXBlIHN0YXJ0aW5nIGZyb20gMy41IG9ud2FyZHNcbiAgICAgIC8vIFNlZSBcIkZpeGVzIHRvIHVuc291bmQgd3JpdGVzIHRvIGluZGV4ZWQgYWNjZXNzIHR5cGVzXCIgaW4gaHR0cHM6Ly9kZXZibG9ncy5taWNyb3NvZnQuY29tL3R5cGVzY3JpcHQvYW5ub3VuY2luZy10eXBlc2NyaXB0LTMtNVxuICAgICAgY3R4LnNvdXJjZVtrZXldID0gc3RhdGVWYWx1ZSBhcyBhbnk7XG4gICAgfSlcbiAgICAucmVnaXN0ZXIoKTtcblxuXG4gIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gIGNyZWF0ZVN0YXRlQ2h1bmtIYW5kbGVyKCdtZXRhUm93JylcbiAgICAvLyBOb3RlIHRoYXQgd2UgYXJlIG5vdCBoYW5kbGluZyBgY29sc2AsIHRoaXMgc2hvdWxkIGJlIGNhbGxlZCBmcm9tIHRoZSBwYXJlbnQsIGFzIGEgZGlmZmVyZW50IGNoaWxkIGNodW5rIGhhbmRsaW5nIHByb2Nlc3MgZm9yIGVhY2ggY29sdW1uXG4gICAgLmhhbmRsZUtleXMoXG4gICAgICAncm93Q2xhc3NOYW1lJywgJ3R5cGUnLCAgICAvLyBBbGwgT3B0aW9uYWwgbGlrZSBkYXRhTWV0YVJvd1xuICAgICAgJ3Jvd0luZGV4JywgICAgICAgICAgICAgICAgLy8gUmVxdWlyZWRcbiAgICAgIClcbiAgICAuc2VyaWFsaXplKCAoa2V5LCBjdHgpID0+IHtcbiAgICAgIHJldHVybiBjdHguc291cmNlW2tleV07XG4gICAgfSlcbiAgICAuZGVzZXJpYWxpemUoIChrZXksIHN0YXRlVmFsdWUsIGN0eCkgPT4ge1xuXG4gICAgfSlcbiAgICAucmVnaXN0ZXIoKTtcblxuICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICBjcmVhdGVTdGF0ZUNodW5rSGFuZGxlcignbWV0YUdyb3VwUm93JylcbiAgICAvLyBOb3RlIHRoYXQgd2UgYXJlIG5vdCBoYW5kbGluZyBgY29sc2AsIHRoaXMgc2hvdWxkIGJlIGNhbGxlZCBmcm9tIHRoZSBwYXJlbnQsIGFzIGEgZGlmZmVyZW50IGNoaWxkIGNodW5rIGhhbmRsaW5nIHByb2Nlc3MgZm9yIGVhY2ggY29sdW1uXG4gICAgLmhhbmRsZUtleXMoXG4gICAgICAncm93Q2xhc3NOYW1lJywgJ3R5cGUnLCAgICAvLyBBbGwgT3B0aW9uYWwgbGlrZSBkYXRhTWV0YVJvd1xuICAgICAgJ3Jvd0luZGV4JywgICAgICAgICAgICAgICAgLy8gUmVxdWlyZWRcbiAgICAgIClcbiAgICAuc2VyaWFsaXplKCAoa2V5LCBjdHgpID0+IHtcbiAgICAgIHJldHVybiBjdHguc291cmNlW2tleV07XG4gICAgfSlcbiAgICAuZGVzZXJpYWxpemUoIChrZXksIHN0YXRlVmFsdWUsIGN0eCkgPT4ge1xuXG4gICAgfSlcbiAgICAucmVnaXN0ZXIoKTtcblxuICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICBjcmVhdGVTdGF0ZUNodW5rSGFuZGxlcignbWV0YUNvbHVtbicpXG4gICAgLnJlcXVpcmVkS2V5cygna2luZCcsICdyb3dJbmRleCcpXG4gICAgLmhhbmRsZUtleXMoXG4gICAgICAnaWQnLCAnbGFiZWwnLCAnY3NzJywgJ3R5cGUnLCAnd2lkdGgnLCAnbWluV2lkdGgnLCAnbWF4V2lkdGgnLCAgICAgICAgLy8gUGJsTmdyaWRCYXNlQ29sdW1uU3RhdGUgKGFsbCBvcHRpb25hbClcbiAgICApXG4gICAgLnNlcmlhbGl6ZSggKGtleSwgY3R4KSA9PiB7XG4gICAgICByZXR1cm4gY3R4LnNvdXJjZVtrZXldO1xuICAgIH0pXG4gICAgLmRlc2VyaWFsaXplKCAoa2V5LCBzdGF0ZVZhbHVlLCBjdHgpID0+IHtcblxuICAgIH0pXG4gICAgLnJlZ2lzdGVyKCk7XG5cbiAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgY3JlYXRlU3RhdGVDaHVua0hhbmRsZXIoJ21ldGFHcm91cENvbHVtbicpXG4gICAgLnJlcXVpcmVkS2V5cygnY29sdW1uSWRzJywgJ3Jvd0luZGV4JylcbiAgICAuaGFuZGxlS2V5cyhcbiAgICAgICdpZCcsICdsYWJlbCcsICdjc3MnLCAndHlwZScsICd3aWR0aCcsICdtaW5XaWR0aCcsICdtYXhXaWR0aCcsICAgICAgICAvLyBQYmxOZ3JpZEJhc2VDb2x1bW5TdGF0ZSAoYWxsIG9wdGlvbmFsKVxuICAgIClcbiAgICAuc2VyaWFsaXplKCAoa2V5LCBjdHgpID0+IHtcbiAgICAgIHJldHVybiBjdHguc291cmNlW2tleV07XG4gICAgfSlcbiAgICAuZGVzZXJpYWxpemUoIChrZXksIHN0YXRlVmFsdWUsIGN0eCkgPT4ge1xuXG4gICAgfSlcbiAgICAucmVnaXN0ZXIoKTtcbn1cbiJdfQ==