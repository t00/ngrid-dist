import { takeUntil, switchMap, filter, tap } from 'rxjs/operators';
import { LEFT_ARROW, UP_ARROW, RIGHT_ARROW, DOWN_ARROW } from '@angular/cdk/keycodes';
import { isCellEvent, isDataCellEvent, rangeBetween, getInnerCellsInRect } from './utils';
const isOsx = /^mac/.test(navigator.platform.toLowerCase());
const isMainMouseButtonClick = (event) => event.source.button === 0;
export function handleFocusAndSelection(targetEvents) {
    const isCellFocusMode = () => targetEvents.grid.focusMode === 'cell';
    const handlers = createHandlers(targetEvents);
    // Handle array keys move (with shift for selection, without for cell focus change)
    targetEvents.keyDown
        .pipe(filter(isCellFocusMode))
        .subscribe(handlers.handleKeyDown);
    // Handle mouse down on cell (focus) and then moving for selection.
    targetEvents.mouseDown
        .pipe(filter(isCellFocusMode), filter(isDataCellEvent), filter(isMainMouseButtonClick), tap(event => {
        event.source.stopPropagation();
        event.source.preventDefault();
    }), tap(handlers.handleMouseDown), // handle mouse down focus
    switchMap(() => targetEvents.cellEnter.pipe(takeUntil(targetEvents.mouseUp))), filter(isDataCellEvent), filter(isMainMouseButtonClick))
        .subscribe(handlers.handleSelectionChangeByMouseClickAndMove); // now handle movements until mouseup
}
function createHandlers(targetEvents) {
    const { contextApi } = targetEvents.grid;
    function focusCell(rowIdent, colIndex, markForCheck) {
        contextApi.focusCell({ rowIdent, colIndex });
    }
    function handleMouseDown(event) {
        if (contextApi.focusedCell && event.source.shiftKey) {
            handleSelectionChangeByMouseClickAndMove(event);
        }
        else if (isOsx ? event.source.metaKey : event.source.ctrlKey) {
            if (event.context.selected) {
                contextApi.unselectCells([event.context]);
            }
            else {
                contextApi.selectCells([event.context]);
            }
        }
        else {
            focusCell(event.context.rowContext.identity, event.context.index);
        }
    }
    function handleKeyDown(event) {
        const source = event.source;
        if (isCellEvent(event)) {
            const sourceCell = event.cellTarget;
            let coeff = 1;
            let isHorizontal = false;
            switch (source.keyCode) {
                case UP_ARROW:
                    coeff = -1;
                case DOWN_ARROW: // tslint:disable-line: no-switch-case-fall-through
                    break;
                case LEFT_ARROW:
                    coeff = -1;
                case RIGHT_ARROW: // tslint:disable-line: no-switch-case-fall-through
                    isHorizontal = true;
                    break;
                default:
                    return;
            }
            event.source.preventDefault();
            event.source.stopPropagation();
            let activeFocus = contextApi.focusedCell;
            if (!activeFocus) {
                const cellContext = contextApi.getCell(sourceCell);
                activeFocus = {
                    rowIdent: cellContext.rowContext.identity,
                    colIndex: cellContext.index,
                };
            }
            if (!!source.shiftKey) {
                handleSelectionChangeByArrows(activeFocus, isHorizontal ? [coeff, 0] : [0, coeff]);
            }
            else {
                handleSingleItemFocus(activeFocus, isHorizontal ? [coeff, 0] : [0, coeff]);
            }
        }
    }
    /**
     * Handle selection changes caused ONLY by the use of the arrow keys with SHIFT key.
     *
     * The implementation is NOT incremental, it will re-calculate the selected cell on every arrow key press (every call to this function).
     *
     * First. A simple adjacent cell detection is performed to determine the direction of the current selected cells relative to the
     * source cell (usually the focused cell). We only care about 4 cells, adjacent to the source Cell: Top, Left, Bottom, Right
     *
     *    │ T │
     * ───┼───┼───
     *  R │ C │ L
     * ───┼───┼───
     *    │ B │
     *
     * We can only have 1 quarter selection with Arrow selection so it TL, TR, BR or BL, any other setup will clear the selection and start from scratch.
     *
     * > Note that the logic in this function is for use with arrow keys + SHIFT key, other selection logic
     * does not fit this scenario (e.g. MOUSE selection or ARROW KEYS + CTRL KEY selection)
     *
     * @param sourceCellRef A point reference to the source cell the direction is relative to
     * @param direction The direction of the new cell.
     * [1 | -1, 0] -> HORIZONTAL
     * [0, 1 | -1] -> VERTICAL
     */
    function handleSelectionChangeByArrows(sourceCellRef, direction) {
        const { rowIdent, colIndex } = sourceCellRef;
        const sourceCellState = contextApi.findRowInCache(rowIdent);
        const [moveH, moveV] = direction;
        const hAdj = [sourceCellState.cells[colIndex - 1], sourceCellState.cells[colIndex + 1]];
        const vAdj = [contextApi.findRowInCache(rowIdent, -1, true), contextApi.findRowInCache(rowIdent, 1, true)];
        let h = (hAdj[0] && hAdj[0].selected ? -1 : 0) + (hAdj[1] && hAdj[1].selected ? 1 : 0);
        let v = (vAdj[0] && vAdj[0].cells[colIndex].selected ? -1 : 0) + (vAdj[1] && vAdj[1].cells[colIndex].selected ? 1 : 0);
        if (h === 0) {
            h += moveH;
        }
        if (v === 0) {
            v += moveV;
        }
        const hCells = [];
        if (h !== 0) {
            let hContextIndex = colIndex;
            let hContext = sourceCellState.cells[colIndex];
            while (hContext && hContext.selected) {
                hCells.push({ rowIdent, colIndex: hContextIndex });
                hContextIndex += h;
                hContext = sourceCellState.cells[hContextIndex];
            }
            if (moveH) {
                if (h === moveH) {
                    if (hContext) {
                        hCells.push({ rowIdent, colIndex: hContextIndex });
                    }
                }
                else {
                    hCells.pop();
                }
            }
        }
        const vCells = [];
        if (v !== 0) {
            let vContextIdent = rowIdent;
            let vContext = contextApi.findRowInCache(vContextIdent, v, true);
            while (vContext && vContext.cells[colIndex].selected) {
                vContextIdent = vContext.identity;
                vCells.push({ rowIdent: vContextIdent, colIndex });
                vContext = contextApi.findRowInCache(vContextIdent, v, true);
            }
            if (moveV) {
                if (v === moveV) {
                    if (vContext) {
                        vCells.push({ rowIdent: vContext.identity, colIndex });
                    }
                }
                else {
                    vCells.pop();
                }
            }
        }
        const innerCells = getInnerCellsInRect(contextApi, hCells, vCells);
        contextApi.selectCells([sourceCellRef, ...hCells, ...vCells, ...innerCells], true);
    }
    function handleSelectionChangeByMouseClickAndMove(event) {
        const cellContext = event.context;
        const activeFocus = contextApi.focusedCell || {
            rowIdent: cellContext.rowContext.identity,
            colIndex: cellContext.index,
        };
        const focusedRowState = contextApi.findRowInCache(activeFocus.rowIdent);
        const hCells = [];
        const vCells = [];
        for (const i of rangeBetween(activeFocus.colIndex, cellContext.index)) {
            hCells.push({ rowIdent: activeFocus.rowIdent, colIndex: i });
        }
        hCells.push({ rowIdent: activeFocus.rowIdent, colIndex: cellContext.index });
        const rowHeight = Math.abs(cellContext.rowContext.dsIndex - focusedRowState.dsIndex);
        const dir = focusedRowState.dsIndex > cellContext.rowContext.dsIndex ? -1 : 1;
        for (let i = 1; i <= rowHeight; i++) {
            const state = contextApi.findRowInCache(activeFocus.rowIdent, dir * i, true);
            vCells.push({ rowIdent: state.identity, colIndex: activeFocus.colIndex });
        }
        const innerCells = getInnerCellsInRect(contextApi, hCells, vCells);
        contextApi.selectCells([activeFocus, ...hCells, ...vCells, ...innerCells], true);
    }
    /**
     * Swap the focus from the source cell to a straight adjacent cell (not diagonal).
     * @param sourceCellRef A point reference to the source cell the direction is relative to
     * @param direction The direction of the new cell.
     * [1 | -1, 0] -> HORIZONTAL
     * [0, 1 | -1] -> VERTICAL
     */
    function handleSingleItemFocus(sourceCellRef, direction) {
        const rowState = contextApi.findRowInCache(sourceCellRef.rowIdent, direction[1], true);
        if (rowState) {
            contextApi.focusCell({ rowIdent: rowState.identity, colIndex: sourceCellRef.colIndex + direction[0] });
        }
    }
    return {
        handleMouseDown,
        handleKeyDown,
        handleSelectionChangeByMouseClickAndMove
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9jdXMtYW5kLXNlbGVjdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvbmdyaWQvdGFyZ2V0LWV2ZW50cy9zcmMvbGliL3RhcmdldC1ldmVudHMvZm9jdXMtYW5kLXNlbGVjdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbkUsT0FBTyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBS3RGLE9BQU8sRUFBRSxXQUFXLEVBQUUsZUFBZSxFQUFFLFlBQVksRUFBRSxtQkFBbUIsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUUxRixNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQTtBQUMzRCxNQUFNLHNCQUFzQixHQUFHLENBQUMsS0FBNkMsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO0FBRTVHLE1BQU0sVUFBVSx1QkFBdUIsQ0FBQyxZQUF3QztJQUM5RSxNQUFNLGVBQWUsR0FBRyxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsS0FBSyxNQUFNLENBQUM7SUFFckUsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBRTlDLG1GQUFtRjtJQUNuRixZQUFZLENBQUMsT0FBTztTQUNqQixJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1NBQzdCLFNBQVMsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUM7SUFFckMsbUVBQW1FO0lBQ25FLFlBQVksQ0FBQyxTQUFTO1NBQ25CLElBQUksQ0FDSCxN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RUFBRSxRQUFRLEVBQUUsUUFBUSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsYUFBYSxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3hHO0lBQ0gsQ0FBQztJQUVELE9BQU87UUFDTCxlQUFlO1FBQ2YsYUFBYTtRQUNiLHdDQUF3QztLQUN6QyxDQUFBO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRha2VVbnRpbCwgc3dpdGNoTWFwLCBmaWx0ZXIsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IExFRlRfQVJST1csIFVQX0FSUk9XLCBSSUdIVF9BUlJPVywgRE9XTl9BUlJPVyB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5cbmltcG9ydCB7IEdyaWREYXRhUG9pbnQgfSBmcm9tICdAcGVidWxhL25ncmlkJztcbmltcG9ydCB7IFBibE5ncmlkUm93RXZlbnQsIFBibE5ncmlkQ2VsbEV2ZW50LCBQYmxOZ3JpZERhdGFDZWxsRXZlbnQgfSBmcm9tICcuL2V2ZW50cyc7XG5pbXBvcnQgeyBQYmxOZ3JpZFRhcmdldEV2ZW50c1BsdWdpbiB9IGZyb20gJy4vdGFyZ2V0LWV2ZW50cy1wbHVnaW4nO1xuaW1wb3J0IHsgaXNDZWxsRXZlbnQsIGlzRGF0YUNlbGxFdmVudCwgcmFuZ2VCZXR3ZWVuLCBnZXRJbm5lckNlbGxzSW5SZWN0IH0gZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IGlzT3N4ID0gL15tYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtLnRvTG93ZXJDYXNlKCkpXG5jb25zdCBpc01haW5Nb3VzZUJ1dHRvbkNsaWNrID0gKGV2ZW50OiBQYmxOZ3JpZERhdGFDZWxsRXZlbnQ8YW55LCBNb3VzZUV2ZW50PikgPT4gZXZlbnQuc291cmNlLmJ1dHRvbiA9PT0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUZvY3VzQW5kU2VsZWN0aW9uKHRhcmdldEV2ZW50czogUGJsTmdyaWRUYXJnZXRFdmVudHNQbHVnaW4pIHtcbiAgY29uc3QgaXNDZWxsRm9jdXNNb2RlID0gKCkgPT4gdGFyZ2V0RXZlbnRzLmdyaWQuZm9jdXNNb2RlID09PSAnY2VsbCc7XG5cbiAgY29uc3QgaGFuZGxlcnMgPSBjcmVhdGVIYW5kbGVycyh0YXJnZXRFdmVudHMpO1xuXG4gIC8vIEhhbmRsZSBhcnJheSBrZXlzIG1vdmUgKHdpdGggc2hpZnQgZm9yIHNlbGVjdGlvbiwgd2l0aG91dCBmb3IgY2VsbCBmb2N1cyBjaGFuZ2UpXG4gIHRhcmdldEV2ZW50cy5rZXlEb3duXG4gICAgLnBpcGUoZmlsdGVyKGlzQ2VsbEZvY3VzTW9kZSkpXG4gICAgLnN1YnNjcmliZShoYW5kbGVycy5oYW5kbGVLZXlEb3duKTtcblxuICAvLyBIYW5kbGUgbW91c2UgZG93biBvbiBjZWxsIChmb2N1cykgYW5kIHRoZW4gbW92aW5nIGZvciBzZWxlY3Rpb24uXG4gIHRhcmdldEV2ZW50cy5tb3VzZURvd25cbiAgICAucGlwZShcbiAgICAgIGZpbHRlcihpc0NlbGxGb2N1c01vZGUpLFxuICAgICAgZmlsdGVyKGlzRGF0YUNlbGxFdmVudCksXG4gICAgICBmaWx0ZXIoaXNNYWluTW91c2VCdXR0b25DbGljayksXG4gICAgICB0YXAoIGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQuc291cmNlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldmVudC5zb3VyY2UucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pLFxuICAgICAgdGFwKGhhbmRsZXJzLmhhbmRsZU1vdXNlRG93biksIC8vIGhhbmRsZSBtb3VzZSBkb3duIGZvY3VzXG4gICAgICBzd2l0Y2hNYXAoICgpID0+IHRhcmdldEV2ZW50cy5jZWxsRW50ZXIucGlwZSh0YWtlVW50aWwodGFyZ2V0RXZlbnRzLm1vdXNlVXApKSApLFxuICAgICAgZmlsdGVyKGlzRGF0YUNlbGxFdmVudCksXG4gICAgICBmaWx0ZXIoaXNNYWluTW91c2VCdXR0b25DbGljaylcbiAgICApXG4gICAgLnN1YnNjcmliZShoYW5kbGVycy5oYW5kbGVTZWxlY3Rpb25DaGFuZ2VCeU1vdXNlQ2xpY2tBbmRNb3ZlKTsgLy8gbm93IGhhbmRsZSBtb3ZlbWVudHMgdW50aWwgbW91c2V1cFxuXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhhbmRsZXJzKHRhcmdldEV2ZW50czogUGJsTmdyaWRUYXJnZXRFdmVudHNQbHVnaW4pIHtcbiAgY29uc3QgeyBjb250ZXh0QXBpIH0gPSB0YXJnZXRFdmVudHMuZ3JpZDtcblxuICBmdW5jdGlvbiBmb2N1c0NlbGwocm93SWRlbnQ6IGFueSwgY29sSW5kZXg6IG51bWJlciwgbWFya0ZvckNoZWNrPzogYm9vbGVhbik6IHZvaWQge1xuICAgIGNvbnRleHRBcGkuZm9jdXNDZWxsKHsgcm93SWRlbnQsIGNvbEluZGV4IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50OiBQYmxOZ3JpZERhdGFDZWxsRXZlbnQ8YW55LCBNb3VzZUV2ZW50Pik6IHZvaWQge1xuICAgIGlmIChjb250ZXh0QXBpLmZvY3VzZWRDZWxsICYmIGV2ZW50LnNvdXJjZS5zaGlmdEtleSkge1xuICAgICAgaGFuZGxlU2VsZWN0aW9uQ2hhbmdlQnlNb3VzZUNsaWNrQW5kTW92ZShldmVudCk7XG4gICAgfSBlbHNlIGlmIChpc09zeCA/IGV2ZW50LnNvdXJjZS5tZXRhS2V5IDogZXZlbnQuc291cmNlLmN0cmxLZXkpIHtcbiAgICAgIGlmIChldmVudC5jb250ZXh0LnNlbGVjdGVkKSB7XG4gICAgICAgIGNvbnRleHRBcGkudW5zZWxlY3RDZWxscyhbIGV2ZW50LmNvbnRleHQgXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0QXBpLnNlbGVjdENlbGxzKFsgZXZlbnQuY29udGV4dCBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9jdXNDZWxsKGV2ZW50LmNvbnRleHQucm93Q29udGV4dC5pZGVudGl0eSwgZXZlbnQuY29udGV4dC5pbmRleCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudDogUGJsTmdyaWRSb3dFdmVudCB8IFBibE5ncmlkQ2VsbEV2ZW50KTogdm9pZCB7XG4gICAgY29uc3Qgc291cmNlOiBLZXlib2FyZEV2ZW50ID0gZXZlbnQuc291cmNlIGFzIGFueTtcbiAgICBpZiAoaXNDZWxsRXZlbnQoZXZlbnQpKSB7XG4gICAgICBjb25zdCBzb3VyY2VDZWxsID0gZXZlbnQuY2VsbFRhcmdldDtcblxuICAgICAgbGV0IGNvZWZmOiAxIHwgLTEgPSAxO1xuICAgICAgbGV0IGlzSG9yaXpvbnRhbCA9IGZhbHNlO1xuXG4gICAgICBzd2l0Y2ggKHNvdXJjZS5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICAgICAgY29lZmYgPSAtMTtcbiAgICAgICAgY2FzZSBET1dOX0FSUk9XOiAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOiBuby1zd2l0Y2gtY2FzZS1mYWxsLXRocm91Z2hcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMRUZUX0FSUk9XOlxuICAgICAgICAgIGNvZWZmID0gLTE7XG4gICAgICAgIGNhc2UgUklHSFRfQVJST1c6IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6IG5vLXN3aXRjaC1jYXNlLWZhbGwtdGhyb3VnaFxuICAgICAgICAgIGlzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBldmVudC5zb3VyY2UucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnNvdXJjZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXG4gICAgICBsZXQgYWN0aXZlRm9jdXM6IEdyaWREYXRhUG9pbnQgPSBjb250ZXh0QXBpLmZvY3VzZWRDZWxsO1xuICAgICAgaWYgKCFhY3RpdmVGb2N1cykge1xuICAgICAgICBjb25zdCBjZWxsQ29udGV4dCA9IGNvbnRleHRBcGkuZ2V0Q2VsbChzb3VyY2VDZWxsKTtcbiAgICAgICAgYWN0aXZlRm9jdXMgPSB7XG4gICAgICAgICAgcm93SWRlbnQ6IGNlbGxDb250ZXh0LnJvd0NvbnRleHQuaWRlbnRpdHksXG4gICAgICAgICAgY29sSW5kZXg6IGNlbGxDb250ZXh0LmluZGV4LFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoISFzb3VyY2Uuc2hpZnRLZXkpIHtcbiAgICAgICAgaGFuZGxlU2VsZWN0aW9uQ2hhbmdlQnlBcnJvd3MoYWN0aXZlRm9jdXMsIGlzSG9yaXpvbnRhbCA/IFtjb2VmZiwgMF0gOiBbMCwgY29lZmZdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZVNpbmdsZUl0ZW1Gb2N1cyhhY3RpdmVGb2N1cywgaXNIb3Jpem9udGFsID8gW2NvZWZmLCAwXSA6IFswLCBjb2VmZl0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBzZWxlY3Rpb24gY2hhbmdlcyBjYXVzZWQgT05MWSBieSB0aGUgdXNlIG9mIHRoZSBhcnJvdyBrZXlzIHdpdGggU0hJRlQga2V5LlxuICAgKlxuICAgKiBUaGUgaW1wbGVtZW50YXRpb24gaXMgTk9UIGluY3JlbWVudGFsLCBpdCB3aWxsIHJlLWNhbGN1bGF0ZSB0aGUgc2VsZWN0ZWQgY2VsbCBvbiBldmVyeSBhcnJvdyBrZXkgcHJlc3MgKGV2ZXJ5IGNhbGwgdG8gdGhpcyBmdW5jdGlvbikuXG4gICAqXG4gICAqIEZpcnN0LiBBIHNpbXBsZSBhZGphY2VudCBjZWxsIGRldGVjdGlvbiBpcyBwZXJmb3JtZWQgdG8gZGV0ZXJtaW5lIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgY2VsbHMgcmVsYXRpdmUgdG8gdGhlXG4gICAqIHNvdXJjZSBjZWxsICh1c3VhbGx5IHRoZSBmb2N1c2VkIGNlbGwpLiBXZSBvbmx5IGNhcmUgYWJvdXQgNCBjZWxscywgYWRqYWNlbnQgdG8gdGhlIHNvdXJjZSBDZWxsOiBUb3AsIExlZnQsIEJvdHRvbSwgUmlnaHRcbiAgICpcbiAgICogICAg4pSCIFQg4pSCXG4gICAqIOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUvOKUgOKUgOKUgFxuICAgKiAgUiDilIIgQyDilIIgTFxuICAgKiDilIDilIDilIDilLzilIDilIDilIDilLzilIDilIDilIBcbiAgICogICAg4pSCIEIg4pSCXG4gICAqXG4gICAqIFdlIGNhbiBvbmx5IGhhdmUgMSBxdWFydGVyIHNlbGVjdGlvbiB3aXRoIEFycm93IHNlbGVjdGlvbiBzbyBpdCBUTCwgVFIsIEJSIG9yIEJMLCBhbnkgb3RoZXIgc2V0dXAgd2lsbCBjbGVhciB0aGUgc2VsZWN0aW9uIGFuZCBzdGFydCBmcm9tIHNjcmF0Y2guXG4gICAqXG4gICAqID4gTm90ZSB0aGF0IHRoZSBsb2dpYyBpbiB0aGlzIGZ1bmN0aW9uIGlzIGZvciB1c2Ugd2l0aCBhcnJvdyBrZXlzICsgU0hJRlQga2V5LCBvdGhlciBzZWxlY3Rpb24gbG9naWNcbiAgICogZG9lcyBub3QgZml0IHRoaXMgc2NlbmFyaW8gKGUuZy4gTU9VU0Ugc2VsZWN0aW9uIG9yIEFSUk9XIEtFWVMgKyBDVFJMIEtFWSBzZWxlY3Rpb24pXG4gICAqXG4gICAqIEBwYXJhbSBzb3VyY2VDZWxsUmVmIEEgcG9pbnQgcmVmZXJlbmNlIHRvIHRoZSBzb3VyY2UgY2VsbCB0aGUgZGlyZWN0aW9uIGlzIHJlbGF0aXZlIHRvXG4gICAqIEBwYXJhbSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiBvZiB0aGUgbmV3IGNlbGwuXG4gICAqIFsxIHwgLTEsIDBdIC0+IEhPUklaT05UQUxcbiAgICogWzAsIDEgfCAtMV0gLT4gVkVSVElDQUxcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZVNlbGVjdGlvbkNoYW5nZUJ5QXJyb3dzKHNvdXJjZUNlbGxSZWY6IEdyaWREYXRhUG9pbnQsIGRpcmVjdGlvbjogWzAsIDEgfCAtMV0gfCBbMSB8IC0xLCAwXSkge1xuICAgIGNvbnN0IHsgcm93SWRlbnQsIGNvbEluZGV4IH0gPSBzb3VyY2VDZWxsUmVmO1xuICAgIGNvbnN0IHNvdXJjZUNlbGxTdGF0ZSA9IGNvbnRleHRBcGkuZmluZFJvd0luQ2FjaGUocm93SWRlbnQpO1xuICAgIGNvbnN0IFttb3ZlSCwgbW92ZVZdID0gZGlyZWN0aW9uO1xuXG4gICAgY29uc3QgaEFkaiA9IFsgc291cmNlQ2VsbFN0YXRlLmNlbGxzW2NvbEluZGV4IC0gMV0sIHNvdXJjZUNlbGxTdGF0ZS5jZWxsc1tjb2xJbmRleCArIDFdIF07XG4gICAgY29uc3QgdkFkaiA9IFsgY29udGV4dEFwaS5maW5kUm93SW5DYWNoZShyb3dJZGVudCwgLTEsIHRydWUpLCBjb250ZXh0QXBpLmZpbmRSb3dJbkNhY2hlKHJvd0lkZW50LCAxLCB0cnVlKSBdO1xuXG4gICAgbGV0IGggPSAoaEFkalswXSAmJiBoQWRqWzBdLnNlbGVjdGVkID8gLTEgOiAwKSArIChoQWRqWzFdICYmIGhBZGpbMV0uc2VsZWN0ZWQgPyAxIDogMCk7XG4gICAgbGV0IHYgPSAodkFkalswXSAmJiB2QWRqWzBdLmNlbGxzW2NvbEluZGV4XS5zZWxlY3RlZCA/IC0xIDogMCkgKyAodkFkalsxXSAmJiB2QWRqWzFdLmNlbGxzW2NvbEluZGV4XS5zZWxlY3RlZCA/IDEgOiAwKTtcblxuICAgIGlmIChoID09PSAwKSB7XG4gICAgICBoICs9IG1vdmVIO1xuICAgIH1cbiAgICBpZiAodiA9PT0gMCkge1xuICAgICAgdiArPSBtb3ZlVjtcbiAgICB9XG5cbiAgICBjb25zdCBoQ2VsbHM6IEdyaWREYXRhUG9pbnRbXSA9IFtdO1xuICAgIGlmIChoICE9PSAwKSB7XG4gICAgICBsZXQgaENvbnRleHRJbmRleCA9IGNvbEluZGV4O1xuICAgICAgbGV0IGhDb250ZXh0ID0gc291cmNlQ2VsbFN0YXRlLmNlbGxzW2NvbEluZGV4XTtcbiAgICAgIHdoaWxlIChoQ29udGV4dCAmJiBoQ29udGV4dC5zZWxlY3RlZCkge1xuICAgICAgICBoQ2VsbHMucHVzaCh7IHJvd0lkZW50LCBjb2xJbmRleDogaENvbnRleHRJbmRleCB9KTtcbiAgICAgICAgaENvbnRleHRJbmRleCArPSBoO1xuICAgICAgICBoQ29udGV4dCA9IHNvdXJjZUNlbGxTdGF0ZS5jZWxsc1toQ29udGV4dEluZGV4XTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vdmVIKSB7XG4gICAgICAgIGlmIChoID09PSBtb3ZlSCkge1xuICAgICAgICAgIGlmIChoQ29udGV4dCkge1xuICAgICAgICAgICAgaENlbGxzLnB1c2goeyByb3dJZGVudCwgY29sSW5kZXg6IGhDb250ZXh0SW5kZXggfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhDZWxscy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHZDZWxsczogR3JpZERhdGFQb2ludFtdID0gWyBdO1xuICAgIGlmICh2ICE9PSAwKSB7XG4gICAgICBsZXQgdkNvbnRleHRJZGVudCA9IHJvd0lkZW50O1xuICAgICAgbGV0IHZDb250ZXh0ID0gY29udGV4dEFwaS5maW5kUm93SW5DYWNoZSh2Q29udGV4dElkZW50LCB2LCB0cnVlKTtcbiAgICAgIHdoaWxlICh2Q29udGV4dCAmJiB2Q29udGV4dC5jZWxsc1tjb2xJbmRleF0uc2VsZWN0ZWQpIHtcbiAgICAgICAgdkNvbnRleHRJZGVudCA9IHZDb250ZXh0LmlkZW50aXR5O1xuICAgICAgICB2Q2VsbHMucHVzaCh7IHJvd0lkZW50OiB2Q29udGV4dElkZW50LCBjb2xJbmRleCB9KTtcbiAgICAgICAgdkNvbnRleHQgPSBjb250ZXh0QXBpLmZpbmRSb3dJbkNhY2hlKHZDb250ZXh0SWRlbnQsIHYsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobW92ZVYpIHtcbiAgICAgICAgaWYgKHYgPT09IG1vdmVWKSB7XG4gICAgICAgICAgaWYgKHZDb250ZXh0KSB7XG4gICAgICAgICAgICB2Q2VsbHMucHVzaCh7IHJvd0lkZW50OiB2Q29udGV4dC5pZGVudGl0eSwgY29sSW5kZXggfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZDZWxscy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgY29uc3QgaW5uZXJDZWxscyA9IGdldElubmVyQ2VsbHNJblJlY3QoY29udGV4dEFwaSwgaENlbGxzLCB2Q2VsbHMpO1xuICAgIGNvbnRleHRBcGkuc2VsZWN0Q2VsbHMoWyBzb3VyY2VDZWxsUmVmLCAuLi5oQ2VsbHMsIC4uLnZDZWxscywgLi4uaW5uZXJDZWxscyBdLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVNlbGVjdGlvbkNoYW5nZUJ5TW91c2VDbGlja0FuZE1vdmUoZXZlbnQ6IFBibE5ncmlkRGF0YUNlbGxFdmVudDxhbnksIE1vdXNlRXZlbnQ+KSB7XG4gICAgY29uc3QgY2VsbENvbnRleHQgPSBldmVudC5jb250ZXh0O1xuICAgIGNvbnN0IGFjdGl2ZUZvY3VzID0gY29udGV4dEFwaS5mb2N1c2VkQ2VsbCB8fCB7XG4gICAgICByb3dJZGVudDogY2VsbENvbnRleHQucm93Q29udGV4dC5pZGVudGl0eSxcbiAgICAgIGNvbEluZGV4OiBjZWxsQ29udGV4dC5pbmRleCxcbiAgICB9O1xuICAgIGNvbnN0IGZvY3VzZWRSb3dTdGF0ZSA9IGNvbnRleHRBcGkuZmluZFJvd0luQ2FjaGUoYWN0aXZlRm9jdXMucm93SWRlbnQpO1xuXG4gICAgY29uc3QgaENlbGxzOiBHcmlkRGF0YVBvaW50W10gPSBbXTtcbiAgICBjb25zdCB2Q2VsbHM6IEdyaWREYXRhUG9pbnRbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBpIG9mIHJhbmdlQmV0d2VlbihhY3RpdmVGb2N1cy5jb2xJbmRleCwgY2VsbENvbnRleHQuaW5kZXgpKSB7XG4gICAgICBoQ2VsbHMucHVzaCh7IHJvd0lkZW50OiBhY3RpdmVGb2N1cy5yb3dJZGVudCwgY29sSW5kZXg6IGkgfSk7XG4gICAgfVxuICAgIGhDZWxscy5wdXNoKHsgcm93SWRlbnQ6IGFjdGl2ZUZvY3VzLnJvd0lkZW50LCBjb2xJbmRleDogY2VsbENvbnRleHQuaW5kZXggfSk7XG5cbiAgICBjb25zdCByb3dIZWlnaHQgPSBNYXRoLmFicyhjZWxsQ29udGV4dC5yb3dDb250ZXh0LmRzSW5kZXggLSBmb2N1c2VkUm93U3RhdGUuZHNJbmRleCk7XG4gICAgY29uc3QgZGlyID0gZm9jdXNlZFJvd1N0YXRlLmRzSW5kZXggPiBjZWxsQ29udGV4dC5yb3dDb250ZXh0LmRzSW5kZXggPyAtMSA6IDE7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gcm93SGVpZ2h0OyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gY29udGV4dEFwaS5maW5kUm93SW5DYWNoZShhY3RpdmVGb2N1cy5yb3dJZGVudCwgZGlyICogaSwgdHJ1ZSk7XG4gICAgICB2Q2VsbHMucHVzaCh7IHJvd0lkZW50OiBzdGF0ZS5pZGVudGl0eSwgY29sSW5kZXg6IGFjdGl2ZUZvY3VzLmNvbEluZGV4IH0pO1xuICAgIH1cbiAgICBjb25zdCBpbm5lckNlbGxzID0gZ2V0SW5uZXJDZWxsc0luUmVjdChjb250ZXh0QXBpLCBoQ2VsbHMsIHZDZWxscyk7XG4gICAgY29udGV4dEFwaS5zZWxlY3RDZWxscyhbIGFjdGl2ZUZvY3VzLCAuLi5oQ2VsbHMsIC4uLnZDZWxscywgLi4uaW5uZXJDZWxscyBdLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2FwIHRoZSBmb2N1cyBmcm9tIHRoZSBzb3VyY2UgY2VsbCB0byBhIHN0cmFpZ2h0IGFkamFjZW50IGNlbGwgKG5vdCBkaWFnb25hbCkuXG4gICAqIEBwYXJhbSBzb3VyY2VDZWxsUmVmIEEgcG9pbnQgcmVmZXJlbmNlIHRvIHRoZSBzb3VyY2UgY2VsbCB0aGUgZGlyZWN0aW9uIGlzIHJlbGF0aXZlIHRvXG4gICAqIEBwYXJhbSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiBvZiB0aGUgbmV3IGNlbGwuXG4gICAqIFsxIHwgLTEsIDBdIC0+IEhPUklaT05UQUxcbiAgICogWzAsIDEgfCAtMV0gLT4gVkVSVElDQUxcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZVNpbmdsZUl0ZW1Gb2N1cyhzb3VyY2VDZWxsUmVmOiBHcmlkRGF0YVBvaW50LCBkaXJlY3Rpb246IFswLCAxIHwgLTFdIHwgWzEgfCAtMSwgMF0pIHtcbiAgICBjb25zdCByb3dTdGF0ZSA9IGNvbnRleHRBcGkuZmluZFJvd0luQ2FjaGUoc291cmNlQ2VsbFJlZi5yb3dJZGVudCwgZGlyZWN0aW9uWzFdLCB0cnVlKTtcbiAgICBpZiAocm93U3RhdGUpIHtcbiAgICAgIGNvbnRleHRBcGkuZm9jdXNDZWxsKHsgcm93SWRlbnQ6IHJvd1N0YXRlLmlkZW50aXR5LCBjb2xJbmRleDogc291cmNlQ2VsbFJlZi5jb2xJbmRleCArIGRpcmVjdGlvblswXSB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGhhbmRsZU1vdXNlRG93bixcbiAgICBoYW5kbGVLZXlEb3duLFxuICAgIGhhbmRsZVNlbGVjdGlvbkNoYW5nZUJ5TW91c2VDbGlja0FuZE1vdmVcbiAgfVxufVxuXG4iXX0=