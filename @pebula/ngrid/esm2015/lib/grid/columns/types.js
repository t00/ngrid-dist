/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
export function PblColumnTypeDefinitionDataMap() { }
/**
 * Optional value to be used by the template when rendering the cell.
 * Any value is allowed, including functions which allow complex scenarios, for example rendering a cell based on values from other cells.
 * @record
 */
export function PblBaseColumnDefinition() { }
if (false) {
    /**
     * A Unique ID for the column.
     * The ID must be unique across all columns, regardless of the type.
     * Columns with identical ID will share result in identical template.
     *
     * For example, having a header column and a footer column with the same id will result in the same cell presentation for both.
     *
     * > The ID is mandatory. Some implementation might use other values to auto-generate it and some might require it explicitly.
     * This is what it is optional.
     * @type {?|undefined}
     */
    PblBaseColumnDefinition.prototype.id;
    /** @type {?|undefined} */
    PblBaseColumnDefinition.prototype.label;
    /**
     * The type of the values in this column.
     * This is an additional level for matching columns to templates, grouping templates for a type.
     * @type {?|undefined}
     */
    PblBaseColumnDefinition.prototype.type;
    /**
     * CSS class that get applied on the header and cell.
     * You can apply unique header/cell styles using the element name.
     * @type {?|undefined}
     */
    PblBaseColumnDefinition.prototype.css;
    /**
     * The width in px or % in the following format: ##% or ##px
     * Examples: '50%', '50px'
     * @type {?|undefined}
     */
    PblBaseColumnDefinition.prototype.width;
    /**
     * This minimum width in pixels
     * This is an absolute value, thus a number.
     * @type {?|undefined}
     */
    PblBaseColumnDefinition.prototype.minWidth;
    /**
     * This maximum width in pixels
     * This is an absolute value, thus a number.
     * @type {?|undefined}
     */
    PblBaseColumnDefinition.prototype.maxWidth;
    /**
     * A place to store things...
     * This must be an object, values are shadow-copied so persist data between multiple plugins.
     * @type {?|undefined}
     */
    PblBaseColumnDefinition.prototype.data;
}
/**
 * @record
 */
export function PblMetaColumnDefinition() { }
if (false) {
    /**
     * A Unique ID for the column.
     * @type {?}
     */
    PblMetaColumnDefinition.prototype.id;
    /** @type {?} */
    PblMetaColumnDefinition.prototype.kind;
    /**
     * The index (zero based) of the header row this column is attached to, used for multi-header setup.
     * When not set (undefined) the index is considered the LAST index.
     * @type {?}
     */
    PblMetaColumnDefinition.prototype.rowIndex;
}
/**
 * @record
 */
export function PblColumnGroupDefinition() { }
if (false) {
    /**
     * A Unique ID for the column.
     * Auto-generated from the property
     * @type {?|undefined}
     */
    PblColumnGroupDefinition.prototype.id;
    /**
     * The index (zero based) of the header row this header group column is attached to, used for multi-header setup.
     * @type {?}
     */
    PblColumnGroupDefinition.prototype.rowIndex;
    /**
     * The grid's column that is the first child column for this group.
     * @type {?}
     */
    PblColumnGroupDefinition.prototype.prop;
    /**
     * The total span of the group (excluding the first child - i.e. prop).
     * The span and prop are used to get the child columns of this group.
     * The span is not dynamic, once the columns are set they don't change.
     *
     * For example, if a we have a span of 2 and the column at the 2nd position is hidden it will still count as
     * being spanned although the UI will span only 1 column... (because the 2nd is hidden...)
     * @type {?}
     */
    PblColumnGroupDefinition.prototype.span;
}
/**
 * @record
 */
export function PblColumnDefinition() { }
if (false) {
    /**
     * A Unique ID for the column.
     * Whe not set (recommend) it is auto-generated by concatenating the values of `prop` and ,
     * If you set this value manually, make sure it does not conflict with other columns!
     * @type {?|undefined}
     */
    PblColumnDefinition.prototype.id;
    /**
     * When set, defines this column as the primary index of the data-set with all values in this column being unique.
     * @type {?|undefined}
     */
    PblColumnDefinition.prototype.pIndex;
    /**
     * The property to display (from the row element)
     * You can use dot notation to display deep paths.
     * @type {?}
     */
    PblColumnDefinition.prototype.prop;
    /** @type {?|undefined} */
    PblColumnDefinition.prototype.headerType;
    /** @type {?|undefined} */
    PblColumnDefinition.prototype.footerType;
    /**
     * A path to a nested object, relative to the row element.
     * The grid will display `prop` from the object referenced by `path`.
     *
     * You can also use dot notation directly from `prop`.
     *
     * Example:
     * prop: "street"
     * path: [ "myInstance", "user", "address"
     *
     * is identical to:
     * prop: "myInstance.user.address.street"
     *
     * @type {?|undefined}
     */
    PblColumnDefinition.prototype.path;
    /** @type {?|undefined} */
    PblColumnDefinition.prototype.sort;
    /**
     * A custom predicate function to filter rows using the current column.
     *
     * Valid only when filtering by value.
     * See `PblDataSource.setFilter` for more information.
     * @type {?|undefined}
     */
    PblColumnDefinition.prototype.filter;
    /**
     * Indicates if the grid is editable or not.
     * Note that an editable also requires an edit template to qualify as editable, this flag alone is not enough.
     * @type {?|undefined}
     */
    PblColumnDefinition.prototype.editable;
    /** @type {?|undefined} */
    PblColumnDefinition.prototype.pin;
    /**
     * @deprecated BREAKING CHANGE 1.0.0 - Use `alias` instead.
     * @type {?|undefined}
     */
    PblColumnDefinition.prototype.sortAlias;
    /**
     * An alias used to identify the column.
     * Useful when the server provides sort/filter metadata that does not have a 1:1 match with the column names.
     * e.g. Deep path props, property name convention mismatch, etc...
     * @type {?|undefined}
     */
    PblColumnDefinition.prototype.alias;
    /**
     * Optional transformer that control the value output from the combination of a column and a row.
     * The value returned from this transformer will be returned from `PblColumn.getValue`
     * @type {?|undefined}
     */
    PblColumnDefinition.prototype.transform;
}
/**
 * @record
 */
export function PblMetaRowDefinitions() { }
if (false) {
    /** @type {?|undefined} */
    PblMetaRowDefinitions.prototype.rowClassName;
    /** @type {?|undefined} */
    PblMetaRowDefinitions.prototype.type;
}
/**
 * Represent a list of meta column's that together form a META ROW.
 * In other words, this is the definition of a row, using it's building blocks - the columns.
 *
 * > A row in the grid represents a row in the datasource, A **meta row** does not, it can represent anything.
 * Meta rows are header, footer and header group.
 * @record
 * @template T
 */
export function PblColumnSet() { }
if (false) {
    /** @type {?} */
    PblColumnSet.prototype.rowIndex;
    /** @type {?} */
    PblColumnSet.prototype.cols;
}
/**
 * Represent a complete column definition set for a grid. (table, header, footer and headerGroup columns).
 *
 * `PblNgridColumnDefinitionSet` contains POJO objects (simple JSON like objects) for each column type (`PblColumnDefinition`, `PblMetaColumnDefinition` and `PblColumnGroupDefinition`)
 * which are later used to create runtime instance for each column type (`PblColumn`, `PblMetaColumn` and `PblColumnGroup`)
 *
 * Because `PblNgridColumnDefinitionSet` contains POJO objects it can be serialized easily.
 * @record
 */
export function PblNgridColumnDefinitionSet() { }
if (false) {
    /** @type {?} */
    PblNgridColumnDefinitionSet.prototype.table;
    /** @type {?} */
    PblNgridColumnDefinitionSet.prototype.header;
    /** @type {?} */
    PblNgridColumnDefinitionSet.prototype.footer;
    /** @type {?} */
    PblNgridColumnDefinitionSet.prototype.headerGroup;
}
/**
 * Represent a complete column set for a grid. (table, header, footer and headerGroup columns).
 *
 * `PblNgridColumnSet` contains runtime instances of for each column type (`PblColumn`, `PblMetaColumn` and `PblColumnGroup`)
 * which
 * @record
 */
export function PblNgridColumnSet() { }
if (false) {
    /** @type {?} */
    PblNgridColumnSet.prototype.table;
    /** @type {?} */
    PblNgridColumnSet.prototype.header;
    /** @type {?} */
    PblNgridColumnSet.prototype.footer;
    /** @type {?} */
    PblNgridColumnSet.prototype.headerGroup;
    /** @type {?} */
    PblNgridColumnSet.prototype.groupStore;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AcGVidWxhL25ncmlkLyIsInNvdXJjZXMiOlsibGliL2dyaWQvY29sdW1ucy90eXBlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBUUEsb0RBRUM7Ozs7OztBQWVELDZDQStDQzs7Ozs7Ozs7Ozs7OztJQXBDQyxxQ0FBWTs7SUFDWix3Q0FBZTs7Ozs7O0lBTWYsdUNBQXdDOzs7Ozs7SUFNeEMsc0NBQWE7Ozs7OztJQU1iLHdDQUFlOzs7Ozs7SUFLZiwyQ0FBa0I7Ozs7OztJQUtsQiwyQ0FBa0I7Ozs7OztJQU1sQix1Q0FBVzs7Ozs7QUFHYiw2Q0FhQzs7Ozs7O0lBVEMscUNBQVc7O0lBRVgsdUNBQTBCOzs7Ozs7SUFNMUIsMkNBQWlCOzs7OztBQUduQiw4Q0F5QkM7Ozs7Ozs7SUFwQkMsc0NBQVk7Ozs7O0lBS1osNENBQWlCOzs7OztJQUlqQix3Q0FBYTs7Ozs7Ozs7OztJQVViLHdDQUFhOzs7OztBQUdmLHlDQXdFQzs7Ozs7Ozs7SUFsRUMsaUNBQVk7Ozs7O0lBS1oscUNBQWlCOzs7Ozs7SUFNakIsbUNBQWE7O0lBRWIseUNBQThDOztJQUM5Qyx5Q0FBOEM7Ozs7Ozs7Ozs7Ozs7Ozs7SUFnQjlDLG1DQUFnQjs7SUFFaEIsbUNBQWdDOzs7Ozs7OztJQVFoQyxxQ0FBbUM7Ozs7OztJQU1uQyx1Q0FBbUI7O0lBRW5CLGtDQUFzQjs7Ozs7SUFJdEIsd0NBQW1COzs7Ozs7O0lBT25CLG9DQUFlOzs7Ozs7SUFNZix3Q0FBNEQ7Ozs7O0FBRzlELDJDQUdDOzs7SUFGQyw2Q0FBc0I7O0lBQ3RCLHFDQUFrQzs7Ozs7Ozs7Ozs7QUFTcEMsa0NBR0M7OztJQUZDLGdDQUFpQjs7SUFDakIsNEJBQVU7Ozs7Ozs7Ozs7O0FBV1osaURBU0M7OztJQVJDLDRDQUlFOztJQUNGLDZDQUFnRDs7SUFDaEQsNkNBQWdEOztJQUNoRCxrREFBc0Q7Ozs7Ozs7OztBQVN4RCx1Q0FVQzs7O0lBVEMsa0NBSUU7O0lBQ0YsbUNBQXNDOztJQUN0QyxtQ0FBc0M7O0lBQ3RDLHdDQUE0Qzs7SUFDNUMsdUNBQWdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGF0YVNvdXJjZUNvbHVtblByZWRpY2F0ZSwgUGJsTmdyaWRTb3J0ZXIgfSBmcm9tICcuLi8uLi9kYXRhLXNvdXJjZS90eXBlcyc7XG5pbXBvcnQgeyBQYmxNZXRhQ29sdW1uIH0gZnJvbSAnLi9tZXRhLWNvbHVtbic7XG5pbXBvcnQgeyBQYmxDb2x1bW4gfSBmcm9tICcuL2NvbHVtbic7XG5pbXBvcnQgeyBQYmxDb2x1bW5Hcm91cCwgUGJsQ29sdW1uR3JvdXBTdG9yZSB9IGZyb20gJy4vZ3JvdXAtY29sdW1uJztcblxuZXhwb3J0IHR5cGUgTUVUQV9DT0xVTU5fVFlQRVMgPSAnaGVhZGVyJyB8ICdoZWFkZXJHcm91cCcgfCAnZm9vdGVyJztcbmV4cG9ydCB0eXBlIENPTFVNTl9UWVBFUyA9IE1FVEFfQ09MVU1OX1RZUEVTIHwgJ3RhYmxlJztcblxuZXhwb3J0IGludGVyZmFjZSBQYmxDb2x1bW5UeXBlRGVmaW5pdGlvbkRhdGFNYXAge1xuICBbdHlwZU5hbWU6IHN0cmluZ106IGFueTtcbn1cblxuZXhwb3J0IHR5cGUgUGJsQ29sdW1uVHlwZURlZmluaXRpb248UCBleHRlbmRzIGtleW9mIFBibENvbHVtblR5cGVEZWZpbml0aW9uRGF0YU1hcCA9IGFueT4gPSB7IG5hbWU6IFA7IGRhdGE/OiBQYmxDb2x1bW5UeXBlRGVmaW5pdGlvbkRhdGFNYXBbUF0gfTtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIHZhbHVlcyBpbiB0aGlzIGNvbHVtbi5cbiAgICogVGhpcyBpcyBhbiBhZGRpdGlvbmFsIGxldmVsIGZvciBtYXRjaGluZyBjb2x1bW5zIHRvIHRlbXBsYXRlcywgZ3JvdXBpbmcgdGVtcGxhdGVzIGZvciBhIHR5cGUuXG4gICAqL1xuICAvLyB0eXBlOiBzdHJpbmcgfCA7XG4gIC8qKlxuICAgKiBPcHRpb25hbCB2YWx1ZSB0byBiZSB1c2VkIGJ5IHRoZSB0ZW1wbGF0ZSB3aGVuIHJlbmRlcmluZyB0aGUgY2VsbC5cbiAgICogQW55IHZhbHVlIGlzIGFsbG93ZWQsIGluY2x1ZGluZyBmdW5jdGlvbnMgd2hpY2ggYWxsb3cgY29tcGxleCBzY2VuYXJpb3MsIGZvciBleGFtcGxlIHJlbmRlcmluZyBhIGNlbGwgYmFzZWQgb24gdmFsdWVzIGZyb20gb3RoZXIgY2VsbHMuXG4gICAqL1xuICAvLyB0eXBlRGF0YT86IGFueTtcblxuZXhwb3J0IGludGVyZmFjZSBQYmxCYXNlQ29sdW1uRGVmaW5pdGlvbiB7XG4gIC8qKlxuICAgKiBBIFVuaXF1ZSBJRCBmb3IgdGhlIGNvbHVtbi5cbiAgICogVGhlIElEIG11c3QgYmUgdW5pcXVlIGFjcm9zcyBhbGwgY29sdW1ucywgcmVnYXJkbGVzcyBvZiB0aGUgdHlwZS5cbiAgICogQ29sdW1ucyB3aXRoIGlkZW50aWNhbCBJRCB3aWxsIHNoYXJlIHJlc3VsdCBpbiBpZGVudGljYWwgdGVtcGxhdGUuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBoYXZpbmcgYSBoZWFkZXIgY29sdW1uIGFuZCBhIGZvb3RlciBjb2x1bW4gd2l0aCB0aGUgc2FtZSBpZCB3aWxsIHJlc3VsdCBpbiB0aGUgc2FtZSBjZWxsIHByZXNlbnRhdGlvbiBmb3IgYm90aC5cbiAgICpcbiAgICogPiBUaGUgSUQgaXMgbWFuZGF0b3J5LiBTb21lIGltcGxlbWVudGF0aW9uIG1pZ2h0IHVzZSBvdGhlciB2YWx1ZXMgdG8gYXV0by1nZW5lcmF0ZSBpdCBhbmQgc29tZSBtaWdodCByZXF1aXJlIGl0IGV4cGxpY2l0bHkuXG4gICAqIFRoaXMgaXMgd2hhdCBpdCBpcyBvcHRpb25hbC5cbiAgICovXG4gIGlkPzogc3RyaW5nO1xuICBsYWJlbD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIHZhbHVlcyBpbiB0aGlzIGNvbHVtbi5cbiAgICogVGhpcyBpcyBhbiBhZGRpdGlvbmFsIGxldmVsIGZvciBtYXRjaGluZyBjb2x1bW5zIHRvIHRlbXBsYXRlcywgZ3JvdXBpbmcgdGVtcGxhdGVzIGZvciBhIHR5cGUuXG4gICAqL1xuICB0eXBlPzogc3RyaW5nIHwgUGJsQ29sdW1uVHlwZURlZmluaXRpb247XG5cbiAgLyoqXG4gICAqIENTUyBjbGFzcyB0aGF0IGdldCBhcHBsaWVkIG9uIHRoZSBoZWFkZXIgYW5kIGNlbGwuXG4gICAqIFlvdSBjYW4gYXBwbHkgdW5pcXVlIGhlYWRlci9jZWxsIHN0eWxlcyB1c2luZyB0aGUgZWxlbWVudCBuYW1lLlxuICAgKi9cbiAgY3NzPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgd2lkdGggaW4gcHggb3IgJSBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDogIyMlIG9yICMjcHhcbiAgICogRXhhbXBsZXM6ICc1MCUnLCAnNTBweCdcbiAgICovXG4gIHdpZHRoPzogc3RyaW5nO1xuICAvKipcbiAgICogVGhpcyBtaW5pbXVtIHdpZHRoIGluIHBpeGVsc1xuICAgKiBUaGlzIGlzIGFuIGFic29sdXRlIHZhbHVlLCB0aHVzIGEgbnVtYmVyLlxuICAgKi9cbiAgbWluV2lkdGg/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBUaGlzIG1heGltdW0gd2lkdGggaW4gcGl4ZWxzXG4gICAqIFRoaXMgaXMgYW4gYWJzb2x1dGUgdmFsdWUsIHRodXMgYSBudW1iZXIuXG4gICAqL1xuICBtYXhXaWR0aD86IG51bWJlcjtcblxuICAvKipcbiAgICogQSBwbGFjZSB0byBzdG9yZSB0aGluZ3MuLi5cbiAgICogVGhpcyBtdXN0IGJlIGFuIG9iamVjdCwgdmFsdWVzIGFyZSBzaGFkb3ctY29waWVkIHNvIHBlcnNpc3QgZGF0YSBiZXR3ZWVuIG11bHRpcGxlIHBsdWdpbnMuXG4gICAqL1xuICBkYXRhPzogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBibE1ldGFDb2x1bW5EZWZpbml0aW9uIGV4dGVuZHMgUGJsQmFzZUNvbHVtbkRlZmluaXRpb24ge1xuICAvKipcbiAgICogQSBVbmlxdWUgSUQgZm9yIHRoZSBjb2x1bW4uXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIGtpbmQ6ICdoZWFkZXInIHwgJ2Zvb3Rlcic7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCAoemVybyBiYXNlZCkgb2YgdGhlIGhlYWRlciByb3cgdGhpcyBjb2x1bW4gaXMgYXR0YWNoZWQgdG8sIHVzZWQgZm9yIG11bHRpLWhlYWRlciBzZXR1cC5cbiAgICogV2hlbiBub3Qgc2V0ICh1bmRlZmluZWQpIHRoZSBpbmRleCBpcyBjb25zaWRlcmVkIHRoZSBMQVNUIGluZGV4LlxuICAgKi9cbiAgcm93SW5kZXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYmxDb2x1bW5Hcm91cERlZmluaXRpb24gZXh0ZW5kcyBQYmxCYXNlQ29sdW1uRGVmaW5pdGlvbiB7XG4gIC8qKlxuICAgKiBBIFVuaXF1ZSBJRCBmb3IgdGhlIGNvbHVtbi5cbiAgICogQXV0by1nZW5lcmF0ZWQgZnJvbSB0aGUgcHJvcGVydHlcbiAgICovXG4gIGlkPzogc3RyaW5nO1xuXG4gICAvKipcbiAgICogVGhlIGluZGV4ICh6ZXJvIGJhc2VkKSBvZiB0aGUgaGVhZGVyIHJvdyB0aGlzIGhlYWRlciBncm91cCBjb2x1bW4gaXMgYXR0YWNoZWQgdG8sIHVzZWQgZm9yIG11bHRpLWhlYWRlciBzZXR1cC5cbiAgICovXG4gIHJvd0luZGV4OiBudW1iZXI7XG4gIC8qKlxuICAgKiBUaGUgZ3JpZCdzIGNvbHVtbiB0aGF0IGlzIHRoZSBmaXJzdCBjaGlsZCBjb2x1bW4gZm9yIHRoaXMgZ3JvdXAuXG4gICAqL1xuICBwcm9wOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3RhbCBzcGFuIG9mIHRoZSBncm91cCAoZXhjbHVkaW5nIHRoZSBmaXJzdCBjaGlsZCAtIGkuZS4gcHJvcCkuXG4gICAqIFRoZSBzcGFuIGFuZCBwcm9wIGFyZSB1c2VkIHRvIGdldCB0aGUgY2hpbGQgY29sdW1ucyBvZiB0aGlzIGdyb3VwLlxuICAgKiBUaGUgc3BhbiBpcyBub3QgZHluYW1pYywgb25jZSB0aGUgY29sdW1ucyBhcmUgc2V0IHRoZXkgZG9uJ3QgY2hhbmdlLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgYSB3ZSBoYXZlIGEgc3BhbiBvZiAyIGFuZCB0aGUgY29sdW1uIGF0IHRoZSAybmQgcG9zaXRpb24gaXMgaGlkZGVuIGl0IHdpbGwgc3RpbGwgY291bnQgYXNcbiAgICogYmVpbmcgc3Bhbm5lZCBhbHRob3VnaCB0aGUgVUkgd2lsbCBzcGFuIG9ubHkgMSBjb2x1bW4uLi4gKGJlY2F1c2UgdGhlIDJuZCBpcyBoaWRkZW4uLi4pXG4gICAqL1xuICBzcGFuOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGJsQ29sdW1uRGVmaW5pdGlvbiBleHRlbmRzIFBibEJhc2VDb2x1bW5EZWZpbml0aW9uIHtcbiAgLyoqXG4gICAqIEEgVW5pcXVlIElEIGZvciB0aGUgY29sdW1uLlxuICAgKiBXaGUgbm90IHNldCAocmVjb21tZW5kKSBpdCBpcyBhdXRvLWdlbmVyYXRlZCBieSBjb25jYXRlbmF0aW5nIHRoZSB2YWx1ZXMgb2YgYHByb3BgIGFuZCAsXG4gICAqIElmIHlvdSBzZXQgdGhpcyB2YWx1ZSBtYW51YWxseSwgbWFrZSBzdXJlIGl0IGRvZXMgbm90IGNvbmZsaWN0IHdpdGggb3RoZXIgY29sdW1ucyFcbiAgICovXG4gIGlkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGVuIHNldCwgZGVmaW5lcyB0aGlzIGNvbHVtbiBhcyB0aGUgcHJpbWFyeSBpbmRleCBvZiB0aGUgZGF0YS1zZXQgd2l0aCBhbGwgdmFsdWVzIGluIHRoaXMgY29sdW1uIGJlaW5nIHVuaXF1ZS5cbiAgICovXG4gIHBJbmRleD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBwcm9wZXJ0eSB0byBkaXNwbGF5IChmcm9tIHRoZSByb3cgZWxlbWVudClcbiAgICogWW91IGNhbiB1c2UgZG90IG5vdGF0aW9uIHRvIGRpc3BsYXkgZGVlcCBwYXRocy5cbiAgICovXG4gIHByb3A6IHN0cmluZztcblxuICBoZWFkZXJUeXBlPzogc3RyaW5nIHwgUGJsQ29sdW1uVHlwZURlZmluaXRpb247XG4gIGZvb3RlclR5cGU/OiBzdHJpbmcgfCBQYmxDb2x1bW5UeXBlRGVmaW5pdGlvbjtcblxuICAvKipcbiAgICogQSBwYXRoIHRvIGEgbmVzdGVkIG9iamVjdCwgcmVsYXRpdmUgdG8gdGhlIHJvdyBlbGVtZW50LlxuICAgKiBUaGUgZ3JpZCB3aWxsIGRpc3BsYXkgYHByb3BgIGZyb20gdGhlIG9iamVjdCByZWZlcmVuY2VkIGJ5IGBwYXRoYC5cbiAgICpcbiAgICogWW91IGNhbiBhbHNvIHVzZSBkb3Qgbm90YXRpb24gZGlyZWN0bHkgZnJvbSBgcHJvcGAuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqIHByb3A6IFwic3RyZWV0XCJcbiAgICogcGF0aDogWyBcIm15SW5zdGFuY2VcIiwgXCJ1c2VyXCIsIFwiYWRkcmVzc1wiXG4gICAqXG4gICAqIGlzIGlkZW50aWNhbCB0bzpcbiAgICogcHJvcDogXCJteUluc3RhbmNlLnVzZXIuYWRkcmVzcy5zdHJlZXRcIlxuICAgKlxuICAgKi9cbiAgcGF0aD86IHN0cmluZ1tdO1xuXG4gIHNvcnQ/OiBib29sZWFuIHwgUGJsTmdyaWRTb3J0ZXI7XG5cbiAgLyoqXG4gICAqIEEgY3VzdG9tIHByZWRpY2F0ZSBmdW5jdGlvbiB0byBmaWx0ZXIgcm93cyB1c2luZyB0aGUgY3VycmVudCBjb2x1bW4uXG4gICAqXG4gICAqIFZhbGlkIG9ubHkgd2hlbiBmaWx0ZXJpbmcgYnkgdmFsdWUuXG4gICAqIFNlZSBgUGJsRGF0YVNvdXJjZS5zZXRGaWx0ZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgZmlsdGVyPzogRGF0YVNvdXJjZUNvbHVtblByZWRpY2F0ZTtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHRoZSBncmlkIGlzIGVkaXRhYmxlIG9yIG5vdC5cbiAgICogTm90ZSB0aGF0IGFuIGVkaXRhYmxlIGFsc28gcmVxdWlyZXMgYW4gZWRpdCB0ZW1wbGF0ZSB0byBxdWFsaWZ5IGFzIGVkaXRhYmxlLCB0aGlzIGZsYWcgYWxvbmUgaXMgbm90IGVub3VnaC5cbiAgICovXG4gIGVkaXRhYmxlPzogYm9vbGVhbjtcblxuICBwaW4/OiAnc3RhcnQnIHwgJ2VuZCc7XG5cbiAgLy8gVE9ETygxLjAuMCk6IHJlbW92ZVxuICAvKiogQGRlcHJlY2F0ZWQgQlJFQUtJTkcgQ0hBTkdFIDEuMC4wIC0gVXNlIGBhbGlhc2AgaW5zdGVhZC4gKi9cbiAgc29ydEFsaWFzPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbiBhbGlhcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBjb2x1bW4uXG4gICAqIFVzZWZ1bCB3aGVuIHRoZSBzZXJ2ZXIgcHJvdmlkZXMgc29ydC9maWx0ZXIgbWV0YWRhdGEgdGhhdCBkb2VzIG5vdCBoYXZlIGEgMToxIG1hdGNoIHdpdGggdGhlIGNvbHVtbiBuYW1lcy5cbiAgICogZS5nLiBEZWVwIHBhdGggcHJvcHMsIHByb3BlcnR5IG5hbWUgY29udmVudGlvbiBtaXNtYXRjaCwgZXRjLi4uXG4gICAqL1xuICBhbGlhcz86IHN0cmluZztcblxuICAvKipcbiAgICogT3B0aW9uYWwgdHJhbnNmb3JtZXIgdGhhdCBjb250cm9sIHRoZSB2YWx1ZSBvdXRwdXQgZnJvbSB0aGUgY29tYmluYXRpb24gb2YgYSBjb2x1bW4gYW5kIGEgcm93LlxuICAgKiBUaGUgdmFsdWUgcmV0dXJuZWQgZnJvbSB0aGlzIHRyYW5zZm9ybWVyIHdpbGwgYmUgcmV0dXJuZWQgZnJvbSBgUGJsQ29sdW1uLmdldFZhbHVlYFxuICAgKi9cbiAgdHJhbnNmb3JtPzogKHZhbHVlOiBhbnksIHJvdz86IGFueSwgY29sPzogUGJsQ29sdW1uKSA9PiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGJsTWV0YVJvd0RlZmluaXRpb25zIHtcbiAgcm93Q2xhc3NOYW1lPzogc3RyaW5nO1xuICB0eXBlPzogJ3JvdycgfCAnc3RpY2t5JyB8ICdmaXhlZCc7XG59XG4vKipcbiAqIFJlcHJlc2VudCBhIGxpc3Qgb2YgbWV0YSBjb2x1bW4ncyB0aGF0IHRvZ2V0aGVyIGZvcm0gYSBNRVRBIFJPVy5cbiAqIEluIG90aGVyIHdvcmRzLCB0aGlzIGlzIHRoZSBkZWZpbml0aW9uIG9mIGEgcm93LCB1c2luZyBpdCdzIGJ1aWxkaW5nIGJsb2NrcyAtIHRoZSBjb2x1bW5zLlxuICpcbiAqID4gQSByb3cgaW4gdGhlIGdyaWQgcmVwcmVzZW50cyBhIHJvdyBpbiB0aGUgZGF0YXNvdXJjZSwgQSAqKm1ldGEgcm93KiogZG9lcyBub3QsIGl0IGNhbiByZXByZXNlbnQgYW55dGhpbmcuXG4gKiBNZXRhIHJvd3MgYXJlIGhlYWRlciwgZm9vdGVyIGFuZCBoZWFkZXIgZ3JvdXAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGJsQ29sdW1uU2V0PFQgZXh0ZW5kcyBQYmxNZXRhQ29sdW1uRGVmaW5pdGlvbiB8IFBibENvbHVtbkdyb3VwRGVmaW5pdGlvbj4gZXh0ZW5kcyBQYmxNZXRhUm93RGVmaW5pdGlvbnMge1xuICByb3dJbmRleDogbnVtYmVyO1xuICBjb2xzOiBUW107XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgY29tcGxldGUgY29sdW1uIGRlZmluaXRpb24gc2V0IGZvciBhIGdyaWQuICh0YWJsZSwgaGVhZGVyLCBmb290ZXIgYW5kIGhlYWRlckdyb3VwIGNvbHVtbnMpLlxuICpcbiAqIGBQYmxOZ3JpZENvbHVtbkRlZmluaXRpb25TZXRgIGNvbnRhaW5zIFBPSk8gb2JqZWN0cyAoc2ltcGxlIEpTT04gbGlrZSBvYmplY3RzKSBmb3IgZWFjaCBjb2x1bW4gdHlwZSAoYFBibENvbHVtbkRlZmluaXRpb25gLCBgUGJsTWV0YUNvbHVtbkRlZmluaXRpb25gIGFuZCBgUGJsQ29sdW1uR3JvdXBEZWZpbml0aW9uYClcbiAqIHdoaWNoIGFyZSBsYXRlciB1c2VkIHRvIGNyZWF0ZSBydW50aW1lIGluc3RhbmNlIGZvciBlYWNoIGNvbHVtbiB0eXBlIChgUGJsQ29sdW1uYCwgYFBibE1ldGFDb2x1bW5gIGFuZCBgUGJsQ29sdW1uR3JvdXBgKVxuICpcbiAqIEJlY2F1c2UgYFBibE5ncmlkQ29sdW1uRGVmaW5pdGlvblNldGAgY29udGFpbnMgUE9KTyBvYmplY3RzIGl0IGNhbiBiZSBzZXJpYWxpemVkIGVhc2lseS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYmxOZ3JpZENvbHVtbkRlZmluaXRpb25TZXQge1xuICB0YWJsZToge1xuICAgIGhlYWRlcj86IFBibE1ldGFSb3dEZWZpbml0aW9ucztcbiAgICBmb290ZXI/OiBQYmxNZXRhUm93RGVmaW5pdGlvbnM7XG4gICAgY29sczogUGJsQ29sdW1uRGVmaW5pdGlvbltdO1xuICB9O1xuICBoZWFkZXI6IFBibENvbHVtblNldDxQYmxNZXRhQ29sdW1uRGVmaW5pdGlvbj5bXTtcbiAgZm9vdGVyOiBQYmxDb2x1bW5TZXQ8UGJsTWV0YUNvbHVtbkRlZmluaXRpb24+W107XG4gIGhlYWRlckdyb3VwOiBQYmxDb2x1bW5TZXQ8UGJsQ29sdW1uR3JvdXBEZWZpbml0aW9uPltdO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIGNvbXBsZXRlIGNvbHVtbiBzZXQgZm9yIGEgZ3JpZC4gKHRhYmxlLCBoZWFkZXIsIGZvb3RlciBhbmQgaGVhZGVyR3JvdXAgY29sdW1ucykuXG4gKlxuICogYFBibE5ncmlkQ29sdW1uU2V0YCBjb250YWlucyBydW50aW1lIGluc3RhbmNlcyBvZiBmb3IgZWFjaCBjb2x1bW4gdHlwZSAoYFBibENvbHVtbmAsIGBQYmxNZXRhQ29sdW1uYCBhbmQgYFBibENvbHVtbkdyb3VwYClcbiAqIHdoaWNoXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGJsTmdyaWRDb2x1bW5TZXQge1xuICB0YWJsZToge1xuICAgIGhlYWRlcj86IFBibE1ldGFSb3dEZWZpbml0aW9ucztcbiAgICBmb290ZXI/OiBQYmxNZXRhUm93RGVmaW5pdGlvbnM7XG4gICAgY29sczogUGJsQ29sdW1uW107XG4gIH07XG4gIGhlYWRlcjogUGJsQ29sdW1uU2V0PFBibE1ldGFDb2x1bW4+W107XG4gIGZvb3RlcjogUGJsQ29sdW1uU2V0PFBibE1ldGFDb2x1bW4+W107XG4gIGhlYWRlckdyb3VwOiBQYmxDb2x1bW5TZXQ8UGJsQ29sdW1uR3JvdXA+W107XG4gIGdyb3VwU3RvcmU6IFBibENvbHVtbkdyb3VwU3RvcmU7XG59XG4iXX0=