import { AutoSizeVirtualScrollStrategy, ItemSizeAverager } from './auto-size-cdk';
export class PblNgridAutoSizeVirtualScrollStrategy extends AutoSizeVirtualScrollStrategy {
    constructor(minBufferPx, maxBufferPx, averager = new PblNgridItemSizeAverager()) {
        super(minBufferPx, maxBufferPx, averager);
        this.averager = averager;
    }
    get type() { return 'vScrollAuto'; }
    attachExtApi(extApi) {
        this.extApi = extApi;
    }
    attach(viewport) {
        if (!this.extApi) {
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                throw new Error('Invalid use of attach, you must first attach `PblNgridExtensionApi`');
            }
        }
        super.attach(viewport);
    }
}
export class PblNgridItemSizeAverager extends ItemSizeAverager {
    addSample(range, size) {
        if (this.rowInfo && this.rowInfo.rowLength === 0) {
            this.reset();
        }
        else {
            super.addSample(range, size);
        }
    }
    /**
     * A temp workaround to solve the actual vs wanted rendered row issue in `CdkVirtualScrollViewport`
     *
     * `CdkVirtualScrollViewport.getRenderedRange()` return the rows that the virtual container want's the grid to render
     * however, the actual rendered rows might be different. This is a problem especially in init, when the rendered rows are actually 0
     * but `CdkVirtualScrollViewport.getRenderedRange()` return the initial range of rows that should be rendered. This results in a wrong
     * calculation of the average item size in `ItemSizeAverager`
     *
     * SEE: https://github.com/angular/material2/blob/a9e550e5bf93cd68c342d1a50d8576d8f3812ebe/src/cdk/scrolling/virtual-scroll-viewport.ts#L212-L220
     */
    setRowInfo(rowInfo) {
        this.rowInfo = rowInfo;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0by1zaXplLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9uZ3JpZC9zcmMvbGliL2dyaWQvZmVhdHVyZXMvdmlydHVhbC1zY3JvbGwvc3RyYXRlZ2llcy9jZGstd3JhcHBlcnMvYXV0by1zaXplLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBWWxGLE1BQU0sT0FBTyxxQ0FBc0MsU0FBUSw2QkFBNkI7SUFNdEYsWUFBWSxXQUFtQixFQUFFLFdBQW1CLEVBQWtCLFdBQVcsSUFBSSx3QkFBd0IsRUFBRTtRQUM3RyxLQUFLLENBQUMsV0FBVyxFQUFFLFdBQVcsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUQwQixhQUFRLEdBQVIsUUFBUSxDQUFpQztJQUUvRyxDQUFDO0lBTkQsSUFBSSxJQUFJLEtBQUssT0FBTyxhQUFzQixDQUFDLENBQUMsQ0FBQztJQVE3QyxZQUFZLENBQUMsTUFBNEI7UUFDdkMsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7SUFDdkIsQ0FBQztJQUVELE1BQU0sQ0FBQyxRQUE4QztRQUNuRCxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNoQixJQUFJLE9BQU8sU0FBUyxLQUFLLFdBQVcsSUFBSSxTQUFTLEVBQUU7Z0JBQ2pELE1BQU0sSUFBSSxLQUFLLENBQUMscUVBQXFFLENBQUMsQ0FBQzthQUN4RjtTQUNGO1FBQ0QsS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN6QixDQUFDO0NBQ0Y7QUFFRCxNQUFNLE9BQU8sd0JBQXlCLFNBQVEsZ0JBQWdCO0lBRzVELFNBQVMsQ0FBQyxLQUFnQixFQUFFLElBQVk7UUFDdEMsSUFBSSxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxLQUFLLENBQUMsRUFBRTtZQUNoRCxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7U0FDZDthQUFNO1lBQ0wsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDOUI7SUFDSCxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0gsVUFBVSxDQUFDLE9BQStCO1FBQ3hDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO0lBQ3pCLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExpc3RSYW5nZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2xsZWN0aW9ucyc7XG5pbXBvcnQgeyBBdXRvU2l6ZVZpcnR1YWxTY3JvbGxTdHJhdGVneSwgSXRlbVNpemVBdmVyYWdlciB9IGZyb20gJy4vYXV0by1zaXplLWNkayc7XG5pbXBvcnQgeyBQYmxOZ3JpZEV4dGVuc2lvbkFwaSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2V4dC9ncmlkLWV4dC1hcGknO1xuaW1wb3J0IHsgTmdlVmlydHVhbFRhYmxlUm93SW5mbyB9IGZyb20gJy4uLy4uL3ZpcnR1YWwtc2Nyb2xsLWZvci1vZic7XG5pbXBvcnQgeyBQYmxDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnRDb21wb25lbnQgfSBmcm9tICcuLi8uLi92aXJ0dWFsLXNjcm9sbC12aWV3cG9ydC5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGJsTmdyaWRWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3kgfSBmcm9tICcuLi90eXBlcyc7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi90eXBlcycge1xuICBpbnRlcmZhY2UgUGJsTmdyaWRWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3lNYXAge1xuICAgIHZTY3JvbGxBdXRvOiBQYmxOZ3JpZEF1dG9TaXplVmlydHVhbFNjcm9sbFN0cmF0ZWd5O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQYmxOZ3JpZEF1dG9TaXplVmlydHVhbFNjcm9sbFN0cmF0ZWd5IGV4dGVuZHMgQXV0b1NpemVWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3kgaW1wbGVtZW50cyBQYmxOZ3JpZFZpcnR1YWxTY3JvbGxTdHJhdGVneTwndlNjcm9sbEF1dG8nPiB7XG5cbiAgZ2V0IHR5cGUoKSB7IHJldHVybiAndlNjcm9sbEF1dG8nIGFzIGNvbnN0OyB9XG5cbiAgcHJvdGVjdGVkIGV4dEFwaTogUGJsTmdyaWRFeHRlbnNpb25BcGk7XG5cbiAgY29uc3RydWN0b3IobWluQnVmZmVyUHg6IG51bWJlciwgbWF4QnVmZmVyUHg6IG51bWJlciwgcHVibGljIHJlYWRvbmx5IGF2ZXJhZ2VyID0gbmV3IFBibE5ncmlkSXRlbVNpemVBdmVyYWdlcigpKSB7XG4gICAgc3VwZXIobWluQnVmZmVyUHgsIG1heEJ1ZmZlclB4LCBhdmVyYWdlcik7XG4gIH1cblxuICBhdHRhY2hFeHRBcGkoZXh0QXBpOiBQYmxOZ3JpZEV4dGVuc2lvbkFwaSk6IHZvaWQge1xuICAgIHRoaXMuZXh0QXBpID0gZXh0QXBpO1xuICB9XG5cbiAgYXR0YWNoKHZpZXdwb3J0OiBQYmxDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnRDb21wb25lbnQpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuZXh0QXBpKSB7XG4gICAgICBpZiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1c2Ugb2YgYXR0YWNoLCB5b3UgbXVzdCBmaXJzdCBhdHRhY2ggYFBibE5ncmlkRXh0ZW5zaW9uQXBpYCcpO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5hdHRhY2godmlld3BvcnQpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQYmxOZ3JpZEl0ZW1TaXplQXZlcmFnZXIgZXh0ZW5kcyBJdGVtU2l6ZUF2ZXJhZ2VyIHtcbiAgcHJpdmF0ZSByb3dJbmZvOiBOZ2VWaXJ0dWFsVGFibGVSb3dJbmZvO1xuXG4gIGFkZFNhbXBsZShyYW5nZTogTGlzdFJhbmdlLCBzaXplOiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy5yb3dJbmZvICYmIHRoaXMucm93SW5mby5yb3dMZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuYWRkU2FtcGxlKHJhbmdlLCBzaXplKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSB0ZW1wIHdvcmthcm91bmQgdG8gc29sdmUgdGhlIGFjdHVhbCB2cyB3YW50ZWQgcmVuZGVyZWQgcm93IGlzc3VlIGluIGBDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnRgXG4gICAqXG4gICAqIGBDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnQuZ2V0UmVuZGVyZWRSYW5nZSgpYCByZXR1cm4gdGhlIHJvd3MgdGhhdCB0aGUgdmlydHVhbCBjb250YWluZXIgd2FudCdzIHRoZSBncmlkIHRvIHJlbmRlclxuICAgKiBob3dldmVyLCB0aGUgYWN0dWFsIHJlbmRlcmVkIHJvd3MgbWlnaHQgYmUgZGlmZmVyZW50LiBUaGlzIGlzIGEgcHJvYmxlbSBlc3BlY2lhbGx5IGluIGluaXQsIHdoZW4gdGhlIHJlbmRlcmVkIHJvd3MgYXJlIGFjdHVhbGx5IDBcbiAgICogYnV0IGBDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnQuZ2V0UmVuZGVyZWRSYW5nZSgpYCByZXR1cm4gdGhlIGluaXRpYWwgcmFuZ2Ugb2Ygcm93cyB0aGF0IHNob3VsZCBiZSByZW5kZXJlZC4gVGhpcyByZXN1bHRzIGluIGEgd3JvbmdcbiAgICogY2FsY3VsYXRpb24gb2YgdGhlIGF2ZXJhZ2UgaXRlbSBzaXplIGluIGBJdGVtU2l6ZUF2ZXJhZ2VyYFxuICAgKlxuICAgKiBTRUU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL21hdGVyaWFsMi9ibG9iL2E5ZTU1MGU1YmY5M2NkNjhjMzQyZDFhNTBkODU3NmQ4ZjM4MTJlYmUvc3JjL2Nkay9zY3JvbGxpbmcvdmlydHVhbC1zY3JvbGwtdmlld3BvcnQudHMjTDIxMi1MMjIwXG4gICAqL1xuICBzZXRSb3dJbmZvKHJvd0luZm86IE5nZVZpcnR1YWxUYWJsZVJvd0luZm8pOiB2b2lkIHtcbiAgICB0aGlzLnJvd0luZm8gPSByb3dJbmZvO1xuICB9XG59XG4iXX0=