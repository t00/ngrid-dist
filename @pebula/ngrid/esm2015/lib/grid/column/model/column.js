import { getValue, deepPathSet, } from '@pebula/ngrid/core';
import { initDefinitions, parseStyleWidth } from './utils';
import { PblColumnGroupStore } from './group-column';
const PBL_NGRID_COLUMN_MARK = Symbol('PblColumn');
const CLONE_PROPERTIES = ['pIndex', 'transform', 'filter', 'sort', 'alias', 'headerType', 'footerType', 'pin'];
export function isPblColumn(def) {
    return def instanceof PblColumn || (def && def[PBL_NGRID_COLUMN_MARK] === true);
}
export class PblColumn {
    constructor(def, groupStore) {
        /**
         * A place to store things...
         * This must be an object, values are shadow-copied so persist data between multiple plugins.
         */
        this.data = {};
        this.defaultWidth = '';
        /**
         * Groups that this column belongs to.
         * WARNING: DO NOT ADD/REMOVE GROUPS DIRECTLY, USE markInGroup/markNotInGroup.
         */
        this._groups = new Set();
        this[PBL_NGRID_COLUMN_MARK] = true;
        if (isPblColumn(def)) {
            initDefinitions(def, this);
            this.prop = def.prop;
            this.path = def.path;
            this.orgProp = def.orgProp;
            this.groupStore = groupStore || def.groupStore;
            this._groups = new Set(def._groups);
            for (const id of Array.from(def._groups.values())) {
                const g = this.groupStore.find(id);
                if (g) {
                    this.markInGroup(g);
                    g.replace(this);
                }
            }
        }
        else {
            const path = def.path || def.prop.split('.');
            const prop = def.path ? def.prop : path.pop();
            def = Object.create(def);
            def.id = def.id || def.prop || def.label;
            def.label = 'label' in def ? def.label : prop;
            if (typeof def.type === 'string') {
                def.type = { name: def.type };
            }
            if (typeof def.headerType === 'string') {
                def.headerType = { name: def.headerType };
            }
            if (typeof def.footerType === 'string') {
                def.footerType = { name: def.footerType };
            }
            initDefinitions(def, this);
            this.groupStore = groupStore || new PblColumnGroupStore();
            this.prop = prop;
            this.orgProp = def.prop;
            if (path.length) {
                this.path = path;
            }
        }
        for (const prop of CLONE_PROPERTIES) {
            if (prop in def) {
                this[prop] = def[prop];
            }
        }
    }
    /**
     * The width in px or % in the following format: ##% or ##px
     * Examples: '50%', '50px'
     */
    get width() { return this._width; }
    set width(value) {
        var _a;
        if (value !== this._width) {
            this._parsedWidth = parseStyleWidth(this._width = value);
            // Error in dev, on prod just let it be unset
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                if (!this._parsedWidth && value) {
                    throw new Error(`Invalid width "${value}" in column ${this.prop}. Valid values are ##% or ##px (50% / 50px)`);
                }
            }
            const isFixedWidth = ((_a = this._parsedWidth) === null || _a === void 0 ? void 0 : _a.type) === 'px';
            Object.defineProperty(this, 'isFixedWidth', { value: isFixedWidth, configurable: true });
        }
    }
    get parsedWidth() { return this._parsedWidth; }
    /**
     * The column def for this column.
     */
    get columnDef() { return this._columnDef; }
    get groups() { return Array.from(this._groups.values()); }
    static extendProperty(name) {
        if (CLONE_PROPERTIES.indexOf(name) === -1) {
            CLONE_PROPERTIES.push(name);
        }
    }
    attach(columnDef) {
        this.detach();
        this._columnDef = columnDef;
        if (this.defaultWidth) {
            this.columnDef.updateWidth(this.width || this.defaultWidth, 'attach');
        }
    }
    detach() {
        this._columnDef = undefined;
    }
    setDefaultWidth(defaultWidth) {
        this.defaultWidth = defaultWidth;
    }
    updateWidth(width) {
        if (width) {
            this.width = width;
        }
        const { columnDef } = this;
        if (columnDef) {
            columnDef.updateWidth(this.width || this.defaultWidth || '', 'update');
        }
    }
    /**
     * Get the value this column points to in the provided row
     */
    getValue(row) { return getValue(this, row); }
    /**
     * Set a value in the provided row where this column points to
     */
    setValue(row, value) { return deepPathSet(row, this, value); }
    /**
     * Mark's that this column belong to the provided group.
     * \> Note that this internal to the column and does not effect the group in any way.
     */
    markInGroup(g) {
        this.groupStore.attach(g, this);
        this._groups.add(g.id);
    }
    /**
     * Mark's that this column does not belong to the provided group.
     * \> Note that this internal to the column and does not effect the group in any way.
     */
    markNotInGroup(g) {
        this.groupStore.detach(g, this);
        return this._groups.delete(g.id);
    }
    isInGroup(g) {
        return this._groups.has(g.id);
    }
    getGroupOfRow(rowIndex) {
        const groupIds = this.groups;
        for (const id of groupIds) {
            const g = this.groupStore.find(id);
            if (g && g.rowIndex === rowIndex) {
                return g;
            }
        }
    }
    groupLogic(columnGroups, groupExists) {
        const [gPrev, gCurr, gNext] = columnGroups;
        // STATE: This column has same group of previous column, nothing to do.
        if (gCurr === gPrev) {
            return gCurr;
        }
        // STATE: The group exists in one of the columns BUT NOT in the LAST COLUMN (i.e: Its a slave split)
        if (groupExists) {
            // If the previous sibling group is a slave and this group is the origin of the slave, convert this group to the slave.
            if (gPrev && gCurr === gPrev.slaveOf) {
                return gPrev;
            }
            if (gNext && gCurr === gNext.slaveOf) {
                return gNext;
            }
            // Otherwise create the slave.
            const g = gCurr.createSlave([this]);
            this.groupStore.add(g);
            // If the current group is a placeholder and either the previous OR next sibling group is a placeholder as well
            // we want to group them together, although they are not related, because they both have identical headers (empty header).
            // Note that we still create the salve, we just don't use it.
            if (gCurr.placeholder) {
                const prevPH = gPrev && gPrev.placeholder;
                const nextPH = gNext && gNext.slaveOf && gNext.placeholder;
                const groupWithPlaceholder = prevPH ? gPrev : nextPH ? gNext : undefined;
                // const groupWithPlaceholder = prevPH && gPrev;
                if (groupWithPlaceholder) {
                    return groupWithPlaceholder;
                }
            }
            return g;
        }
        else if (gCurr === null || gCurr === void 0 ? void 0 : gCurr.slaveOf) {
            // STATE: The group IS a slave and it is set AFTER an item that belongs to the group it is slave of.
            if (gCurr.slaveOf === gPrev) {
                return gCurr.slaveOf;
            }
            if (gCurr.slaveOf === (gPrev === null || gPrev === void 0 ? void 0 : gPrev.slaveOf)) {
                return gPrev;
            }
            // STATE: The group IS a slave and it is set BEFORE an item that belongs to the group it is slave of.
            if (gCurr.slaveOf === gNext) {
                return gCurr.slaveOf;
            }
        }
        else {
            if ((gPrev === null || gPrev === void 0 ? void 0 : gPrev.placeholder) && (gCurr === null || gCurr === void 0 ? void 0 : gCurr.placeholder)) {
                return gPrev;
            }
        }
        return gCurr;
    }
    /**
     * Calculates if the column width is locked by a maximum by checking if the given width is equal to the max width.
     * If the result of the calculation (true/false) does not equal the previous lock state it will set the new lock state
     * and return true.
     * Otherwise return false.
     * @internal
     */
    checkMaxWidthLock(actualWidth) {
        if (actualWidth === this.maxWidth) {
            if (!this.maxWidthLock) {
                this.maxWidthLock = true;
                return true;
            }
        }
        else if (this.maxWidthLock) {
            this.maxWidthLock = false;
            return true;
        }
        return false;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sdW1uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9uZ3JpZC9zcmMvbGliL2dyaWQvY29sdW1uL21vZGVsL2NvbHVtbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBR0wsUUFBUSxFQUFFLFdBQVcsR0FDdEIsTUFBTSxvQkFBb0IsQ0FBQztBQUs1QixPQUFPLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUMzRCxPQUFPLEVBQWtCLG1CQUFtQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFckUsTUFBTSxxQkFBcUIsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDbEQsTUFBTSxnQkFBZ0IsR0FBMkIsQ0FBQyxRQUFRLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFFdkksTUFBTSxVQUFVLFdBQVcsQ0FBQyxHQUFRO0lBQ2xDLE9BQU8sR0FBRyxZQUFZLFNBQVMsSUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMscUJBQXFCLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQztBQUNsRixDQUFDO0FBRUQsTUFBTSxPQUFPLFNBQVM7SUE2THBCLFlBQVksR0FBb0MsRUFBRSxVQUFnQztRQTlJbEY7OztXQUdHO1FBQ0gsU0FBSSxHQUFRLEVBQUUsQ0FBQztRQWtJUCxpQkFBWSxHQUFHLEVBQUUsQ0FBQztRQUUxQjs7O1dBR0c7UUFDSyxZQUFPLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztRQUdsQyxJQUFJLENBQUMscUJBQXFCLENBQUMsR0FBRyxJQUFJLENBQUM7UUFFbkMsSUFBSSxXQUFXLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDcEIsZUFBZSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUMzQixJQUFJLENBQUMsSUFB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QUNMLElBQUksQ0FBQSxLQUFLLGFBQUwsS0FBSyx1QkFBTCxLQUFLLENBQUUsV0FBVyxNQUFJLEtBQUssYUFBTCxLQUFLLHVCQUFMLEtBQUssQ0FBRSxXQUFXLENBQUEsRUFBRTtnQkFDNUMsT0FBTyxLQUFLLENBQUM7YUFDZDtTQUNGO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsaUJBQWlCLENBQUMsV0FBbUI7UUFDbkMsSUFBSSxXQUFXLEtBQUssSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNqQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtnQkFDdEIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7Z0JBQ3pCLE9BQU8sSUFBSSxDQUFDO2FBQ2I7U0FDRjthQUFNLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUM1QixJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQztZQUMxQixPQUFPLElBQUksQ0FBQztTQUNiO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0NBRUYiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgRGF0YVNvdXJjZUNvbHVtblByZWRpY2F0ZSwgUGJsTmdyaWRTb3J0ZXIsXG4gIFBibENvbHVtbkRlZmluaXRpb24sIFBibENvbHVtblR5cGVEZWZpbml0aW9uLFxuICBnZXRWYWx1ZSwgZGVlcFBhdGhTZXQsXG59IGZyb20gJ0BwZWJ1bGEvbmdyaWQvY29yZSc7XG5cbmltcG9ydCB7IFBibE5ncmlkTWV0YUNlbGxDb250ZXh0LCBQYmxOZ3JpZENlbGxDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC90eXBlcyc7XG5pbXBvcnQgeyBQYmxOZ3JpZENvbHVtbkRlZiB9IGZyb20gJy4uL2RpcmVjdGl2ZXMvY29sdW1uLWRlZic7XG5pbXBvcnQgeyBQYmxDb2x1bW5TaXplSW5mbyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgaW5pdERlZmluaXRpb25zLCBwYXJzZVN0eWxlV2lkdGggfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IFBibENvbHVtbkdyb3VwLCBQYmxDb2x1bW5Hcm91cFN0b3JlIH0gZnJvbSAnLi9ncm91cC1jb2x1bW4nO1xuXG5jb25zdCBQQkxfTkdSSURfQ09MVU1OX01BUksgPSBTeW1ib2woJ1BibENvbHVtbicpO1xuY29uc3QgQ0xPTkVfUFJPUEVSVElFUzogQXJyYXk8a2V5b2YgUGJsQ29sdW1uPiA9IFsncEluZGV4JywgJ3RyYW5zZm9ybScsICdmaWx0ZXInLCAnc29ydCcsICdhbGlhcycsICdoZWFkZXJUeXBlJywgJ2Zvb3RlclR5cGUnLCAncGluJ107XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BibENvbHVtbihkZWY6IGFueSk6IGRlZiBpcyBQYmxDb2x1bW4ge1xuICByZXR1cm4gZGVmIGluc3RhbmNlb2YgUGJsQ29sdW1uIHx8IChkZWYgJiYgZGVmW1BCTF9OR1JJRF9DT0xVTU5fTUFSS10gPT09IHRydWUpO1xufVxuXG5leHBvcnQgY2xhc3MgUGJsQ29sdW1uIGltcGxlbWVudHMgUGJsQ29sdW1uRGVmaW5pdGlvbiB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZW4gc2V0LCBkZWZpbmVzIHRoaXMgY29sdW1uIGFzIHRoZSBwcmltYXJ5IGluZGV4IG9mIHRoZSBkYXRhLXNldCB3aXRoIGFsbCB2YWx1ZXMgaW4gdGhpcyBjb2x1bW4gYmVpbmcgdW5pcXVlLlxuICAgKi9cbiAgcEluZGV4PzogYm9vbGVhbjtcblxuICBsYWJlbD86IHN0cmluZztcblxuICAvKipcbiAgICogQ1NTIGNsYXNzIHRoYXQgZ2V0IGFwcGxpZWQgb24gdGhlIGhlYWRlciBhbmQgY2VsbC5cbiAgICogWW91IGNhbiBhcHBseSB1bmlxdWUgaGVhZGVyL2NlbGwgc3R5bGVzIHVzaW5nIHRoZSBlbGVtZW50IG5hbWUuXG4gICAqL1xuICBjc3M/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB3aWR0aCBpbiBweCBvciAlIGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiAjIyUgb3IgIyNweFxuICAgKiBFeGFtcGxlczogJzUwJScsICc1MHB4J1xuICAgKi9cbiAgZ2V0IHdpZHRoKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl93aWR0aDsgfVxuICBzZXQgd2lkdGgodmFsdWU6IHN0cmluZykge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fd2lkdGgpIHtcbiAgICAgIHRoaXMuX3BhcnNlZFdpZHRoID0gcGFyc2VTdHlsZVdpZHRoKHRoaXMuX3dpZHRoID0gdmFsdWUpO1xuXG4gICAgICAvLyBFcnJvciBpbiBkZXYsIG9uIHByb2QganVzdCBsZXQgaXQgYmUgdW5zZXRcbiAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wYXJzZWRXaWR0aCAmJiB2YWx1ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB3aWR0aCBcIiR7dmFsdWV9XCIgaW4gY29sdW1uICR7dGhpcy5wcm9wfS4gVmFsaWQgdmFsdWVzIGFyZSAjIyUgb3IgIyNweCAoNTAlIC8gNTBweClgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0ZpeGVkV2lkdGggPSB0aGlzLl9wYXJzZWRXaWR0aD8udHlwZSA9PT0gJ3B4JztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaXNGaXhlZFdpZHRoJywgeyB2YWx1ZTogaXNGaXhlZFdpZHRoLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1pbmltdW0gd2lkdGggaW4gcGl4ZWxzXG4gICAqIFRoaXMgaXMgYW4gYWJzb2x1dGUgdmFsdWUsIHRodXMgYSBudW1iZXIuXG4gICAqL1xuICBtaW5XaWR0aD86IG51bWJlcjtcbiAgLyoqXG4gICAqIFRoaXMgbWF4aW11bSB3aWR0aCBpbiBwaXhlbHNcbiAgICogVGhpcyBpcyBhbiBhYnNvbHV0ZSB2YWx1ZSwgdGh1cyBhIG51bWJlci5cbiAgICovXG4gIG1heFdpZHRoPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBBIHBsYWNlIHRvIHN0b3JlIHRoaW5ncy4uLlxuICAgKiBUaGlzIG11c3QgYmUgYW4gb2JqZWN0LCB2YWx1ZXMgYXJlIHNoYWRvdy1jb3BpZWQgc28gcGVyc2lzdCBkYXRhIGJldHdlZW4gbXVsdGlwbGUgcGx1Z2lucy5cbiAgICovXG4gIGRhdGE6IGFueSA9IHt9O1xuXG4gIGdldCBwYXJzZWRXaWR0aCgpOiB7IHZhbHVlOiBudW1iZXI7IHR5cGU6ICdweCcgfCAnJScgfSB8IHVuZGVmaW5lZCB7IHJldHVybiB0aGlzLl9wYXJzZWRXaWR0aDsgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHJvcGVydHkgdG8gZGlzcGxheSAoZnJvbSB0aGUgcm93IGVsZW1lbnQpXG4gICAqIFlvdSBjYW4gdXNlIGRvdCBub3RhdGlvbiB0byBkaXNwbGF5IGRlZXAgcGF0aHMuXG4gICAqL1xuICBwcm9wOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgcGF0aCB0byBhIG5lc3RlZCBvYmplY3QsIHJlbGF0aXZlIHRvIHRoZSByb3cgZWxlbWVudC5cbiAgICogVGhlIHRhYmxlIHdpbGwgZGlzcGxheSBgcHJvcGAgZnJvbSB0aGUgb2JqZWN0IHJlZmVyZW5jZWQgYnkgYHBhdGhgLlxuICAgKlxuICAgKiBZb3UgY2FuIGFsc28gdXNlIGRvdCBub3RhdGlvbiBkaXJlY3RseSBmcm9tIGBwcm9wYC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogcHJvcDogXCJzdHJlZXRcIlxuICAgKiBwYXRoOiBbIFwibXlJbnN0YW5jZVwiLCBcInVzZXJcIiwgXCJhZGRyZXNzXCJcbiAgICpcbiAgICogaXMgaWRlbnRpY2FsIHRvOlxuICAgKiBwcm9wOiBcIm15SW5zdGFuY2UudXNlci5hZGRyZXNzLnN0cmVldFwiXG4gICAqXG4gICAqL1xuICBwYXRoPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZXMgaW4gdGhpcyBjb2x1bW4uXG4gICAqIFRoaXMgaXMgYW4gYWRkaXRpb25hbCBsZXZlbCBmb3IgbWF0Y2hpbmcgY29sdW1ucyB0byB0ZW1wbGF0ZXMsIGdyb3VwaW5nIHRlbXBsYXRlcyBmb3IgYSB0eXBlLlxuICAgKi9cbiAgdHlwZT86IFBibENvbHVtblR5cGVEZWZpbml0aW9uO1xuICBoZWFkZXJUeXBlPzogUGJsQ29sdW1uVHlwZURlZmluaXRpb247XG4gIGZvb3RlclR5cGU/OiBQYmxDb2x1bW5UeXBlRGVmaW5pdGlvbjtcblxuICBzb3J0PzogYm9vbGVhbiB8IFBibE5ncmlkU29ydGVyO1xuXG4gIC8qKlxuICAgKiBBIGN1c3RvbSBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gZmlsdGVyIHJvd3MgdXNpbmcgdGhlIGN1cnJlbnQgY29sdW1uLlxuICAgKlxuICAgKiBWYWxpZCBvbmx5IHdoZW4gZmlsdGVyaW5nIGJ5IHZhbHVlLlxuICAgKiBTZWUgYFBibERhdGFTb3VyY2Uuc2V0RmlsdGVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGZpbHRlcj86IERhdGFTb3VyY2VDb2x1bW5QcmVkaWNhdGU7XG5cbiAgLyoqXG4gICAqIE1hcmtzIHRoZSB0YWJsZSBhcyBlZGl0YWJsZS4gQW4gZWRpdGFibGUgY29sdW1uIGFsc28gcmVxdWlyZXMgYW4gZWRpdCB0ZW1wbGF0ZSB0byBxdWFsaWZ5IGFzIGVkaXRhYmxlLCB0aGlzIGZsYWcgYWxvbmUgaXMgbm90IGVub3VnaC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgZmxhZyBvbmx5IGVmZmVjdCB0aGUgQ1NTIGNsYXNzIGFkZGVkIHRvIHRoZSBjZWxsLlxuICAgKi9cbiAgZWRpdGFibGU6IGJvb2xlYW47XG5cbiAgcGluOiAnc3RhcnQnIHwgJ2VuZCcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEFuIGFsaWFzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGNvbHVtbi5cbiAgICogVXNlZnVsIHdoZW4gdGhlIHNlcnZlciBwcm92aWRlcyBzb3J0L2ZpbHRlciBtZXRhZGF0YSB0aGF0IGRvZXMgbm90IGhhdmUgYSAxOjEgbWF0Y2ggd2l0aCB0aGUgY29sdW1uIG5hbWVzLlxuICAgKiBlLmcuIERlZXAgcGF0aCBwcm9wcywgcHJvcGVydHkgbmFtZSBjb252ZW50aW9uIG1pc21hdGNoLCBldGMuLi5cbiAgICovXG4gIGFsaWFzPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCB0cmFuc2Zvcm1lciB0aGF0IGNvbnRyb2wgdGhlIHZhbHVlIG91dHB1dCBmcm9tIHRoZSBjb21iaW5hdGlvbiBvZiBhIGNvbHVtbiBhbmQgYSByb3cuXG4gICAqIFRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoaXMgdHJhbnNmb3JtZXIgd2lsbCBiZSByZXR1cm5lZCBmcm9tIGBQYmxDb2x1bW4uZ2V0VmFsdWVgXG4gICAqL1xuICB0cmFuc2Zvcm0/OiAodmFsdWU6IGFueSwgcm93PzogYW55LCBjb2w/OiBQYmxDb2x1bW5EZWZpbml0aW9uKSA9PiBhbnk7XG5cbiAgLyoqXG4gICAqIFRoZSBvcmlnaW5hbCB2YWx1ZSBvZiBgcHJvcGAuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb3JnUHJvcDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IHBibC1uZ3JpZCB0byBhcHBseSBjdXN0b20gY2VsbCB0ZW1wbGF0ZSwgb3IgdGhlIGRlZmF1bHQgd2hlbiBub3Qgc2V0LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNlbGxUcGw6IFRlbXBsYXRlUmVmPFBibE5ncmlkQ2VsbENvbnRleHQ8YW55Pj47XG4gICAgLyoqXG4gICAqIFVzZWQgYnkgcGJsLW5ncmlkIHRvIGFwcGx5IGN1c3RvbSBjZWxsIHRlbXBsYXRlLCBvciB0aGUgZGVmYXVsdCB3aGVuIG5vdCBzZXQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZWRpdG9yVHBsOiBUZW1wbGF0ZVJlZjxQYmxOZ3JpZENlbGxDb250ZXh0PGFueT4+O1xuICAvKipcbiAgICogVXNlZCBieSBwYmwtbmdyaWQgdG8gYXBwbHkgYSBjdXN0b20gaGVhZGVyIGNlbGwgdGVtcGxhdGUsIG9yIHRoZSBkZWZhdWx0IHdoZW4gbm90IHNldC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBoZWFkZXJDZWxsVHBsOiBUZW1wbGF0ZVJlZjxQYmxOZ3JpZE1ldGFDZWxsQ29udGV4dDxhbnk+PjtcbiAgLyoqXG4gICAqIFVzZWQgYnkgcGJsLW5ncmlkIHRvIGFwcGx5IGEgY3VzdG9tIGZvb3RlciBjZWxsIHRlbXBsYXRlLCBvciB0aGUgZGVmYXVsdCB3aGVuIG5vdCBzZXQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZm9vdGVyQ2VsbFRwbDogVGVtcGxhdGVSZWY8UGJsTmdyaWRNZXRhQ2VsbENvbnRleHQ8YW55Pj47XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgdGhlIGxpYnJhcnkgYXMgYSBsb2dpY2FsIGZsYWcgcmVwcmVzZW50aW5nIHRoZSBjb2x1bW4gaGlkZGVuIHN0YXRlLlxuICAgKiBUaGlzIGZsYWcgZG9lcyBub3QgZWZmZWN0IHRoZSBVSSwgY2hhbmdpbmcgaXQgd2lsbCBub3QgY2hhbmdlIGhlIGhpZGRlbiBzdGF0ZSBpbiB0aGUgVUkuXG4gICAqIERvIG5vdCBzZXQgdGhpcyB2YWx1ZSBtYW51YWxseS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBoaWRkZW46IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZW4gdHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgd2lkdGggaXMgc2V0IHdpdGggdHlwZSBwaXhlbHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVhZG9ubHkgaXNGaXhlZFdpZHRoPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQW4gb24tZGVtYW5kIHNpemUgaW5mbyBvYmplY3QsIHBvcHVsYXRlZCBieSBgUGJsQ29sdW1uU2l6ZU9ic2VydmVyYFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNpemVJbmZvPzogUGJsQ29sdW1uU2l6ZUluZm87XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBtYXhXaWR0aExvY2s6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBjb2x1bW4gZGVmIGZvciB0aGlzIGNvbHVtbi5cbiAgICovXG4gIGdldCBjb2x1bW5EZWYoKTogUGJsTmdyaWRDb2x1bW5EZWY8UGJsQ29sdW1uPiB7IHJldHVybiB0aGlzLl9jb2x1bW5EZWY7IH1cblxuICBnZXQgZ3JvdXBzKCk6IHN0cmluZ1tdIHsgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fZ3JvdXBzLnZhbHVlcygpKTsgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHVibGljIHJlYWRvbmx5IGdyb3VwU3RvcmU6IFBibENvbHVtbkdyb3VwU3RvcmU7XG5cbiAgcHJpdmF0ZSBfd2lkdGg/OiBzdHJpbmc7XG4gIHByaXZhdGUgX3BhcnNlZFdpZHRoOiBSZXR1cm5UeXBlPHR5cGVvZiBwYXJzZVN0eWxlV2lkdGg+O1xuXG4gIHByaXZhdGUgX2NvbHVtbkRlZjogUGJsTmdyaWRDb2x1bW5EZWY8UGJsQ29sdW1uPjtcbiAgcHJpdmF0ZSBkZWZhdWx0V2lkdGggPSAnJztcblxuICAvKipcbiAgICogR3JvdXBzIHRoYXQgdGhpcyBjb2x1bW4gYmVsb25ncyB0by5cbiAgICogV0FSTklORzogRE8gTk9UIEFERC9SRU1PVkUgR1JPVVBTIERJUkVDVExZLCBVU0UgbWFya0luR3JvdXAvbWFya05vdEluR3JvdXAuXG4gICAqL1xuICBwcml2YXRlIF9ncm91cHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICBjb25zdHJ1Y3RvcihkZWY6IFBibENvbHVtbiB8IFBibENvbHVtbkRlZmluaXRpb24sIGdyb3VwU3RvcmU/OiBQYmxDb2x1bW5Hcm91cFN0b3JlKSB7XG4gICAgdGhpc1tQQkxfTkdSSURfQ09MVU1OX01BUktdID0gdHJ1ZTtcblxuICAgIGlmIChpc1BibENvbHVtbihkZWYpKSB7XG4gICAgICBpbml0RGVmaW5pdGlvbnMoZGVmLCB0aGlzKTtcbiAgICAgIHRoaXMucHJvcCA9IGRlZi5wcm9wO1xuICAgICAgdGhpcy5wYXRoID0gZGVmLnBhdGg7XG4gICAgICB0aGlzLm9yZ1Byb3AgPSBkZWYub3JnUHJvcDtcbiAgICAgIHRoaXMuZ3JvdXBTdG9yZSA9IGdyb3VwU3RvcmUgfHwgZGVmLmdyb3VwU3RvcmU7XG4gICAgICB0aGlzLl9ncm91cHMgPSBuZXcgU2V0PHN0cmluZz4oZGVmLl9ncm91cHMpO1xuICAgICAgZm9yIChjb25zdCBpZCBvZiBBcnJheS5mcm9tKGRlZi5fZ3JvdXBzLnZhbHVlcygpKSkge1xuICAgICAgICBjb25zdCBnID0gdGhpcy5ncm91cFN0b3JlLmZpbmQoaWQpO1xuICAgICAgICBpZiAoZykge1xuICAgICAgICAgIHRoaXMubWFya0luR3JvdXAoZyk7XG4gICAgICAgICAgZy5yZXBsYWNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBhdGggPSBkZWYucGF0aCB8fCBkZWYucHJvcC5zcGxpdCgnLicpO1xuICAgICAgY29uc3QgcHJvcCA9IGRlZi5wYXRoID8gZGVmLnByb3AgOiBwYXRoLnBvcCgpO1xuXG4gICAgICBkZWYgPSBPYmplY3QuY3JlYXRlKGRlZik7XG4gICAgICBkZWYuaWQgPSBkZWYuaWQgfHwgZGVmLnByb3AgfHwgZGVmLmxhYmVsO1xuICAgICAgZGVmLmxhYmVsID0gJ2xhYmVsJyBpbiBkZWYgPyBkZWYubGFiZWwgOiBwcm9wO1xuXG4gICAgICBpZiAodHlwZW9mIGRlZi50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBkZWYudHlwZSA9IHsgbmFtZTogZGVmLnR5cGUgfSBhcyBhbnk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRlZi5oZWFkZXJUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBkZWYuaGVhZGVyVHlwZSA9IHsgbmFtZTogZGVmLmhlYWRlclR5cGUgfSBhcyBhbnk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRlZi5mb290ZXJUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBkZWYuZm9vdGVyVHlwZSA9IHsgbmFtZTogZGVmLmZvb3RlclR5cGUgfSBhcyBhbnk7XG4gICAgICB9XG5cbiAgICAgIGluaXREZWZpbml0aW9ucyhkZWYsIHRoaXMpO1xuXG4gICAgICB0aGlzLmdyb3VwU3RvcmUgPSBncm91cFN0b3JlIHx8IG5ldyBQYmxDb2x1bW5Hcm91cFN0b3JlKCk7XG4gICAgICB0aGlzLnByb3AgPSBwcm9wO1xuICAgICAgdGhpcy5vcmdQcm9wID0gZGVmLnByb3A7XG4gICAgICBpZiAocGF0aC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgQ0xPTkVfUFJPUEVSVElFUykge1xuICAgICAgaWYgKHByb3AgaW4gZGVmKSB7XG4gICAgICAgIHRoaXNbcHJvcCBhcyBhbnldID0gZGVmW3Byb3BdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGV4dGVuZFByb3BlcnR5KG5hbWU6IGtleW9mIFBibENvbHVtbik6IHZvaWQge1xuICAgIGlmIChDTE9ORV9QUk9QRVJUSUVTLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICBDTE9ORV9QUk9QRVJUSUVTLnB1c2gobmFtZSk7XG4gICAgfVxuICB9XG5cbiAgYXR0YWNoKGNvbHVtbkRlZjogUGJsTmdyaWRDb2x1bW5EZWY8UGJsQ29sdW1uPik6IHZvaWQge1xuICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgdGhpcy5fY29sdW1uRGVmID0gY29sdW1uRGVmO1xuICAgIGlmICh0aGlzLmRlZmF1bHRXaWR0aCkge1xuICAgICAgdGhpcy5jb2x1bW5EZWYudXBkYXRlV2lkdGgodGhpcy53aWR0aCB8fCB0aGlzLmRlZmF1bHRXaWR0aCwgJ2F0dGFjaCcpO1xuICAgIH1cbiAgfVxuXG4gIGRldGFjaCgpOiB2b2lkIHtcbiAgICB0aGlzLl9jb2x1bW5EZWYgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBzZXREZWZhdWx0V2lkdGgoZGVmYXVsdFdpZHRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmRlZmF1bHRXaWR0aCA9IGRlZmF1bHRXaWR0aDtcbiAgfVxuXG4gIHVwZGF0ZVdpZHRoKHdpZHRoPzogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHdpZHRoKSB7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgfVxuICAgIGNvbnN0IHsgY29sdW1uRGVmIH0gPSB0aGlzO1xuICAgIGlmIChjb2x1bW5EZWYpIHtcbiAgICAgIGNvbHVtbkRlZi51cGRhdGVXaWR0aCh0aGlzLndpZHRoIHx8IHRoaXMuZGVmYXVsdFdpZHRoIHx8ICcnLCAndXBkYXRlJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgdGhpcyBjb2x1bW4gcG9pbnRzIHRvIGluIHRoZSBwcm92aWRlZCByb3dcbiAgICovXG4gIGdldFZhbHVlPFQgPSBhbnk+KHJvdzogYW55KTogVCB7IHJldHVybiBnZXRWYWx1ZSh0aGlzLCByb3cpOyB9XG5cbiAgLyoqXG4gICAqIFNldCBhIHZhbHVlIGluIHRoZSBwcm92aWRlZCByb3cgd2hlcmUgdGhpcyBjb2x1bW4gcG9pbnRzIHRvXG4gICAqL1xuICBzZXRWYWx1ZShyb3c6IGFueSwgdmFsdWU6IGFueSk6IHZvaWQgeyByZXR1cm4gZGVlcFBhdGhTZXQocm93LCB0aGlzLCB2YWx1ZSk7IH1cblxuICAvKipcbiAgICogTWFyaydzIHRoYXQgdGhpcyBjb2x1bW4gYmVsb25nIHRvIHRoZSBwcm92aWRlZCBncm91cC5cbiAgICogXFw+IE5vdGUgdGhhdCB0aGlzIGludGVybmFsIHRvIHRoZSBjb2x1bW4gYW5kIGRvZXMgbm90IGVmZmVjdCB0aGUgZ3JvdXAgaW4gYW55IHdheS5cbiAgICovXG4gIG1hcmtJbkdyb3VwKGc6IFBibENvbHVtbkdyb3VwKTogdm9pZCB7XG4gICAgdGhpcy5ncm91cFN0b3JlLmF0dGFjaChnLCB0aGlzKTtcbiAgICB0aGlzLl9ncm91cHMuYWRkKGcuaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcmsncyB0aGF0IHRoaXMgY29sdW1uIGRvZXMgbm90IGJlbG9uZyB0byB0aGUgcHJvdmlkZWQgZ3JvdXAuXG4gICAqIFxcPiBOb3RlIHRoYXQgdGhpcyBpbnRlcm5hbCB0byB0aGUgY29sdW1uIGFuZCBkb2VzIG5vdCBlZmZlY3QgdGhlIGdyb3VwIGluIGFueSB3YXkuXG4gICAqL1xuICBtYXJrTm90SW5Hcm91cChnOiBQYmxDb2x1bW5Hcm91cCk6IGJvb2xlYW4ge1xuICAgIHRoaXMuZ3JvdXBTdG9yZS5kZXRhY2goZywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX2dyb3Vwcy5kZWxldGUoZy5pZCk7XG4gIH1cblxuICBpc0luR3JvdXAoZzogUGJsQ29sdW1uR3JvdXApOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JvdXBzLmhhcyhnLmlkKTtcbiAgfVxuXG4gIGdldEdyb3VwT2ZSb3cocm93SW5kZXg6IG51bWJlcik6IFBibENvbHVtbkdyb3VwIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBncm91cElkcyA9IHRoaXMuZ3JvdXBzO1xuICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXBJZHMpIHtcbiAgICAgIGNvbnN0IGcgPSB0aGlzLmdyb3VwU3RvcmUuZmluZChpZCk7XG4gICAgICBpZiAoZyAmJiBnLnJvd0luZGV4ID09PSByb3dJbmRleCkge1xuICAgICAgICByZXR1cm4gZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBncm91cExvZ2ljKGNvbHVtbkdyb3VwczogW1BibENvbHVtbkdyb3VwLCBQYmxDb2x1bW5Hcm91cCwgUGJsQ29sdW1uR3JvdXBdLCBncm91cEV4aXN0czogYm9vbGVhbik6IFBibENvbHVtbkdyb3VwIHtcbiAgICBjb25zdCBbZ1ByZXYsIGdDdXJyLCBnTmV4dF0gPSBjb2x1bW5Hcm91cHM7XG5cbiAgICAvLyBTVEFURTogVGhpcyBjb2x1bW4gaGFzIHNhbWUgZ3JvdXAgb2YgcHJldmlvdXMgY29sdW1uLCBub3RoaW5nIHRvIGRvLlxuICAgIGlmIChnQ3VyciA9PT0gZ1ByZXYpIHtcbiAgICAgIHJldHVybiBnQ3VycjtcbiAgICB9XG5cbiAgICAvLyBTVEFURTogVGhlIGdyb3VwIGV4aXN0cyBpbiBvbmUgb2YgdGhlIGNvbHVtbnMgQlVUIE5PVCBpbiB0aGUgTEFTVCBDT0xVTU4gKGkuZTogSXRzIGEgc2xhdmUgc3BsaXQpXG4gICAgaWYgKGdyb3VwRXhpc3RzKSB7XG4gICAgICAvLyBJZiB0aGUgcHJldmlvdXMgc2libGluZyBncm91cCBpcyBhIHNsYXZlIGFuZCB0aGlzIGdyb3VwIGlzIHRoZSBvcmlnaW4gb2YgdGhlIHNsYXZlLCBjb252ZXJ0IHRoaXMgZ3JvdXAgdG8gdGhlIHNsYXZlLlxuICAgICAgaWYgKGdQcmV2ICYmIGdDdXJyID09PSBnUHJldi5zbGF2ZU9mKSB7XG4gICAgICAgIHJldHVybiBnUHJldjtcbiAgICAgIH1cbiAgICAgIGlmIChnTmV4dCAmJiBnQ3VyciA9PT0gZ05leHQuc2xhdmVPZikge1xuICAgICAgICByZXR1cm4gZ05leHQ7XG4gICAgICB9XG4gICAgICAvLyBPdGhlcndpc2UgY3JlYXRlIHRoZSBzbGF2ZS5cbiAgICAgIGNvbnN0IGcgPSBnQ3Vyci5jcmVhdGVTbGF2ZShbdGhpc10pO1xuICAgICAgdGhpcy5ncm91cFN0b3JlLmFkZChnKTtcblxuICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgZ3JvdXAgaXMgYSBwbGFjZWhvbGRlciBhbmQgZWl0aGVyIHRoZSBwcmV2aW91cyBPUiBuZXh0IHNpYmxpbmcgZ3JvdXAgaXMgYSBwbGFjZWhvbGRlciBhcyB3ZWxsXG4gICAgICAvLyB3ZSB3YW50IHRvIGdyb3VwIHRoZW0gdG9nZXRoZXIsIGFsdGhvdWdoIHRoZXkgYXJlIG5vdCByZWxhdGVkLCBiZWNhdXNlIHRoZXkgYm90aCBoYXZlIGlkZW50aWNhbCBoZWFkZXJzIChlbXB0eSBoZWFkZXIpLlxuICAgICAgLy8gTm90ZSB0aGF0IHdlIHN0aWxsIGNyZWF0ZSB0aGUgc2FsdmUsIHdlIGp1c3QgZG9uJ3QgdXNlIGl0LlxuICAgICAgaWYgKGdDdXJyLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgIGNvbnN0IHByZXZQSCA9IGdQcmV2ICYmIGdQcmV2LnBsYWNlaG9sZGVyO1xuICAgICAgICBjb25zdCBuZXh0UEggPSBnTmV4dCAmJiBnTmV4dC5zbGF2ZU9mICYmIGdOZXh0LnBsYWNlaG9sZGVyO1xuICAgICAgICBjb25zdCBncm91cFdpdGhQbGFjZWhvbGRlciA9IHByZXZQSCA/IGdQcmV2IDogbmV4dFBIID8gZ05leHQgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIGNvbnN0IGdyb3VwV2l0aFBsYWNlaG9sZGVyID0gcHJldlBIICYmIGdQcmV2O1xuICAgICAgICBpZiAoZ3JvdXBXaXRoUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICByZXR1cm4gZ3JvdXBXaXRoUGxhY2Vob2xkZXI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGc7XG4gICAgfSBlbHNlIGlmIChnQ3Vycj8uc2xhdmVPZikge1xuICAgICAgLy8gU1RBVEU6IFRoZSBncm91cCBJUyBhIHNsYXZlIGFuZCBpdCBpcyBzZXQgQUZURVIgYW4gaXRlbSB0aGF0IGJlbG9uZ3MgdG8gdGhlIGdyb3VwIGl0IGlzIHNsYXZlIG9mLlxuICAgICAgaWYgKGdDdXJyLnNsYXZlT2YgPT09IGdQcmV2KSB7XG4gICAgICAgIHJldHVybiBnQ3Vyci5zbGF2ZU9mO1xuICAgICAgfVxuICAgICAgaWYgKGdDdXJyLnNsYXZlT2YgPT09IGdQcmV2Py5zbGF2ZU9mKSB7XG4gICAgICAgIHJldHVybiBnUHJldjtcbiAgICAgIH1cbiAgICAgIC8vIFNUQVRFOiBUaGUgZ3JvdXAgSVMgYSBzbGF2ZSBhbmQgaXQgaXMgc2V0IEJFRk9SRSBhbiBpdGVtIHRoYXQgYmVsb25ncyB0byB0aGUgZ3JvdXAgaXQgaXMgc2xhdmUgb2YuXG4gICAgICBpZiAoZ0N1cnIuc2xhdmVPZiA9PT0gZ05leHQpIHtcbiAgICAgICAgcmV0dXJuIGdDdXJyLnNsYXZlT2Y7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChnUHJldj8ucGxhY2Vob2xkZXIgJiYgZ0N1cnI/LnBsYWNlaG9sZGVyKSB7XG4gICAgICAgIHJldHVybiBnUHJldjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdDdXJyO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgaWYgdGhlIGNvbHVtbiB3aWR0aCBpcyBsb2NrZWQgYnkgYSBtYXhpbXVtIGJ5IGNoZWNraW5nIGlmIHRoZSBnaXZlbiB3aWR0aCBpcyBlcXVhbCB0byB0aGUgbWF4IHdpZHRoLlxuICAgKiBJZiB0aGUgcmVzdWx0IG9mIHRoZSBjYWxjdWxhdGlvbiAodHJ1ZS9mYWxzZSkgZG9lcyBub3QgZXF1YWwgdGhlIHByZXZpb3VzIGxvY2sgc3RhdGUgaXQgd2lsbCBzZXQgdGhlIG5ldyBsb2NrIHN0YXRlXG4gICAqIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICogT3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBjaGVja01heFdpZHRoTG9jayhhY3R1YWxXaWR0aDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKGFjdHVhbFdpZHRoID09PSB0aGlzLm1heFdpZHRoKSB7XG4gICAgICBpZiAoIXRoaXMubWF4V2lkdGhMb2NrKSB7XG4gICAgICAgIHRoaXMubWF4V2lkdGhMb2NrID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLm1heFdpZHRoTG9jaykge1xuICAgICAgdGhpcy5tYXhXaWR0aExvY2sgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxufVxuIl19